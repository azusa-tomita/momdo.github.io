<!DOCTYPE html><html data-bug-component="HTML5 spec" data-bug-product="HTML WG" lang="ja"><meta charset="utf-8"><title>4.7 Embedded content — （古）HTML 5.1 日本語訳
    </title><script src="js/bug-assist.js"></script>
<style type="text/css">
body {line-height:1.5}
     .applies thead th > * { display: block; }
     .applies thead code { display: block; }
     .applies tbody th { white-space: nowrap; }
     .applies td { text-align: center; }
     .applies .yes { background: yellow; }

     .matrix, .matrix td { border: hidden; text-align: right; }
     .matrix { margin-left: 2em; }

     .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
     .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
     .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

     td.eg { border-width: thin; text-align: center; }

     #table-example-1 { border: solid thin; border-collapse: collapse; margin-left: 3em; }
     #table-example-1 * { font-family: "Essays1743", serif; line-height: 1.01em; }
     #table-example-1 caption { padding-bottom: 0.5em; }
     #table-example-1 thead, #table-example-1 tbody { border: none; }
     #table-example-1 th, #table-example-1 td { border: solid thin; }
     #table-example-1 th { font-weight: normal; }
     #table-example-1 td { border-style: none solid; vertical-align: top; }
     #table-example-1 th { padding: 0.5em; vertical-align: middle; text-align: center; }
     #table-example-1 tbody tr:first-child td { padding-top: 0.5em; }
     #table-example-1 tbody tr:last-child td { padding-bottom: 1.5em; }
     #table-example-1 tbody td:first-child { padding-left: 2.5em; padding-right: 0; width: 9em; }
     #table-example-1 tbody td:first-child::after { content: leader(". "); }
     #table-example-1 tbody td { padding-left: 2em; padding-right: 2em; }
     #table-example-1 tbody td:first-child + td { width: 10em; }
     #table-example-1 tbody td:first-child + td ~ td { width: 2.5em; }
     #table-example-1 tbody td:first-child + td + td + td ~ td { width: 1.25em; }

     .apple-table-examples { border: none; border-collapse: separate; border-spacing: 1.5em 0em; width: 40em; margin-left: 3em; }
     .apple-table-examples * { font-family: "Times", serif; }
     .apple-table-examples td, .apple-table-examples th { border: none; white-space: nowrap; padding-top: 0; padding-bottom: 0; }
     .apple-table-examples tbody th:first-child { border-left: none; width: 100%; }
     .apple-table-examples thead th:first-child ~ th { font-size: smaller; font-weight: bolder; border-bottom: solid 2px; text-align: center; }
     .apple-table-examples tbody th::after, .apple-table-examples tfoot th::after { content: leader(". ") }
     .apple-table-examples tbody th, .apple-table-examples tfoot th { font: inherit; text-align: left; }
     .apple-table-examples td { text-align: right; vertical-align: top; }
     .apple-table-examples.e1 tbody tr:last-child td { border-bottom: solid 1px; }
     .apple-table-examples.e1 tbody + tbody tr:last-child td { border-bottom: double 3px; }
     .apple-table-examples.e2 th[scope=row] { padding-left: 1em; }
     .apple-table-examples sup { line-height: 0; }

     .details-example img { vertical-align: top; }

     #base64-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 6em;
       column-count: 5;
       column-gap: 1em;
       -moz-column-width: 6em;
       -moz-column-count: 5;
       -moz-column-gap: 1em;
       -webkit-column-width: 6em;
       -webkit-column-count: 5;
       -webkit-column-gap: 1em;
     }
     #base64-table thead { display: none; }
     #base64-table * { border: none; }
     #base64-table tbody td:first-child:after { content: ':'; }
     #base64-table tbody td:last-child { text-align: right; }

     #named-character-references-table {
       white-space: nowrap;
       font-size: 0.6em;
       column-width: 30em;
       column-gap: 1em;
       -moz-column-width: 30em;
       -moz-column-gap: 1em;
       -webkit-column-width: 30em;
       -webkit-column-gap: 1em;
     }
     #named-character-references-table > table > tbody > tr > td:first-child + td,
     #named-character-references-table > table > tbody > tr > td:last-child { text-align: center; }
     #named-character-references-table > table > tbody > tr > td:last-child:hover > span { position: absolute; top: auto; left: auto; margin-left: 0.5em; line-height: 1.2; font-size: 5em; border: outset; padding: 0.25em 0.5em; background: white; width: 1.25em; height: auto; text-align: center; }
     #named-character-references-table > table > tbody > tr#entity-CounterClockwiseContourIntegral > td:first-child { font-size: 0.5em; }

     .glyph.control { color: red; }

     @font-face {
       font-family: 'Essays1743';
       src: url('fonts/Essays1743.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-weight: bold;
       src: url('fonts/Essays1743-Bold.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       src: url('fonts/Essays1743-Italic.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       font-weight: bold;
       src: url('fonts/Essays1743-BoldItalic.ttf');
     }

    </style>
<style type="text/css">
       pre { margin-left: 2em; white-space: pre-wrap; }
       h2 { margin: 3em 0 1em 0; }
       h3 { margin: 2.5em 0 1em 0; }
       h4 { margin: 2.5em 0 0.75em 0; }
       h5, h6 { margin: 2.5em 0 1em; }
       h1 + h2, h1 + h2 + h2, h1 + p, h1 + p + h2 { margin: 0.75em 0 0.75em; }
       h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 0.5em; }
       p { margin: 1em 0; }
       hr:not(.top) { display: block; background: none; border: none; padding: 0; margin: 2em 0; height: auto; }
       .element dd,  .element dl { margin-top: 0em; margin-bottom: 0.25em;}
       dt { margin-top: 0.75em; margin-bottom: 0.5em; clear: left; }
        .element dt { margin-top: 0.5em; margin-bottom: 0.5em;  }
       dt + dt { margin-top: 0; }
       dd dt { margin-top: 0.25em; margin-bottom: 0; }
       dd p { margin-top: 0; }
       dd dl + p { margin-top: 1em; }
       dd table + p { margin-top: 1em; }
       p + * > li, dd li { margin: 1em 0; }
       dt, dfn { font-weight: bold; font-style: normal; }
       i, em { font-style: italic; }
       dt dfn { font-style: italic; }
       pre, code { font-size: inherit; font-family: monospace; font-variant: normal; }
       pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
       pre em { font-weight: bolder; font-style: normal; }
       @media screen { code { color: #D93B00; } code :link, code :visited { color: inherit; } }
       var { background-color: #f9f9f9; border: 1px solid #eee; padding: 0 2px; }
       var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
       table { border-collapse: collapse; border-style: hidden hidden none hidden; }
       table thead, table tbody { border-bottom: solid; }
       table tbody th:first-child { border-left: solid; }
       table tbody th { text-align: left; }
       table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
       blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }

       .bad, .bad *:not(.XXX) { color: #5F6D7A; border-color: gray; background: transparent; }
       .matrix, .matrix td { border: none; text-align: right; }
       .matrix { margin-left: 2em; }
       .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
       .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
       .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

       .toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
       img.extra, p.overview { float: right; }
       pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
       pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
       pre.idl::before { content: "IDL"; font: bold small sans-serif; padding: 0.5em; background: white; position: absolute; top: 0; margin: -1px 0 0 -4em; width: 1.5em; border: thin solid; border-radius: 0 0 0 0.5em }
       pre.css { border: solid thin; background: #FFFFEE; color: black; padding: 0.5em 1em; }
       pre.css:first-line { color: #AAAA50; }
       dl.domintro {padding: 0.5em 1em; border: none; background:#E9FBE9; border: 1px solid lightgray; }
       hr + dl.domintro, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
       dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
       dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
       dl.domintro dd p { margin: 0.5em 0; }
       dl.domintro:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This definition is non-normative. Implementation requirements are given below this definition.'; color: #606060; border:1px solid lightgray; background: white; padding: 0 0.25em;font-size:.9em;}
       dl.switch { padding-left: 2em; }
       dl.switch > dt { text-indent: -1.5em; }
       dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }
       dl.triple { padding: 0 0 0 1em; }
       dl.triple dt, dl.triple dd { margin: 0; display: inline }
       dl.triple dt:after { content: ':'; }
       dl.triple dd:after { content: '\A'; white-space: pre; }
       .diff-old { text-decoration: line-through; color: silver; background: transparent; }
       .diff-chg, .diff-new { text-decoration: underline; color: green; background: transparent; }
       a .diff-new { border-bottom: 1px blue solid; }

       figure.diagrams { border: double black; background: white; padding: 1em; }
       figure.diagrams img { display: block; margin: 1em auto; } 

       h2 { page-break-before: always; }
       h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
       h1 + h2, hr + h2.no-toc { page-break-before: auto; }

       p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang]),
       li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang])
       { border-bottom: solid #9999CC; }

       div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
       div.head p { margin: 0; }
       div.head h1 { margin: 0; }
       div.head .logo { float: right; margin: 0 1em; }
       div.head .logo img { border: none } /* remove border from top image */
       div.head dl { margin: 1em 0; }
       div.head p.copyright, div.head p.alt { font-size: x-small; font-style: oblique; margin: 0; }

       body > .toc > li { margin-top: 1em; margin-bottom: 1em; }
       body > .toc.brief > li { margin-top: 0.35em; margin-bottom: 0.35em; }
       body > .toc > li > * { margin-bottom: 0.5em; }
       body > .toc > li > * > li > * { margin-bottom: 0.25em; }
       .toc, .toc li { list-style: none; }

       .brief { margin-top: 1em; margin-bottom: 1em; line-height: 1.1; }
       .brief li { margin: 0; padding: 0; }
       .brief li p { margin: 0; padding: 0; }

       .category-list { margin-top: -0.75em; margin-bottom: 1em; line-height: 1.5; }
       .category-list::before { content: '\21D2\A0'; font-size: 1.2em; font-weight: 900; }
       .category-list li { display: inline; }
       .category-list li:not(:last-child)::after { content: ', '; }
       .category-list li > span, .category-list li > a { text-transform: lowercase; }
       .category-list li * { text-transform: none; } /* don't affect <code> nested in <a> */

       .XXX { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
       .XXX > :first-child { margin-top: 0; }
       p .XXX { line-height: 3em; }
       .annotation { border: solid thin black; background: #0C479D; color: white; position: relative; margin: 8px 0 20px 0; }
       .annotation:before { position: absolute; left: 0; top: 0; width: 100%; height: 100%; margin: 6px -6px -6px 6px; background: #333333; z-index: -1; content: ''; }
       .annotation :link, .annotation :visited { color: inherit; }
       .annotation :link:hover, .annotation :visited:hover { background: transparent; }
       .annotation span { border: none ! important; }
       .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
       .warning { background-color: #F9F0D4; border: medium double #FF0000; margin: 1em; padding: 1em; }
       .note em, .warning em, .note i, .warning i { font-style: normal; }
       p.note, div.note { padding: 0.5em 2em; }
       span.note { padding: 0 2em; }
       .note p:first-child, .warning p:first-child { margin-top: 0; }
       .note p:last-child, .warning p:last-child { margin-bottom: 0; }
       .warning:before { font-style: normal; }
       p.note:before { content: 'Note: '; font-weight: bolder;}
       p.warning:before { content: '\26A0 Warning! '; font-weight:bolder;}
       .critical {margin:1em; border:double red; padding:1em; background-color:#F9F0D4;}

       .bookkeeping:before { display: block; content: 'Bookkeeping details'; font-weight: bolder; font-style: italic; }
       .bookkeeping { font-size: 0.8em; margin: 2em 0; }
       .bookkeeping p { margin: 0.5em 2em; display: list-item; list-style: square; }
       .bookkeeping dt { margin: 0.5em 2em 0; }
       .bookkeeping dd { margin: 0 3em 0.5em; }

       h4 { position: relative; z-index: 3; }
       h4 + .element, h4 + div + .element { margin-top: -2.5em; padding-top: 2em; }
       .element {
         background: #F4F4FA;
         color: black;
         margin: 0 0 1em 0.15em;
         padding: 0 1em 0.25em 0.75em;
         border-left: solid #9999FF 0.25em;
         position: relative;
         z-index: 1;
       }
       .element:before {
         position: absolute;
         z-index: 2;
         top: 0;
         left: -1.15em;
         height: 2em;
         width: 0.9em;
         background: #F4F4FA;
         content: ' ';
         border-style: none none solid solid;
         border-color: #9999FF;
         border-width: 0.25em;
       }

       .example { display: block; color: #222222; background: #FCFCFC; border-left-style: solid;border-color:#c0c0c0; border-left-width: 0.25em; margin-left: 1em; padding-left: 1em;padding-bottom: 0.5em;}
       div.example:before { content: 'Code Example: '; font-weight: bolder;}
       td > .example:only-child { margin: 0 0 0 0.1em; }

       ul.domTree, ul.domTree ul { padding: 0 0 0 1em; margin: 0; }
       ul.domTree li { padding: 0; margin: 0; list-style: none; position: relative; }
       ul.domTree li li { list-style: none; }
       ul.domTree li:first-child::before { position: absolute; top: 0; height: 0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree li:not(:last-child)::after { position: absolute; top: 0; bottom: -0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree span { font-style: italic; font-family: serif; }
       ul.domTree .t1 code { color: purple; font-weight: bold; }
       ul.domTree .t2 { font-style: normal; font-family: monospace; }
       ul.domTree .t2 .name { color: black; font-weight: bold; }
       ul.domTree .t2 .value { color: blue; font-weight: normal; }
       ul.domTree .t3 code, .domTree .t4 code, .domTree .t5 code { color: gray; }
       ul.domTree .t7 code, .domTree .t8 code { color: green; }
       ul.domTree .t10 code { color: teal; }

       body.dfnEnabled dfn { cursor: pointer; }
       .dfnPanel {
         display: inline;
         position: absolute;
         z-index: 10;
         height: auto;
         width: auto;
         padding: 0.5em 0.75em;
         font: small sans-serif, Droid Sans Fallback;
         background: #DDDDDD;
         color: black;
         border: outset 0.2em;
       }
       .dfnPanel * { margin: 0; padding: 0; font: inherit; text-indent: 0; }
       .dfnPanel :link, .dfnPanel :visited { color: black; }
       .dfnPanel p { font-weight: bolder; }
       .dfnPanel * + p { margin-top: 0.25em; }
       .dfnPanel li { list-style-position: inside; }

       #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
       #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
       #configUI p label { display: block; }
       #configUI #updateUI, #configUI .loginUI { text-align: center; }
       #configUI input[type=button] { display: block; margin: auto; }

       fieldset { margin: 1em; padding: 0.5em 1em; }
       fieldset > legend + * { margin-top: 0; }
       fieldset > :last-child { margin-bottom: 0; }
       fieldset p { margin: 0.5em 0; }
       header p.subline {color:#005A9C; font: 140% sans-serif;margin: 0.75em 0;}
       #authorButton {overflow: visible; padding: 0.1em 0.3em; position: fixed; right: 2em; top: 6em; width: auto;}

       @media print {#authorButton { display:none;}}

  </style><!--<link href="switcher/W3C-ED-au.css" rel="stylesheet" type="text/css">--><link href="notice.css" rel="stylesheet"><link href="https://www.w3.org/StyleSheets/TR/W3C-ED" rel="stylesheet" type="text/css"><script>
   function getCookie(name) {
     var params = location.search.substr(1).split("&");
     for (var index = 0; index < params.length; index++) {
       if (params[index] == name)
         return "1";
       var data = params[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     var cookies = document.cookie.split("; ");
     for (var index = 0; index < cookies.length; index++) {
       var data = cookies[index].split("=");
       if (data[0] == name)
         return unescape(data[1]);
     }
     return null;
   }
  </script><!-- style switcher script by Stommepoes  --><link href="switcher/author-view.css" id="author-view" rel="alternate stylesheet" title="Author documentation only"><script src="switcher/authorstylesheet.js"></script><link href="edits.html" rel="prev" title="4.6 Edits">
  <link href="Overview.html#contents" rel="contents" title="目次">
  <link href="links.html" rel="next" title="4.8 Links">
  <body class="split chapter" onload="fixBrokenLink();"><div class="head" id="head">
<header><span id="styleSwitch"></span>
   <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72"></a></p>

    <h1 id="big-title">HTML 5.1 日本語訳
    </h1>
    <p class="no-num no-toc subline">HTMLとXHTMLのための語彙と関連API</p>
   <p class="no-num no-toc subline">Editor's Draft 2 October 2014</p>
   </header></div>
  

  <nav class="prev_next">
   <a href="edits.html">← 4.6 編集</a> – <a href="Overview.html#contents">目次</a> – <a href="links.html">4.8 リンク →</a>
  <ol class="toc"><li><ol><li><a href="embedded-content.html#embedded-content"><span class="secno">4.7</span> 埋め込みコンテンツ</a>
    <ol><li><a href="embedded-content.html#introduction-0"><span class="secno">4.7.1</span> 導入</a></li><li><a href="embedded-content.html#dependencies-0"><span class="secno">4.7.2</span> 依存関係</a></li><li><a href="embedded-content.html#the-picture-element"><span class="secno">4.7.3</span> <code>picture</code>要素</a></li><li><a href="embedded-content.html#the-source-element-when-used-with-the-picture-element"><span class="secno">4.7.4</span> <code>picture</code>要素とともに使用される場合の<code>source</code>要素</a></li><li><a href="embedded-content.html#the-img-element"><span class="secno">4.7.5</span> <code>img</code>要素</a>
      <ol><li><a href="embedded-content.html#alt"><span class="secno">4.7.5.1</span> 画像に対して代替として動作するテキストを提供に対する要件</a>
        <ol><li><a href="embedded-content.html#examples-of-scenarios-where-users-benefit-from-text-alternatives-for-images"><span class="secno">4.7.5.1.1</span> ユーザーが画像のテキストによる代替の恩恵を受けるシナリオの例</a></li><li><a href="embedded-content.html#general-guidelines"><span class="secno">4.7.5.1.2</span> 一般的なガイドライン</a></li><li><a href="embedded-content.html#a-link-or-button-containing-nothing-but-an-image"><span class="secno">4.7.5.1.3</span> 画像のみを含むリンクまたはボタン</a></li><li><a href="embedded-content.html#graphical-representations:-charts,-diagrams,-graphs,-maps,-illustrations"><span class="secno">4.7.5.1.4</span> グラフィカルな表現：チャート、図、グラフ、マップ、イラスト</a></li><li><a href="embedded-content.html#images-of-text"><span class="secno">4.7.5.1.5</span> テキストの画像</a></li><li><a href="embedded-content.html#images-that-include-text"><span class="secno">4.7.5.1.6</span> テキストを含む画像</a></li><li><a href="embedded-content.html#images-that-enhance-the-themes-or-subject-matter-of-the-page-content"><span class="secno">4.7.5.1.7</span>テーマを向上させる画像やページ内容の主題</a></li><li><a href="embedded-content.html#a-graphical-representation-of-some-of-the-surrounding-text"><span class="secno">4.7.5.1.8</span> 周囲のテキストの一部をグラフィカルに表現</a></li><li><a href="embedded-content.html#a-purely-decorative-image-that-doesn't-add-any-information"><span class="secno">4.7.5.1.9</span> 情報を追加しない、純粋に装飾的な画像</a></li><li><a href="embedded-content.html#inline"><span class="secno">4.7.5.1.10</span> インライン画像</a></li><li><a href="embedded-content.html#a-group-of-images-that-form-a-single-larger-picture-with-no-links"><span class="secno">4.7.5.1.11</span> リンクのない単一の大きな画像を形成する画像のグループ</a></li><li><a href="embedded-content.html#image-maps-0"><span class="secno">4.7.5.1.12</span> イメージマップ</a></li><li><a href="embedded-content.html#a-group-of-images-that-form-a-single-larger-picture-with-links"><span class="secno">4.7.5.1.13</span> リンクのある単一の大きな画像を形成する画像のグループ</a></li><li><a href="embedded-content.html#images-of-pictures"><span class="secno">4.7.5.1.14</span> 写真の画像</a></li><li><a href="embedded-content.html#webcam-images"><span class="secno">4.7.5.1.15</span> ウェブカメラ画像</a></li><li><a href="embedded-content.html#when-a-text-alternative-is-not-available-at-the-time-of-publication"><span class="secno">4.7.5.1.16</span> 公開時にテキストによる代替が利用不能である場合</a></li><li><a href="embedded-content.html#an-image-not-intended-for-the-user"><span class="secno">4.7.5.1.17</span> ユーザーを意図しない画像</a></li><li><a href="embedded-content.html#icon-images"><span class="secno">4.7.5.1.18</span> アイコン画像</a></li><li><a href="embedded-content.html#logos,-insignia,-flags,-or-emblems"><span class="secno">4.7.5.1.19</span> ロゴ、 記号、旗、またはエンブレム</a></li><li><a href="embedded-content.html#captcha-images"><span class="secno">4.7.5.1.20</span> CAPTCHA画像</a></li><li><a href="embedded-content.html#an-image-in-a-picture-element"><span class="secno">4.7.5.1.21</span> <code>picture</code>要素における画像</a></li><li><a href="embedded-content.html#guidance-for-markup-generators"><span class="secno">4.7.5.1.22 </span>Guidance for markup generators</a></li><li><a href="embedded-content.html#guidance-for-conformance-checkers"><span class="secno">4.7.5.1.23 </span>Guidance for conformance checkers</a></li></ol></li></ol></li><li><a href="embedded-content.html#the-iframe-element"><span class="secno">4.7.6</span> <code>iframe</code>要素</a></li><li><a href="embedded-content.html#the-embed-element"><span class="secno">4.7.7</span> <code>embed</code>要素</a></li><li><a href="embedded-content.html#the-object-element"><span class="secno">4.7.8</span> <code>object</code>要素</a></li><li><a href="embedded-content.html#the-param-element"><span class="secno">4.7.9</span> <code>param</code>要素</a></li><li><a href="embedded-content.html#the-video-element"><span class="secno">4.7.10</span> <code>video</code>要素</a></li><li><a href="embedded-content.html#the-audio-element"><span class="secno">4.7.11</span> <code>audio</code>要素</a></li><li><a href="embedded-content.html#the-source-element"><span class="secno">4.7.12</span> <code>source</code>要素</a></li><li><a href="embedded-content.html#the-track-element"><span class="secno">4.7.13</span>  <code>track</code>要素</a></li><li><a href="embedded-content.html#media-elements"><span class="secno">4.7.14</span> メディア要素</a>
      <ol><li><a href="embedded-content.html#error-codes"><span class="secno">4.7.14.1</span> エラーコード</a></li><li><a href="embedded-content.html#location-of-the-media-resource"><span class="secno">4.7.14.2</span> メディアリソースの場所</a></li><li><a href="embedded-content.html#mime-types"><span class="secno">4.7.14.3</span> MIMEタイプ</a></li><li><a href="embedded-content.html#network-states"><span class="secno">4.7.14.4</span> ネットワーク状態</a></li><li><a href="embedded-content.html#loading-the-media-resource"><span class="secno">4.7.14.5</span> メディアリソースの読み込み</a></li><li><a href="embedded-content.html#offsets-into-the-media-resource"><span class="secno">4.7.14.6</span> メディアリソースからのオフセット</a></li><li><a href="embedded-content.html#ready-states"><span class="secno">4.7.14.7</span> 準備状態</a></li><li><a href="embedded-content.html#playing-the-media-resource"><span class="secno">4.7.14.8</span> メディアリソースの再生</a></li><li><a href="embedded-content.html#seeking"><span class="secno">4.7.14.9</span> シーク</a></li><li><a href="embedded-content.html#media-resources-with-multiple-media-tracks"><span class="secno">4.7.14.10</span> 複数のメディアトラックを伴うメディアリソース</a>
        <ol><li><a href="embedded-content.html#audiotracklist-and-videotracklist-objects"><span class="secno">4.7.14.10.1</span> <code>AudioTrackList</code>および<code>VideoTrackList</code>オブジェクト</a></li><li><a href="embedded-content.html#selecting-specific-audio-and-video-tracks-declaratively"><span class="secno">4.7.14.10.2</span> 宣言的に特定のオーディオとビデオトラックを選択する</a></li></ol></li><li><a href="embedded-content.html#synchronising-multiple-media-elements"><span class="secno">4.7.14.11</span> 複数のメディア要素を同期する</a>
        <ol><li><a href="embedded-content.html#introduction-1"><span class="secno">4.7.14.11.1</span> 導入</a></li><li><a href="embedded-content.html#media-controllers"><span class="secno">4.7.14.11.2</span> メディアコントローラ</a></li><li><a href="embedded-content.html#assigning-a-media-controller-declaratively"><span class="secno">4.7.14.11.3</span> 宣言的メディアコントローラを割り当てる</a></li></ol></li><li><a href="embedded-content.html#timed-text-tracks"><span class="secno">4.7.14.12</span> 時限テキストトラック</a>
        <ol><li><a href="embedded-content.html#text-track-model"><span class="secno">4.7.14.12.1</span> テキストトラックモデル</a></li><li><a href="embedded-content.html#sourcing-in-band-text-tracks"><span class="secno">4.7.14.12.2</span> 帯域内テキストトラックの情報源</a></li><li><a href="embedded-content.html#sourcing-out-of-band-text-tracks"><span class="secno">4.7.14.12.3 </span>Sourcing out-of-band text tracks</a></li><li><a href="embedded-content.html#guidelines-for-exposing-cues-in-various-formats-as-text-track-cues"><span class="secno">4.7.14.12.4 </span>Guidelines for exposing cues in various formats as <span data-anolis-xref="text track
  cue">text track cues</span></a></li><li><a href="embedded-content.html#text-track-api"><span class="secno">4.7.14.12.5</span> テキストトラックAPI</a></li><li><a href="embedded-content.html#text-tracks-exposing-in-band-metadata"><span class="secno">4.7.14.12.6 </span>Text tracks exposing in-band metadata</a></li><li><a href="embedded-content.html#text-tracks-describing-chapters"><span class="secno">4.7.14.12.7</span> 章を記述するテキストトラック</a></li><li><a href="embedded-content.html#cue-events"><span class="secno">4.7.14.12.8 </span>Event handlers for objects of the text track APIs</a></li><li><a href="embedded-content.html#best-practices-for-metadata-text-tracks"><span class="secno">4.7.14.12.9 </span>Best practices for metadata text tracks</a></li></ol></li><li><a href="embedded-content.html#user-interface"><span class="secno">4.7.14.13</span> ユーザーインターフェース</a></li><li><a href="embedded-content.html#time-ranges"><span class="secno">4.7.14.14</span> 時間範囲</a></li><li><a href="embedded-content.html#the-trackevent-interface"><span class="secno">4.7.14.15</span> <code>TrackEvent</code>インタフェース</a></li><li><a href="embedded-content.html#mediaevents"><span class="secno">4.7.14.16 </span>Event summary</a></li><li><a href="embedded-content.html#security-and-privacy-considerations"><span class="secno">4.7.14.17 </span>Security and privacy considerations</a></li><li><a href="embedded-content.html#best-practices-for-authors-using-media-elements"><span class="secno">4.7.14.18 </span>Best practices for authors using media elements</a></li><li><a href="embedded-content.html#best-practices-for-implementors-of-media-elements"><span class="secno">4.7.14.19 </span>Best practices for implementors of media elements</a></li></ol></li><li><a href="embedded-content.html#the-map-element"><span class="secno">4.7.15</span> <code>map</code>要素</a></li><li><a href="embedded-content.html#the-area-element"><span class="secno">4.7.16</span> <code>area</code>要素</a></li><li><a href="embedded-content.html#image-maps"><span class="secno">4.7.17</span> イメージマップ</a>
      <ol><li><a href="embedded-content.html#authoring"><span class="secno">4.7.17.1 </span>Authoring</a></li><li><a href="embedded-content.html#processing-model-0"><span class="secno">4.7.17.2 </span>Processing model</a></li></ol></li><li><a href="embedded-content.html#mathml"><span class="secno">4.7.18</span> MathML</a></li><li><a href="embedded-content.html#svg"><span class="secno">4.7.19</span> SVG</a></li><li><a href="embedded-content.html#dimension-attributes"><span class="secno">4.7.20</span> 次元属性</a></li></ol></li></ol></li></ol></nav>
<div> <input id=annoying-warning type=checkbox title="hide note"> <label for=annoying-warning>(隠す)</label> <div class=annoying-warning> <p>訳注: この文書は<strong><a href="https://www.w3.org/TR/html51/">HTML 5.1 Recommendation</a>の日本語訳ではありません</strong>。代わりに最新の<a href="https://www.w3.org/TR/html/">W3C HTML仕様</a>を参照ください。<p>この日本語訳は<strong>メンテナンスされていません</strong>。この翻訳文書の代わりに<a href="https://momdo.github.io/html/">WHATWG HTML日本語訳</a>を参照することができます。</div> </div>
  <h3 id="embedded-content"><span class="secno">4.7</span> 埋め込みコンテンツ</h3><!-- START OF PICTURE SECTION -->

  

  <h4 id="introduction-0"><span class="secno">4.7.1</span> 導入</h4>

  <p><i data-anolis-xref="">この節は非規範的である。</i></p>

  <p>単独の画像リソースのみが存在する場合、HTMLにおいて画像を埋め込むために、<code><a href="#the-img-element">img</a></code>要素および<code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>属性を使用する。</p>

  <div class="example">

<pre>&lt;h2&gt;From today's featured article&lt;/h2&gt;
<strong>&lt;img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150"&gt;</strong>
&lt;p&gt;&lt;b&gt;&lt;a href="/wiki/Marie_Lloyd"&gt;Marie Lloyd&lt;/a&gt;&lt;/b&gt; (1870–1922)
was an English &lt;a href="/wiki/Music_hall"&gt;music hall&lt;/a&gt; singer, ...</pre>

  </div>

  <p>しかし、ユーザーエージェントが選択することができる複数の画像リソースを用いることを著者が望むかもしれない多数の状況が存在する：</p>

  <ul><li>

    <p>異なるユーザーが異なる環境特性を持つかもしれない：</p>

    <ul><li>

      <p>ユーザーの物理スクリーンサイズは他のものと異なるかもしれない。</p>

      <p class="example">ラップトップのスクリーンは14インチ型であるかもしれない一方で、携帯電話のスクリーンは4インチ型であるかもしれない。</p>

      <p class="note">画像のレンダリングサイズがビューポートに依存する場合、これは単に関連するだけである。</p>

     </li>

     <li>

      <p>ユーザーのスクリーンピクセル密度は、別のスクリーンと異なるかもしれない。</p>

      <p class="example">携帯電話のスクリーンは、物理スクリーンサイズに関わらず、別の携帯電話のスクリーンと比較してインチあたり物理ピクセルとして3倍になるかもしれない。</p>

     </li>

     <li>

      <p>ユーザーのズームレベルは別のものと異なるかもしれず、時間とともに単独のユーザーに対して変化するかもしれない。</p>

      <p class="example">ユーザーは、特定の画像の詳細を見るためにズームするかもしれない。</p>

      <p>ズームレベルおよびスクリーンピクセル密度（前のポイント）は、CSSピクセル密度あたり多数の物理スクリーンピクセルに影響を与えることができる。この比率は、一般に<dfn id="device-pixel-ratio">デバイスピクセル比</dfn>として参照される。</p>

     </li>

     <li>

      <p>ユーザーのスクリーン方向は別のものと異なるかもしれず、時間とともに単独のユーザーに対して変化するかもしれない。</p>

      <p class="example">タブレットは縦型または90度回転して固定されることができ、その結果スクリーンは、"縦長"（portrait）または"横長"（landscape）のいずれかとなる。</p>

     </li>

     <li>

      <p>ユーザーのネットワーク速度、ネットワークレイテンシおよび帯域幅コストは異なるかもしれず、時間とともに単独のユーザーに対して変化するかもしれない。</p>

      <p class="example">ユーザーは、仕事で低レイテンシおよび一定コスト接続の高速かもしれないし、家で低レイテンシおよび一定コスト接続の低速かもしれないし、他の場所で高レイテンシおよび可変コスト接続の速度変化かもしれない。</p>

     </li>

    </ul></li>

   <li>

    <p>著者は、画像のレンダリングサイズ次第で異なる画像コンテンツを表示したいかもしれない。これは通常<dfn id="art-direction">art direction</dfn>として参照される。</p>

    <p class="example">ウェブページが大きな物理サイズ（最大化されたブラウザウィンドウと仮定する）をもつスクリーンで見られる場合、著者は画像の重要な部分を囲むあまり関連しない部分を含むことを望むかもしれない。ウェブページが小さなな物理サイズをもつスクリーンで見られる場合、著者は画像の重要な部分のみを表示することを望むかもしれない。</p>

   </li>

   <li>

    <p>著者は、ビューポートの幅に依存して、同じ画像だが異なるレンダリングサイズを表示したいかもしれない。これは通常<dfn id="viewport-based-selection">ビューポートベースの選択</dfn>として参照される。</p>

    <p class="example">ウェブページは、常に全体のビューポート幅に及ぶ、一番上のバナーを持つかもしれない。この場合、画像のレンダリングサイズはスクリーンの物理サイズに依存する（最大化されたブラウザウィンドウを仮定する）。</p>

    <p class="example">別のウェブページは、小さな物理サイズをもつスクリーンに対する列、中程度の物理サイズをもつスクリーンに対する列、大きな物理サイズをもつスクリーンに対する列をともない、ビューポートを埋める各ケースにおいてレンダリングサイズの変化する画像をもつ、列における画像を持つかもしれない。この場合、画像のレンダリングサイズは、スクリーンがより小さくにもかかわらず、2列レイアウトと比較して1列レイアウトで<em>より大きく</em>なるかもしれない。</p>

   </li>

   <li>

    <p>著者は、ユーザーエージェントがサポートする画像フォーマットに応じて、同じ画像コンテンツだが異なる画像フォーマットを表示したいかもしれない。これは通常<dfn id="image-format-based-selection">画像フォーマットベースの選択</dfn>として参照される。</p>

    <p class="example">ウェブページは、JPEG、JPEGと比較してより圧縮能力のよいWebPおよびJPEG XRで画像を持つかもしれない。異なるユーザーエージェントは、よりよい圧縮比を提供するフォーマットをもつ、異なる画像フォーマットをサポートすることができるため、サポートしないユーザーエージェントに対してJPEGフォールバックを提供する一方で、著者はフォーマットをサポートするユーザーエージェントに対してよりよいフォーマットを配信したいだろう。<!--XXX refs?--></p>

   </li>

  </ul><p>上記の状況は、相互に排他的ではない。たとえば、<a href="#art-direction">art direction</a>に対する異なるリソースをもつ異なる<a href="#device-pixel-ratio">デバイスピクセル比</a>が異なるリソースを組み合わせることは理にかなっている。 </p>

  <p>スクリプトを使用することでこれら問題を解決することは可能である間、そのようにすることは他の問題を導入する：</p>

  <ul><li><p>ウェブページがすぐに読み込み完了するように、スクリプトが実行する機会を持つ前に、一部のユーザーエージェントは、HTMLマークアップで指定される画像を積極的にダウンロードする。スクリプトがダウンロードする画像を変更する場合、より悪いページ読み込みパフォーマンスを引き起こすことができるダウンロードの代わりに、ユーザーエージェントはダウンロードを分離する2つを潜在的に開始するだろう。</li>

   <li><p>著者がHTMLマークアップで任意の画像の指定を避け、かつスクリプトから単一のダウンロードを代わりに実例を示す場合、それは上記の2回のダウンロード問題を回避するが、代わりに無効されるスクリプトをもつユーザーに対してすべて画像をダウンロードさせず、かつ積極的な画像ダウンロード最適化を無効にする。</li>

  </ul><p>このことを考慮して、この仕様は宣言する方法で上記の問題を申し立てるための多数の機能を導入する。</p>

  <dl><dt>画像のレンダリングサイズが固定される場合で<a href="#device-pixel-ratio">デバイスピクセル比</a>ベースの選択</dt>

   <dd>

    <p><code><a href="#the-img-element">img</a></code>要素の<code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>および<code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>は、（より小さいサイズがより大きい画像のスケールダウンバージョンとなる）画像サイズで変化するのみの複数の画像を提供するために<code data-anolis-xref="">x</code>記述子を用いて使用することができる。</p>

    <p class="note">画像のレンダリングサイズがビューポート幅に依存する場合（<a href="#viewport-based-selection">ビューポートベースの選択</a>）、<code data-anolis-xref="">x</code>記述子は適さないが、<a href="#art-direction">art direction</a>と一緒に使用することができる。</p>

    <div class="example">

<pre>&lt;h2&gt;From today's featured article&lt;/h2&gt;
&lt;img <strong>src="/uploads/100-marie-lloyd.jpg"</strong>
     <strong>srcset="/uploads/150-marie-lloyd.jpg 1.5x, /uploads/200-marie-lloyd.jpg 2x"</strong>
     alt="" width="100" height="150"&gt;
&lt;p&gt;&lt;b&gt;&lt;a href="/wiki/Marie_Lloyd"&gt;Marie Lloyd&lt;/a&gt;&lt;/b&gt; (1870–1922)
was an English &lt;a href="/wiki/Music_hall"&gt;music hall&lt;/a&gt; singer, ...</pre>

     <p>ユーザーエージェントは、ユーザーのスクリーンのピクセル密度、ズームレベルおよびユーザーのネットワーク状態のような可能性のあるその他の要素に依存する与えられたリソースのどれでも選択することができる。</p>

     <p><code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>属性を解釈しない古いユーザーエージェントの後方互換性のために、URLの1つは、<code><a href="#the-img-element">img</a></code>要素の<code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>属性で指定される。これは（ユーザーが好むよりももしかすると低い解像度だけれども）古いユーザーエージェントにおいてさえも表示されるという何かしら役に立つ結果になるだろう。新しいユーザーエージェントに対して、あたかも属性が<code data-anolis-xref="">1x</code>記述子とともに<code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>で指定されたかのように、<code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>属性はリソース選択に参加する。</p>

     <p>画像のレンダリングサイズは、画像がダウンロードされる前に画像に対する空間を割り当てることがユーザーエージェントにできる<code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code>および<code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code>属性で与えられる。</p>

    </div>

   </dd>

   <dt><a href="#art-direction">Art direction</a>-ベースの選択</dt>

   <dd>

    <p><code data-anolis-xref="attr-picture-source-media"><a href="#attr-picture-source-media">media</a></code>属性と共に<code><a href="#the-picture-element">picture</a></code>要素および<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素は、（たとえばより小さい画像がより大きい画像の収穫されたバージョンかもしれない）画像コンテンツを変化させる複数の画像を提供するために使用することができる。</p>

    <div class="example">

<pre>&lt;picture&gt;
  &lt;source <strong>media="(min-width: 45em)"</strong> srcset="large.jpg"&gt;
  &lt;source <strong>media="(min-width: 32em)"</strong> srcset="med.jpg"&gt;
  &lt;img src="small.jpg" alt="The president giving an award."&gt;
&lt;/picture&gt;</pre>

     <p>ユーザーエージェントが<code data-anolis-xref="attr-picture-source-media"><a href="#attr-picture-source-media">media</a></code>属性におけるメディアクエリがマッチする最初の<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素を選択し、要素の<code data-anolis-xref="attr-picture-source-srcset"><a href="#attr-picture-source-srcset">srcset</a></code>属性から適切なURLを選択する。</p>

     <p>画像のレンダリングサイズは、ソースが選択されるものに依存して変化する。ダウンロードされた画像を持つ前にユーザーエージェントが使用することができる次元を指定するために、CSSは使用することができる。</p>

<pre class="css">img { width: 300px; height: 300px }
@media (min-width: 32em) { img { width: 500px; height:300px } }
@media (min-width: 45em) { img { width: 700px; height:400px } }</pre>

    </div>

    <div class="example">

     <p>この例は、<a href="#art-direction">art direction</a>および<a href="#device-pixel-ratio">デバイスピクセル比</a>ベースの選択を組み合わせる。ビューポートの半分を取るバナーは、1つは広いスクリーンに対して、1つは狭いスクリーンに対しての、2つのバージョンで提供される。</p>

<pre>&lt;h1&gt;
 &lt;picture&gt;
  &lt;source media="(max-width: 500px)" srcset="banner-phone.jpeg, banner-phone-HD.jpeg 2x"&gt;
  &lt;img src="banner.jpeg" srcset="banner-HD.jpeg 2x" alt="The Breakfast Combo"&gt;
 &lt;/picture&gt;
&lt;/h1&gt;</pre>

    </div>

   </dd>

   <dt><a href="#viewport-based-selection">ビューポートベースの選択</a></dt>

   <dd>

    <p><code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>および<code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code>は、（より小さいサイズがより大きい画像のスケールダウンバージョンとなる）画像サイズで変化するのみの複数の画像を提供するために<code data-anolis-xref="">w</code>記述子を用いて使用することができる。</p>

    <div class="example">

     <p>この例において、バナー画像は（適切なCSSを用いて）ビューポート幅全体を取る。</p>

<pre>&lt;h1&gt;&lt;img <strong>sizes="100vw" srcset="wolf-400.jpg 400w, wolf-800.jpg 800w, wolf-1600.jpg 1600w"</strong>
     src="wolf-400.jpg" alt="The rad wolf"&gt;&lt;/h1&gt;</pre>

     <p>ユーザーエージェントは、指定される<code data-anolis-xref="">w</code>記述子および<code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code>属性で指定されるレンダリングサイズから各画像の効果的なピクセル密度を算出するだろう。 ユーザーエージェントは、ユーザーのスクリーンのピクセル密度、ズームレベルおよびユーザーのネットワーク状態のような可能性のあるその他の要素に依存する与えられたリソースのどれでも選択することができる。</p>

     <p>ユーザーのスクリーンが320 CSSピクセル幅である場合、これは<code data-anolis-xref="">wolf-400.jpg 1.25x, wolf-800.jpg 2.5x, wolf-1600.jpg 5x</code>に指定するのと等価である。言い換えると、ユーザーのスクリーン1200 CSSピクセル幅である場合、これは<code data-anolis-xref="">wolf-400.jpg 0.33x, wolf-800.jpg 0.67x, wolf-1600.jpg 1.33x</code>に指定するのと等価である。By using the <code data-anolis-xref="">w</code>記述子および<code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code>属性を使用することによって、ユーザーエージェントはユーザーのデバイスの大きさにかかわらず、ダウンロードする正確な画像リソースを選択することができる。</p>

     <p>後方互換性のために、URLの1つは<code><a href="#the-img-element">img</a></code>要素の<code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>属性で指定される。新しいユーザーエージェントにおいて、<code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>属性が<code data-anolis-xref="">w</code>記述子を使用する場合、<code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>属性は無視される。</p>

     <p>次の例において、デフォルト値が<code data-anolis-xref="">100vw</code>であるので、<code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code>属性は省略することができる。</p>

    </div>

    <div class="example">

     <p>この例において、ウェブページはビューポートの幅に依存する3つのレイアウトを持つ。狭いレイアウトは1列目の画像（各画像の幅が約100%）、中程度のレイアウトは2列目の画像（各画像の幅が約50%）、広いレイアウトは3列目の画像（各画像の幅が約33%）、およびページマージンを持つ。ビューポートがそれぞれ幅<code data-anolis-xref="">30em</code>および幅<code data-anolis-xref="">50em</code>である場合、これらレイアウトを壊す。</p>

<pre>&lt;img <strong>sizes="(max-width: 30em) 100vw, (max-width: 50em) 50vw, calc(33vw - 100px)"</strong>
     <strong>srcset="swing-200.jpg 200w, swing-400.jpg 400w, swing-800.jpg 800w, swing-1600.jpg 1600w"</strong>
     src="swing-400.jpg" alt="Kettlebell Swing"&gt;</pre>

     <p><code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code>属性は、<code data-anolis-xref="">30em</code>および<code data-anolis-xref="">50em</code>でレイアウトのブレークポイントを設定し、これらブレークポイントの間で <code data-anolis-xref="">100vw</code>、<code data-anolis-xref="">50vw</code>または<code data-anolis-xref="">calc(33vw - 100px)</code>に画像サイズを宣言する。これらサイズは、CSSで指定されたように実際の画像幅と厳密にマッチする必要が必然的にない。</p>

     <p>ユーザーエージェントは、trueに評価する<a href="#media-condition">&lt;media-condition&gt;</a>（丸括弧の一部）をもつ最初の項目を用いる、またはそれらがfalseにすべて評価する場合、最後の項目（<code data-anolis-xref="">calc(33vw - 100px)</code>）を用いて、<code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code>属性から幅を選ぶだろう。</p>

     <p>たとえば、ビューポート幅が<code data-anolis-xref="">29em</code>である場合、<code data-anolis-xref="">(max-width: 30em)</code>がtrueに評価し<code data-anolis-xref="">100vw</code>が使用され結果として、リソース選択の目的で画像サイズは<code data-anolis-xref="">29em</code>である。ビューポート幅が代わりに<code data-anolis-xref="">32em</code>である場合、<code data-anolis-xref="">(max-width: 30em)</code>はfalseに評価するが、<code data-anolis-xref="">(max-width: 50em)</code>はtrueに評価し、<code data-anolis-xref="">50vw</code> が使用され結果として、リソース選択の目的で画像のサイズは<code data-anolis-xref="">16em</code>（ビューポート幅の半分）となる。異なるレイアウトのため、わずかにより幅の広いビューポートがより小さい画像をもたらすことに注目する。</p>

     <p>ユーザーエージェントは、効果的なピクセル密度を選択し、前の例と似た適切なリソースを選択することができる。</p>

    </div>

   </dd>

   <dt><a href="#image-format-based-selection">Image format-based selection</a></dt>

   <dd>

    <p><code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素の<code data-anolis-xref="attr-picture-source-type"><a href="attr-picture-source-type">type</a></code>属性は、異なるフォーマットで複数の画像を提供するために、使用することができる。</p>

    <div class="example">

<pre>&lt;h2&gt;From today's featured article&lt;/h2&gt;
&lt;picture&gt;
 &lt;source srcset="/uploads/100-marie-lloyd.webp" <strong>type="image/webp"</strong>&gt;
 &lt;source srcset="/uploads/100-marie-lloyd.jxr" <strong>type="image/vnd.ms-photo"</strong>&gt;
 &lt;img src="/uploads/100-marie-lloyd.jpg" alt="" width="100" height="150"&gt;
&lt;/picture&gt;
&lt;p&gt;&lt;b&gt;&lt;a href="/wiki/Marie_Lloyd"&gt;Marie Lloyd&lt;/a&gt;&lt;/b&gt; (1870–1922)
was an English &lt;a href="/wiki/Music_hall"&gt;music hall&lt;/a&gt; singer, ...</pre>

     <p>この例において、ユーザーエージェントは、サポートされるMIMEタイプをもつ<code data-anolis-xref="attr-picture-source-type"><a href="attr-picture-source-type">type</a></code>属性を持つ最初のリソースを選択するだろう。ユーザーエージェントがWebP画像をサポートする場合、最初の<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素が選択されるだろう。WebP画像をサポートしないが、ユーザーエージェントがJPEG XR画像をサポートする場合、2つ目の<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素が選択されるだろう。これらのフォーマットがいずれもサポートされない場合、<code><a href="#the-img-element">img</a></code>要素が選択されるだろう。</p>

    </div>

   </dd>

  </dl><h4 id="dependencies-0"><span class="secno">4.7.2</span> 依存関係</h4>

  <dl><dt>メディアクエリ<a href="references.html#refsMQ">[MQ]</a> <span class="XXX">正しい参照は<a href="http://dev.w3.org/csswg/mediaqueries-4/">http://dev.w3.org/csswg/mediaqueries-4/</a>である</span></dt>

   <dd><dfn id="media-condition">&lt;media-condition&gt;</dfn></dd>

   <dt>CSS Values and Units <a href="references.html#refsCSSVALUES">[CSSVALUES]</a></dt>

   <dd><dfn id="length">&lt;length&gt;</dfn></dd>

   <dt>CSS Syntax <a href="references.html#refsCSSSYNTAX">[CSSSYNTAX]</a></dt>

   <dd><dfn id="parse-a-comma-separated-list-of-component-values">Parse a comma-separated list of component values</dfn></dd>
   <dd><dfn id="component-value">component value</dfn></dd>
   <dd><dfn id="whitespace-token">&lt;whitespace-token&gt;</dfn></dd>

  </dl><h4 id="the-picture-element"><span class="secno">4.7.3</span> <dfn><code>picture</code></dfn>要素</h4>

  <dl class="element"><dt><span data-anolis-xref="element-dfn-categories">カテゴリ</span>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>。</dd>
   <dt><span data-anolis-xref="element-dfn-contexts">この要素を使用できるコンテキスト</span>：</dt>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>が期待される場所。</dd>
   <dt><span data-anolis-xref="element-dfn-content-model">コンテンツモデル</span>：</dt>
   <dd>1つ以上の<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素、その後に来る1つの<code><a href="#the-img-element">img</a></code>要素、任意で<a href="dom.html#script-supporting-elements-0">スクリプトサポート要素</a>と混合される。</dd>
   <dt><span data-anolis-xref="element-dfn-attributes">コンテンツ属性</span>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd><!--FORK start-->
   
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd>どちらのタグも省略不可</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd>なし</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd><!-- FORK end -->
   
   <dt><span data-anolis-xref="element-dfn-dom">DOMインターフェース</span>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmlpictureelement">HTMLPictureElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {};</pre>
   </dd>
  </dl><p><code><a href="#the-picture-element">picture</a></code>要素は、スクリーンピクセル密度、ビューポートサイズ、画像フォーマット、およびその他の要素を元にした、著者に宣言的にコントロールを許可するために、または画像が使用するためのリソースに関するユーザーエージェントに対するヒントを与えるために、ソースの含まれた<code><a href="#the-img-element">img</a></code>要素に複数のソースを提供するコンテナである。この要素は、要素の子を<a href="dom.html#represents">表す</a>。</p>

  <p class="note"><code><a href="#the-picture-element">picture</a></code>要素は、<code><a href="#the-video-element">video</a></code>および<code><a href="#the-audio-element">audio</a></code>要素によく似た異なる何かである。それら要素のすべてが<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素を含む一方で、<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素の<code data-anolis-xref="attr-source-src"><a href="#attr-source-src">src</a></code>属性は、要素が<code><a href="#the-picture-element">picture</a></code>要素内でネストされる場合に意味を持たず、リソース選択アルゴリズムは異なる。その上、<code><a href="#the-picture-element">picture</a></code>要素自身は何も表示しない。要素は複数の<a data-anolis-xref="URL" href="infrastructure.html#url">URL</a>から選択する要素を有効にする 要素の含まれる<code><a href="#the-img-element">img</a></code>要素にコンテキストを単に提供する。</p>


  <h4 id="the-source-element-when-used-with-the-picture-element"><span class="secno">4.7.4</span> <code><a href="#the-picture-element">picture</a></code>要素とともに使用される場合の<dfn data-anolis-xref="picture-source" id="picture-source"><code>source</code></dfn>要素</h4>

  <dl class="element"><dt><span data-anolis-xref="element-dfn-categories">カテゴリ</span>：</dt>
   <dd><code><a href="#the-source-element">source</a></code>要素と同じ。</dd>
   <dt><span data-anolis-xref="element-dfn-contexts">この要素を使用できるコンテキスト</span>：</dt>
   <dd><code><a href="#the-img-element">img</a></code>要素の前の、<code><a href="#the-picture-element">picture</a></code>要素の子として。</dd>
   <dt><span data-anolis-xref="element-dfn-content-model">コンテンツモデル</span>：</dt>
   <dd><code><a href="#the-source-element">source</a></code>要素と同じ。</dd>
   <dt><span data-anolis-xref="element-dfn-attributes">コンテンツ属性</span>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-picture-source-srcset"><a href="#attr-picture-source-srcset">srcset</a></code> - 異なる状況で使用するための画像（たとえば、高解像度ディスプレイ、小さなモニタ、など）</dd>
   <dd><code data-anolis-xref="attr-picture-source-sizes"><a href="#attr-picture-source-sizes">sizes</a></code> - ブレークポイント間の画像サイズ</dd>
   <dd><code data-anolis-xref="attr-picture-source-media"><a href="#attr-picture-source-media">media</a></code> — 受け入れ可能なメディア</dd>
   <dd><code data-anolis-xref="attr-picture-source-type"><a href="attr-picture-source-type">type</a></code> — 埋め込みリソースタイプ</dd><!--FORK start-->
   
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd><a data-anolis-xref="syntax-end-tag" href="syntax.html#syntax-end-tag">終了タグ</a>なし</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd>なし</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd><!-- FORK end -->
   
   <dt><span data-anolis-xref="element-dfn-dom">DOMインターフェース</span>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">partial interface <a href="#htmlsourceelement">HTMLSourceElement</a> {
           attribute DOMString <a data-anolis-xref="dom-picture-source-srcset" href="#dom-picture-source-srcset">srcset</a>;
           attribute DOMString <a data-anolis-xref="dom-picture-source-sizes" href="#dom-picture-source-sizes">sizes</a>;
           attribute DOMString <a data-anolis-xref="dom-picture-source-media" href="#dom-picture-source-media">media</a>;
};</pre>
   </dd>
  </dl><p><code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素が親として<code><a href="#the-picture-element">picture</a></code>要素を持つ場合、この節におけるオーサリング要求のみが適用する</p>

  <p><code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素は、著者に<code><a href="#the-img-element">img</a></code>要素に対する複数の代替<a data-anolis-xref="source set" href="#source-set">ソースセット</a>の指定を許可する。この要素は、自分自身で何かを<a data-anolis-xref="represents" href="dom.html#represents">表す</a>ものではない。</p>

  <p><dfn data-anolis-xref="attr-picture-source-srcset" id="attr-picture-source-srcset"><code>srcset</code></dfn>属性は存在しなければならず、1つ以上の<a data-anolis-xref="image candidate string" href="#image-candidate-string">画像候補文字列</a>から成らなければならず、","（U+002C）文字でそれぞれ分離される。<a href="#image-candidate-string">画像候補文字列</a>が記述子およびURLの後に<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>を一切含まない場合、次の<a href="#image-candidate-string">画像候補文字列</a>が存在するならば、1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>で開始しなければならない。</p>

  <p><dfn data-anolis-xref="attr-picture-source-sizes" id="attr-picture-source-sizes"><code>sizes</code></dfn>属性は存在してもよい。存在する場合、値は<a href="#valid-source-size-list">妥当なソースサイズのリスト</a>でなければならない。</p>

  <p><dfn data-anolis-xref="attr-picture-source-media" id="attr-picture-source-media"><code>media</code></dfn>属性は存在してもよい。存在する場合、値は<a href="infrastructure.html#valid-media-query">妥当なメディアクエリ</a>でなければならない。</p>

  <p><dfn data-anolis-xref="attr-picture-source-type" id="attr-picture-source-type"><code>type</code></dfn>属性は存在してもよい。存在する場合、値は<a href="infrastructure.html#valid-mime-type">妥当なMIMEタイプ</a>でなければならない。属性が与えられた種類をサポートしない場合、次の<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素にスキップするためにユーザーエージェントを許可するために、属性は<a href="#source-set">ソースセット</a>で画像の種類を与える。</p>

  <p class="note"><code data-anolis-xref="attr-picture-source-type"><a href="attr-picture-source-type">type</a></code>属性が指定され<em>ない</em>場合、ユーザーエージェントがフェッチする後で画像フォーマットをサポートしないならば、ユーザーエージェントは異なる<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素を選択しないだろう。</p>

  <p><code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素が次の兄弟<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素または指定される<code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>属性をもつ<code><a href="#the-img-element">img</a></code>要素を持つ場合、この要素は少なくとも以下の1つを持たなければならない：</p>

  <ul><li><p><a data-anolis-xref="strip leading and trailing whitespace" href="infrastructure.html#strip-leading-and-trailing-whitespace">先頭および末尾の空白を除去する</a>後で、空文字列でなくかつ<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>で文字列<code>all</code>にマッチしないような値で指定される<code data-anolis-xref="attr-picture-source-media"><a href="#attr-picture-source-media">media</a></code>属性。</li>

   <li><p>指定される<code data-anolis-xref="attr-picture-source-type"><a href="attr-picture-source-type">type</a></code>属性。</li>

  </ul><p><code data-anolis-xref="attr-source-src"><a href="#attr-source-src">src</a></code>属性は存在してはならない。</p>

  <div class="impl">

  <p>The IDL attributes <dfn data-anolis-xref="dom-picture-source-srcset" id="dom-picture-source-srcset"><code>srcset</code></dfn>,
  <dfn data-anolis-xref="dom-picture-source-sizes" id="dom-picture-source-sizes"><code>sizes</code></dfn> and
  <dfn data-anolis-xref="dom-picture-source-media" id="dom-picture-source-media"><code>media</code></dfn> must reflect the
  respective content attributes of the same name.</p>

  </div>


  <h4 id="the-img-element"><span class="secno">4.7.5</span> <dfn><code>img</code></dfn>要素</h4>

  <dl class="element"><dt><span data-anolis-xref="element-dfn-categories">カテゴリ</span>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>。</dd>
   <dd><a href="forms.html#form-associated-element">フォーム関連要素</a>。</dd>
   <dd>要素が<code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code>属性をもつ場合：<a href="dom.html#interactive-content-0">インタラクティブコンテンツ</a>。</dd>
   <dd><a href="dom.html#palpable-content-0">パルパブルコンテンツ</a>。</dd>
   <dt><span data-anolis-xref="element-dfn-contexts">この要素を使用できるコンテキスト</span>：</dt>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>が期待される場所。</dd>
   <dt><span data-anolis-xref="element-dfn-content-model">コンテンツモデル</span>：</dt>
   <dd>空。</dd>
   <dt><span data-anolis-xref="element-dfn-attributes">コンテンツ属性</span>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd><!--FORK start-->
    
   <dd><code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> - 画像が利用不可の際使用する置換テキスト </dd>
   <dd><code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code> - 異なる状況で使用するための画像（たとえば、高解像度ディスプレイ、小さなモニタ、など） </dd>
   <dd><code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code> - ブレークポイント間の画像サイズ</dd>
   <dd><code data-anolis-xref="attr-img-crossorigin"><a href="#attr-img-crossorigin">crossorigin</a></code> — 要素がcrossorigin要求を処理する方法</dd>
   <dd><code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code> - 使用する<a href="#image-map">イメージマップ</a>の名前 </dd>
   <dd><code data-anolis-xref="attr-img-ismap"><a href="#attr-img-ismap">ismap</a></code> - 画像がサーバ側イメージマップであるかどうか</dd>
   <dd><code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code> - 横の次元</dd>
   <dd><code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code> - 縦の次元</dd>
   <dt><span data-anolis-xref="element-dfn-tag-omission">text/htmlにおけるタグ省略</span>：</dt>
   <dd><a data-anolis-xref="syntax-end-tag" href="syntax.html#syntax-end-tag">終了タグ</a>なし。</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd><code><a href="#the-img-element">img</a></code>要素の<code>alt</code>属性値が空である（<code title="">alt=""</code>）場合は<a href="dom.html#index-aria-presentation"><code title="">presentation</code></a>ロールのみ、そうでなければ<a href="dom.html#allowed-aria-roles,-states-and-properties">任意のロール値</a>。</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dd><a href="dom.html#allowed-aria-roles,-states-and-properties">許可されるロールで受け入れ可能な</a>任意の<code title="">aria-*</code>属性。</dd><!--FORK end-->
    
   <dt><span data-anolis-xref="element-dfn-dom">DOMインターフェース</span>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">[NamedConstructor=<a data-anolis-xref="dom-image" href="#dom-image">Image</a>(optional unsigned long width, optional unsigned long height)]
interface <dfn id="htmlimageelement">HTMLImageElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-img-alt" href="#dom-img-alt">alt</a>;
           attribute DOMString <a data-anolis-xref="dom-img-src" href="#dom-img-src">src</a>;
           attribute DOMString <a data-anolis-xref="dom-img-srcset" href="#dom-img-srcset">srcset</a>;
           attribute DOMString <a data-anolis-xref="dom-img-sizes" href="#dom-img-sizes">sizes</a>;
           attribute DOMString <a data-anolis-xref="dom-img-crossOrigin" href="#dom-img-crossorigin">crossOrigin</a>;
           attribute DOMString <a data-anolis-xref="dom-img-useMap" href="#dom-img-usemap">useMap</a>;
           attribute boolean <a data-anolis-xref="dom-img-isMap" href="#dom-img-ismap">isMap</a>;
           attribute unsigned long <a data-anolis-xref="dom-img-width" href="#dom-img-width">width</a>;
           attribute unsigned long <a data-anolis-xref="dom-img-height" href="#dom-img-height">height</a>;
  readonly attribute unsigned long <a data-anolis-xref="dom-img-naturalWidth" href="#dom-img-naturalwidth">naturalWidth</a>;
  readonly attribute unsigned long <a data-anolis-xref="dom-img-naturalHeight" href="#dom-img-naturalheight">naturalHeight</a>;
  readonly attribute boolean <a data-anolis-xref="dom-img-complete" href="#dom-img-complete">complete</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-img-currentSrc" href="#dom-img-currentsrc">currentSrc</a>;
};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-img-element">img</a></code>要素は画像を表す。</p><!-- v2 ideas for <img>:

     * Maps sites would like to know which images are already cached, so that they can use images
       that are vaguely suitable while they wait for the most appropriate image to download.

       Almost like lowsrc="", except that many images might be appropriate.

       Slight hitch: their images are at a different origin, and we don't want to allow arbitrary
       cross-origin inspection (privacy leak risk). So it will require them to do CORS opt-in.

     * See note at rel=noreferrer.

  -->

  

  <p>親が<code><a href="#the-picture-element">picture</a></code>要素である場合、<dfn data-anolis-xref="attr-img-src" id="attr-img-src"><code>src</code></dfn>および<dfn data-anolis-xref="attr-img-srcset" id="attr-img-srcset"><code>srcset</code></dfn>属性、および任意の兄<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素の<code data-anolis-xref="attr-picture-source-srcset"><a href="#attr-picture-source-srcset">srcset</a></code>属性によって与えられる画像は、エンベティッドコンテンツである。<dfn data-anolis-xref="attr-img-alt" id="attr-img-alt"><code>alt</code></dfn>属性の値は、画像を処理することができないまたは読み込みが無効である画像に対して、等価なコンテンツを提供する。（すなわち、<code><a href="#the-img-element">img</a></code>要素の<a href="dom.html#fallback-content">フォールバックコンテンツ</a>である）。</p>

  <p><code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性の値に関する要件は、<a href="#alt">次節で</a>説明される。</p>

  <p><code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>属性は存在しなければならず、画像リソースは潜在的にページ化もスクリプト化もされていない、任意でアニメーションである、非対話型を参照する<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>を含めなければならない。</p>

  <p><code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>属性は存在してもよい。属性が存在する場合、属性値は、","（U+002C）文字でそれぞれ分離される1つ以上の<a data-anolis-xref="image candidate string" href="#image-candidate-string">画像候補文字列</a>から成らなければならない。<a href="#image-candidate-string">画像候補文字列</a>が記述子およびURLの後に<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>を一切含まない場合、次の<a href="#image-candidate-string">画像候補文字列</a>が存在するならば、1つ以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>で開始しなければならない。</p><!-- XXXX
  <div class="note">

   <p>The <code data-x="attr-img-srcset">srcset</code> attribute allows authors to provide a set of
   images to handle graphical displays of varying dimensions and pixel densities.</p>

   <p>The attribute essentially takes a comma-separated list of URLs each with one or more
   descriptors giving the maximum viewport dimensions and pixel density allowed to use the image.
   From the available options, the user agent then picks the most appropriate image. If the viewport
   dimensions or pixel density changes, the user agent can replace the image data with a new image
   on the fly.</p>

   <p>To specify an image, give first a URL, then one or more descriptors of the form 100w, 100h, or
   2x, where "100w" means "maximum viewport width of 100 CSS pixels", "100h" is the same but for
   height, and "2x" means "maximum pixel density of 2 device pixels per CSS pixel".</p>

  </div>
  -->

  

  <p><dfn id="image-candidate-string">画像候補文字列</dfn>は、以下のリストで説明される追加の制限とともに、順に、以下のコンポーネントから成る：</p>

  <ol><li><p>0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>

   <li><p>"," （U+002C）文字で開始または終了しない<a href="infrastructure.html#valid-non-empty-url">妥当な空でないURL</a>で、非インタラクティブを参照し、任意でアニメーション、ページ化もスクリプト化もされない画像リソース。</li>

   <li><p>0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>

   <li>

    <p>次の0または1つ：</p>

    <ul><li><p><a href="infrastructure.html#space-character">空白文字</a>、<i data-anolis-xref="">幅記述子</i> 値を表す0より大きい数値を与える<a href="infrastructure.html#valid-non-negative-integer">妥当な非負整数</a>、およびU+0077 LATIN SMALL LETTER W文字から成る、<i data-anolis-xref="">幅記述子</i>。</li>

     <li><p><a href="infrastructure.html#space-character">空白文字</a>、<i data-anolis-xref="">ピクセル密度記述子</i>値を表す0より大きい数値を与える<a href="infrastructure.html#valid-floating-point-number">妥当な浮動小数点数</a>、およびU+0078 LATIN SMALL LETTER X文字から成る、<i data-anolis-xref="">ピクセル密度記述子</i>。</li>

    </ul></li>

   <li><p>0個以上の<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>。</li>

  </ol><p>同じ要素に対して別の<a href="#image-candidate-string">画像候補文字列</a>の<i data-anolis-xref="">幅記述子</i>値と同じ<i data-anolis-xref="">幅記述子</i>値を持つ要素に対する<a href="#image-candidate-string">画像候補文字列</a>が存在してはならない。</p>

  <p>同じ要素に対して別の<a href="#image-candidate-string">画像候補文字列</a>の<i data-anolis-xref="">ピクセル密度記述子</i>値と同じ<i data-anolis-xref="">ピクセル密度記述子</i>値を持つ要素に対する<a href="#image-candidate-string">画像候補文字列</a>が存在してはならない。この要求の目的のために、記述子をもたない<a href="#image-candidate-string">画像候補文字列</a>は、<code data-anolis-xref="">1x</code>記述子をもつ<a href="#image-candidate-string">画像候補文字列</a>と等価である。</p>

  <p><code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素が<code data-anolis-xref="attr-picture-source-sizes"><a href="#attr-picture-source-sizes">sizes</a></code>属性を存在させる、または<code><a href="#the-img-element">img</a></code>が<code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code>属性属性を存在させる場合、その要素に対するすべての<a data-anolis-xref="image candidate string" href="#image-candidate-string">画像候補文字列</a>は、指定される<i data-anolis-xref="">幅記述子</i>を持たなければならない。</p>

  <p><code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>または<code><a href="#the-img-element">img</a></code>要素に対する<a href="#image-candidate-string">画像候補文字列</a>は、指定される<i data-anolis-xref="">幅記述子</i>を持つ場合、その要素に対するすべての他の<a data-anolis-xref="image candidate string" href="#image-candidate-string">画像候補文字列</a>はまた、指定される<i data-anolis-xref="">幅記述子</i>を持たなければならない。</p>

  <p><a href="#image-candidate-string">画像候補文字列</a>の<i data-anolis-xref="">幅記述子</i>における指定される幅は、<a href="#image-candidate-string">画像候補文字列</a>のURLによって指定されるリソースにおける内在幅にマッチしなければならない。</p>

  <p class="note">上記の要件は、画像が静的ビットマップ（たとえばPNG、GIF、JPEG）、単一ページのベクター文書（単一ページのPDF、SVGルート要素を持つXMLファイル）、アニメーションビットマップ（APNG、アニメーションGIF）、アニメーションベクターグラフィックス（宣言型SMILアニメーションを使用するSVGルート要素を持つXMLファイル）などであることを意味する。しかし、これらの定義は、スクリプトを伴うSVGファイル、複数ページのPDFファイル、インタラクティブMNGファイル、HTML文書、プレーンテキスト文書などを排除する。<a href="references.html#refsPNG">[PNG]</a> <a href="references.html#refsGIF">[GIF]</a> <a href="references.html#refsJPEG">[JPEG]</a> <a href="references.html#refsPDF">[PDF]</a> <a href="references.html#refsXML">[XML]</a> <a href="references.html#refsAPNG">[APNG]</a> <!-- <a href="#refsAGIF">[AGIF]</a> --> <a href="references.html#refsSVG">[SVG]</a>
  <a href="references.html#refsMNG">[MNG]</a> </p>

  <p><code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>属性が存在する場合、<dfn data-anolis-xref="attr-img-sizes" id="attr-img-sizes"><code>sizes</code></dfn>属性はまた存在してもよい。存在する場合、値は<a href="#valid-source-size-list">妥当なソースサイズのリスト</a>でなければならない。</p>

  <p><dfn id="valid-source-size-list">妥当なソースサイズのリスト</dfn>は、以下の文法にマッチする文字列である：<a href="references.html#refsCSSVALUES">[CSSVALUES]</a> <a href="references.html#refsMQ">[MQ]</a></p>

<pre><dfn id="source-size-list">&lt;source-size-list&gt;</dfn> = <a href="source-size">&lt;source-size&gt;</a># [ , <a href="#source-size-value">&lt;source-size-value&gt;</a> ]? | <a href="#source-size-value">&lt;source-size-value&gt;</a>
<dfn id="source-size">&lt;source-size&gt;</dfn> = <a href="#media-condition">&lt;media-condition&gt;</a> <a href="#source-size-value">&lt;source-size-value&gt;</a>
<dfn id="source-size-value">&lt;source-size-value&gt;</dfn> = <a href="#length">&lt;length&gt;</a></pre>

  <p><a href="#source-size-value">&lt;source-size-value&gt;</a>は負であってはならない。</p>

  <p><code><a href="#the-img-element">img</a></code>要素は、レイアウトツールとして使用してはならない。特に、画像はめったに意味および文書に有用なものを追加しないので、<code><a href="#the-img-element">img</a></code>要素は、透明な画像を表示するために使用すべきでない。</p>

  <hr><p><dfn data-anolis-xref="attr-img-crossorigin" id="attr-img-crossorigin"><code>crossorigin</code></dfn>属性は<a href="infrastructure.html#cors-settings-attribute">CORS設定属性</a>である。その目的は、クロスオリジンなアクセスに<code><a href="scripting-1.html#the-canvas-element">canvas</a></code>とともに使用できるサードパーティのサイトからの画像を許可することである。</p>

  <div class="impl">

  <hr><p>An <code><a href="#the-img-element">img</a></code> element has a <dfn id="current-request">current request</dfn> and a <dfn id="pending-request">pending request</dfn>.
  The <a href="#current-request">current request</a> is initially set to a new <a href="#image-request">image request</a>.
  The <a href="#pending-request">pending request</a> is initially set to null.
  The <a href="#current-request">current request</a> is usually referred to as the <code><a href="#the-img-element">img</a></code> element itself.</p>

  <p>An <dfn id="image-request">image request</dfn> has a <dfn data-anolis-xref="img-req-state" id="img-req-state">state</dfn>, <dfn data-anolis-xref="img-req-url" id="img-req-url">current URL</dfn> and <dfn data-anolis-xref="img-req-data" id="img-req-data">image data</dfn>.</p>

  <p>An <a href="#image-request">image request</a>'s <a data-anolis-xref="img-req-state" href="#img-req-state">state</a> is one of the following:</p>

  <dl><dt><dfn data-anolis-xref="img-none" id="img-none">Unavailable</dfn></dt>
   <dd>The user agent hasn't obtained any image data,
   or has obtained some or all of the image data but
   hasn't yet decoded enough of the image to get the image dimensions.</dd>

   <dt><dfn data-anolis-xref="img-inc" id="img-inc">Partially available</dfn></dt>
   <dd>The user agent has obtained some of the image data and at least the image dimensions are
   available.</dd>

   <dt><dfn data-anolis-xref="img-all" id="img-all">Completely available</dfn></dt>
   <dd>The user agent has obtained all of the image data and at least the image dimensions are
   available.</dd>

   <dt><dfn data-anolis-xref="img-error" id="img-error">Broken</dfn></dt>
   <dd>The user agent has obtained all of the image data that it can, but it cannot even decode the
   image enough to get the image dimensions (e.g. the image is corrupted, or the format is not
   supported, or no data could be obtained).</dd>

  </dl><p>An <a href="#image-request">image request</a>'s <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a> is initially the empty string.</p>

  <p>An <a href="#image-request">image request</a>'s <a data-anolis-xref="img-req-data" href="#img-req-data">image data</a> is the decoded image data.</p>

  <p>When an <a href="#image-request">image request</a> is either in the <a data-anolis-xref="img-inc" href="#img-inc">partially
  available</a> state or in the <a data-anolis-xref="img-all" href="#img-all">completely available</a> state, it is
  said to be <dfn data-anolis-xref="img-available" id="img-available">available</dfn>.</p>

  <p>An <a href="#image-request">image request</a> is initially <a data-anolis-xref="img-none" href="#img-none">unavailable</a>.</p>

  <p>When an <code><a href="#the-img-element">img</a></code> element is <a data-anolis-xref="img-available" href="#img-available">available</a>, it
  <a href="infrastructure.html#provides-a-paint-source">provides a paint source</a> whose width is the image's intrinsic width, whose height is
  the image's intrinsic height, and whose appearance is the intrinsic appearance of the image.</p>

  <p>In a <a href="browsers.html#browsing-context">browsing context</a> where <a data-anolis-xref="concept-bc-noscript" href="webappapis.html#concept-bc-noscript">scripting is
  disabled</a>, user agents may obtain images immediately or on demand. In a <a href="browsers.html#browsing-context">browsing
  context</a> where <a data-anolis-xref="concept-bc-noscript" href="webappapis.html#concept-bc-noscript">scripting is enabled</a>, user agents
  must obtain images immediately.</p>

  <p>A user agent that obtains images immediately must synchronously
  <a href="#update-the-image-data">update the image data</a> of an <code><a href="#the-img-element">img</a></code> element,
  with the <i data-anolis-xref="">restart animation</i> flag set if so stated,
  whenever that element is created,
  or has experienced <a href="#relevant-mutations">relevant mutations</a>,
  and whenever that element's <a data-anolis-xref="concept-node-adopt-ext" href="infrastructure.html#concept-node-adopt-ext">adopting steps</a> are run.</p><!-- Note
  how this does NOT happen when the base URL changes (except for when adopted into a new doc) --> 

  <p>A user agent that obtains images on demand must <a href="#update-the-image-data">update the image data</a> of an
  <code><a href="#the-img-element">img</a></code> element whenever it needs the image data (i.e. on demand),
  but only if the <code><a href="#the-img-element">img</a></code> element is in the
  <a data-anolis-xref="img-none" href="#img-none">unavailable</a> state. When an <code><a href="#the-img-element">img</a></code> element
  has experienced <a href="#relevant-mutations">relevant mutations</a>,
  and whenever that element's <a data-anolis-xref="concept-node-adopt-ext" href="infrastructure.html#concept-node-adopt-ext">adopting steps</a> are run, if the user
  agent only obtains images on demand, the <code><a href="#the-img-element">img</a></code> element must return to the <a data-anolis-xref="img-none" href="#img-none">unavailable</a> state.</p><!-- Note how this does NOT happen when the base
  URL changes. --> 

  <p>The <dfn id="relevant-mutations">relevant mutations</dfn> for an <code><a href="#the-img-element">img</a></code> element are as follows:</p>

  <ul><li><p>The element's <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>,
   <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>
   or <code data-anolis-xref="attr-img-sizes"><a href="#attr-img-sizes">sizes</a></code> attributes are set, changed, or removed.</li>

   <li><p>The element's <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute is set to the same value as the previous value.
   This must set the <i data-anolis-xref="">restart animation</i> flag for the <a href="#update-the-image-data">update the image data</a> algorithm.</li>

   <li><p>The element's <code data-anolis-xref="attr-img-crossorigin"><a href="#attr-img-crossorigin">crossorigin</a></code> attribute's state is changed.</li>

   <li><p>The element is inserted into or removed from a <code><a href="#the-picture-element">picture</a></code> parent element.</li>

   <li><p>The element's parent is a <code><a href="#the-picture-element">picture</a></code> element and a
   <code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code> element is inserted as a previous sibling.</li>

   <li><p>The element's parent is a <code><a href="#the-picture-element">picture</a></code> element and a
   <code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code> element that was a previous sibling is removed.</li>

   <li><p>The element's parent is a <code><a href="#the-picture-element">picture</a></code> element and a
   <code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code> element that is a previous sibling has its
   <code data-anolis-xref="attr-picture-source-srcset"><a href="#attr-picture-source-srcset">srcset</a></code>,
   <code data-anolis-xref="attr-picture-source-sizes"><a href="#attr-picture-source-sizes">sizes</a></code>,
   <code data-anolis-xref="attr-picture-source-media"><a href="#attr-picture-source-media">media</a></code>
   or <code data-anolis-xref="attr-picture-source-type"><a href="attr-picture-source-type">type</a></code> attributes set, changed, or removed.</li>

  </ul><p>Each <code><a href="#the-img-element">img</a></code> element has a <dfn id="last-selected-source">last selected source</dfn>, which must initially be
  null.</p>

  <p>Each <a href="#image-request">image request</a> has a <dfn id="current-pixel-density">current pixel density</dfn>, which must initially be undefined.</p>

  <p>When an <code><a href="#the-img-element">img</a></code> element has a <a href="#current-pixel-density">current pixel density</a> that is not 1.0, the
  element's image data must be treated as if its resolution, in device pixels per CSS pixels, was
  the <a href="#current-pixel-density">current pixel density</a>.</p>

  <p class="example">For example, if the <a href="#current-pixel-density">current pixel density</a> is 3.125, that means
  that there are 300 device pixels per CSS inch, and thus if the image data is 300x600, it has an
  intrinsic dimension of 96 CSS pixels by 192 CSS pixels.</p>

  <p>Each <code><a href="dom.html#document">Document</a></code> object must have a <dfn id="list-of-available-images">list of available images</dfn>. Each image
  in this list is identified by a tuple consisting of an <a href="infrastructure.html#absolute-url">absolute URL</a>, a <a href="infrastructure.html#cors-settings-attribute">CORS
  settings attribute</a> mode, and, if the mode is not <a data-anolis-xref="attr-crossorigin-none" href="infrastructure.html#attr-crossorigin-none">No
  CORS</a>, an <a href="browsers.html#origin-0">origin</a>.
  Each image furthermore has an <dfn id="ignore-higher-layer-caching">ignore higher-layer caching</dfn> flag.
  User agents may copy entries from one <code><a href="dom.html#document">Document</a></code>
  object's <a href="#list-of-available-images">list of available images</a> to another at any time (e.g. when the
  <code><a href="dom.html#document">Document</a></code> is created, user agents can add to it all the images that are loaded in
  other <code><a href="dom.html#document">Document</a></code>s), but must not change the keys of entries copied in this way when
  doing so, and must unset the <a href="#ignore-higher-layer-caching">ignore higher-layer caching</a> flag for the copied entry.
  User agents may also remove images from such lists at any time (e.g. to save
  memory).
  User agents must remove entries in the <a href="#list-of-available-images">list of available images</a> as appropriate
  given higher-layer caching semantics for the resource (e.g. the HTTP <code data-anolis-xref="">Cache-Control</code>
  response header) when the <a href="#ignore-higher-layer-caching">ignore higher-layer caching</a> is unset.</p>

  <p class="note">The user agent can also store the image data in a separatly from the <a href="#list-of-available-images">list of available images</a>.</p>

  <p class="example">For example, if a resource has the HTTP response header <code data-anolis-xref="">Cache-Control: must-revalidate</code>,
  the user agent would remove it from the <a href="#list-of-available-images">list of available images</a> but could keep the image data separately,
  and use that if the server responds with a <code data-anolis-xref="">204 No Content</code> status.</p>

  <p>When the user agent is to <dfn id="update-the-image-data">update the image data</dfn> of an <code><a href="#the-img-element">img</a></code> element,
  optionally with the <i data-anolis-xref="">restart animations</i> flag set,
  it must run the following steps:</p>

  <ol><li><p>If the element's <code><a href="dom.html#document">Document</a></code> is not the <a href="browsers.html#active-document">active document</a>,
   abort these steps.</li>

   <li><p>If the user agent cannot support images, or its support for images has been disabled, then
   <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a> and the <a href="#pending-request">pending request</a>,
   set <a href="#current-request">current request</a> to the <a data-anolis-xref="img-none" href="#img-none">unavailable</a> state,
   let <a href="#pending-request">pending request</a> be null,
   and abort these steps.</li>

   <li>

    <p>If the element does not have a <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code> attribute specified and
    it does not have a parent or it has a parent but it is not a <code><a href="#the-picture-element">picture</a></code> element,
    and it has a <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute specified and
    its value is not the empty string, let <var data-anolis-xref="">selected source</var> be the value of the
    element's <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute, and <var data-anolis-xref="">selected pixel
    density</var> be 1.0. Otherwise, let <var data-anolis-xref="">selected source</var> be null and <var data-anolis-xref="">selected pixel density</var> be undefined.</p>

   </li>

   <li><p>Let the <code><a href="#the-img-element">img</a></code> element's <a href="#last-selected-source">last selected source</a> be <var data-anolis-xref="">selected source</var>.</li>

   <li>

    <p>If <var data-anolis-xref="">selected source</var> is not null, run these substeps:</p>

    <ol><li><p><a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">Resolve</a> <var data-anolis-xref="">selected source</var>, relative
     to the element, and let the result be <var data-anolis-xref="">absolute URL</var>. If that is not successful, then
     abort these inner set of steps.</li><!-- This does not change currentSrc -->
     

     <li><p>Let <var data-anolis-xref="">key</var> be a tuple consisting of the resulting <a href="infrastructure.html#absolute-url">absolute
     URL</a>, the <code><a href="#the-img-element">img</a></code> element's <code data-anolis-xref="attr-img-crossorigin"><a href="#attr-img-crossorigin">crossorigin</a></code>
     attribute's mode, and, if that mode is not <a data-anolis-xref="attr-crossorigin-none" href="infrastructure.html#attr-crossorigin-none">No CORS</a>,
     the <code><a href="dom.html#document">Document</a></code> object's <a href="browsers.html#origin-0">origin</a>.</li>

     <li><p>If the <a href="#list-of-available-images">list of available images</a> contains an entry for <var data-anolis-xref="">key</var>, then
     set the <a href="#ignore-higher-layer-caching">ignore higher-layer caching</a> flag for that entry,
     <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a> and the <a href="#pending-request">pending request</a>,
     let <a href="#pending-request">pending request</a> be null,
     let <a href="#current-request">current request</a> be a new <a href="#image-request">image request</a> whose <a data-anolis-xref="img-req-data" href="#img-req-data">image data</a> is that of the entry
     and whose state is set to the <a data-anolis-xref="img-all" href="#img-all">completely available</a> state,
     update the presentation of the image appropriately,
     let the <a href="#current-request">current request</a>'s <a href="#current-pixel-density">current pixel density</a> be <var data-anolis-xref="">selected pixel density</var>,
     <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="#restart-the-animation">restart the animation</a> if <i data-anolis-xref="">restart animation</i> is set,
     change <a href="#current-request">current request</a>'s <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a> to <var data-anolis-xref="">absolute URL</var>,
     and then <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the <code><a href="#the-img-element">img</a></code> element,
     and abort these steps.</li><!--
     load is a simple event here
     loadstart and loadend do not fire
     -->

     

    </ol></li>

   <li><p>Asynchronously <a href="webappapis.html#await-a-stable-state">await a stable state</a>, allowing the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that invoked this algorithm to continue.
   The <a href="webappapis.html#synchronous-section">synchronous
   section</a> consists of all the remaining steps of this algorithm until the algorithm says the
   <a href="webappapis.html#synchronous-section">synchronous section</a> has ended. (Steps in <a data-anolis-xref="synchronous
   section" href="webappapis.html#synchronous-section">synchronous sections</a> are marked with ⌛.)</li>

   <li>

    <p>⌛ If another instance of this algorithm for this <code><a href="#the-img-element">img</a></code> element was started
    after this instance (even if it aborted and is no longer running), then abort these steps.</p>

    <p class="note">Only the last instance takes effect, to avoid multiple requests when, for
    example, the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code>, <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code>,
    and <code data-anolis-xref="attr-img-crossorigin"><a href="#attr-img-crossorigin">crossorigin</a></code> attributes are all set in
    succession.</p>

   </li>

   <li>

    <p>⌛ Let <var data-anolis-xref="">selected source</var> and <var data-anolis-xref="">selected pixel density</var> be the
    URL and pixel density that results from <a data-anolis-xref="select an image source" href="#select-an-image-source">selecting an image source</a>,
    respectively.</p>

   </li>

   <li>

    <p>⌛ If <var data-anolis-xref="">selected source</var> is null, run these substeps:</p>

    <ol><li><p>⌛ Set the <a href="#current-request">current request</a> to the <a data-anolis-xref="img-error" href="#img-error">broken</a> state,
     <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a> and the <a href="#pending-request">pending request</a>,
     and let <a href="#pending-request">pending request</a> be null.</li>

     <li><p>⌛ <a href="webappapis.html#queue-a-task">Queue a task</a> to change the <a href="#current-request">current request</a>'s <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a> to the empty string,
     and then, if the element has a <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute
     or a <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code> attribute
     or a parent that is a <code><a href="#the-picture-element">picture</a></code> element,
     <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <code><a href="#the-img-element">img</a></code> element.</li><!-- loadstart and loadend do not fire -->

     

     <li><p>⌛ Abort this algorithm.</li>

    </ol></li>

   <li>

    <p>⌛ <a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="infrastructure.html#fire-a-progress-event">fire a progress event</a> named <code data-anolis-xref="event-loadstart"><a href="index.html#event-loadstart">loadstart</a></code> at
    the <code><a href="#the-img-element">img</a></code> element.</p>

   </li>

   <li><p><a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">Resolve</a> <var data-anolis-xref="">selected source</var>, relative
   to the element, and let the result be <var data-anolis-xref="">absolute URL</var>. If that is not successful, then
   <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a> and the <a href="#pending-request">pending request</a>,
   set the <a href="#current-request">current request</a> to the <a data-anolis-xref="img-error" href="#img-error">broken</a> state,
   let <a href="#pending-request">pending request</a> be null,
   <a href="webappapis.html#queue-a-task">queue a task</a> to
   change the <a href="#current-request">current request</a>'s <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a> to <var data-anolis-xref="">absolute URL</var>,
   <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <code><a href="#the-img-element">img</a></code> element
   and then <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-loadend"><a href="index.html#event-loadend">loadend</a></code> at the <code><a href="#the-img-element">img</a></code> element,
   and abort these steps.</li>

   <li>

    <p>⌛ If the <a href="#pending-request">pending request</a> is not null,
    and <var data-anolis-xref="">absolute URL</var> is the same as the <a href="#pending-request">pending request</a>'s <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a>,
    then abort these steps.</p>

    <p>⌛ If <var data-anolis-xref="">absolute URL</var> is the same as the <a href="#current-request">current request</a>'s <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a>,
    and <a href="#current-request">current request</a> is in the <a data-anolis-xref="img-inc" href="#img-inc">partially available</a> state,
    then <a href="#abort-the-image-request">abort the image request</a> for the <a href="#pending-request">pending request</a>,
    <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="#restart-the-animation">restart the animation</a> if <i data-anolis-xref="">restart animation</i> is set,
    and abort these steps.</p>

    <p>⌛ If the <a href="#pending-request">pending request</a> is not null,
    <a href="#abort-the-image-request">abort the image request</a> for the <a href="#pending-request">pending request</a>.</p>

    <p>⌛ Let <var data-anolis-xref="">image request</var> be a new <a href="#image-request">image request</a>
    whose <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a> is <var data-anolis-xref="">absolute URL</var>.</p>

    <p>⌛ Let the <a href="#pending-request">pending request</a> be <var data-anolis-xref="">image request</var>.</p>

    <p>⌛ Do a <a href="infrastructure.html#potentially-cors-enabled-fetch">potentially CORS-enabled fetch</a><!--FETCH-->  of <var data-anolis-xref="">absolute URL</var>,
    with the <i data-anolis-xref="">mode</i> being the current state of
    the element's <code data-anolis-xref="attr-img-crossorigin"><a href="#attr-img-crossorigin">crossorigin</a></code> content attribute, the <i data-anolis-xref="">origin</i> being the <a href="browsers.html#origin-0">origin</a> of the <code><a href="#the-img-element">img</a></code> element's
    <code><a href="dom.html#document">Document</a></code>, and the <i data-anolis-xref="">default origin behaviour</i> set to <i data-anolis-xref="">taint</i>.
    Let this instance of the <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching</a> algorithm be associated with <var data-anolis-xref="">image request</var>.<!-- XXXX
    "Interaction with the Preload Scanner" from the picture spec --></p>

    <p>The resource obtained in this fashion, if any, is <var data-anolis-xref="">image request</var>'s <a data-anolis-xref="img-req-data" href="#img-req-data">image data</a>.
    It can be either <a href="infrastructure.html#cors-same-origin">CORS-same-origin</a> or <a href="infrastructure.html#cors-cross-origin">CORS-cross-origin</a>; this affects
    the <a href="browsers.html#origin-0">origin</a> of the image itself (e.g. when used on a <code><a href="scripting-1.html#the-canvas-element">canvas</a></code>).</p><!-- same text in <input type=image> section and similar text elsewhere -->

    
    <p>Fetching the image must <a href="syntax.html#delay-the-load-event">delay the load event</a> of the element's document until the
    <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the
    <a href="webappapis.html#networking-task-source">networking task source</a> once the resource has been <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> (<a href="#img-load">defined below</a>) has been run.
    
    <!--XXX or the fetch was aborted, presumably --></p>

    <p class="warning">This, unfortunately, can be used to perform a rudimentary port scan of the
    user's local network (especially in conjunction with scripting, though scripting isn't actually
    necessary to carry out such an attack). User agents may implement <a data-anolis-xref="origin" href="browsers.html#origin-0">cross-origin</a> access control policies that are stricter than those
    described above to mitigate this attack, but unfortunately such policies are typically not
    compatible with existing Web content.</p>

    <p>If the resource is <a href="infrastructure.html#cors-same-origin">CORS-same-origin</a>, each <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a>
    that is <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a>
    while the image is being <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a>,
    if <var data-anolis-xref="">image request</var> is the <a href="#current-request">current request</a>,
    must <a href="infrastructure.html#fire-a-progress-event">fire a progress event</a> named <code data-anolis-xref="event-progress"><a href="index.html#event-progress">progress</a></code> at the <code><a href="#the-img-element">img</a></code> element.</p>

   </li>

   <li><p>End the <a href="webappapis.html#synchronous-section">synchronous section</a>, continuing the remaining steps asynchronously,
   but without missing any data from the <a href="infrastructure.html#fetch">fetch</a> algorithm.</li>

   <li>

    <p>As soon as possible, jump to the first applicable entry from the following list:</p>

    <dl class="switch"><dt>If the resource type is <code><a href="iana.html#multipart/x-mixed-replace">multipart/x-mixed-replace</a></code></dt>

     <dd>

      <p>The next <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a
      task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> while the image is being <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> must run the following steps:</p>

      <ol><li>

        <p>If <var data-anolis-xref="">image request</var> is the <a href="#pending-request">pending request</a>
        and the user agent is able to determine <var data-anolis-xref="">image request</var>'s image's width and height,
        <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a>,
        <a href="#upgrade-the-pending-request-to-the-current-request">upgrade the pending request to the current request</a> and
        set the <a href="#current-request">current request</a>'s state to <a data-anolis-xref="img-inc" href="#img-inc">partially available</a>.</p>

       </li>

       <li>

        <p>Otherwise, if <var data-anolis-xref="">image request</var> is the <a href="#pending-request">pending request</a>
        and the user agent is able to determine that <var data-anolis-xref="">image request</var>'s image
        is corrupted in some fatal way such that the image dimensions cannot be obtained,
        <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a>,
        <a href="#upgrade-the-pending-request-to-the-current-request">upgrade the pending request to the current request</a>
        and set the <a href="#current-request">current request</a>'s state to <a data-anolis-xref="img-error" href="#img-error">broken</a>.</p>

       </li>

       <li>

        <p>Otherwise, if <var data-anolis-xref="">image request</var> is the <a href="#current-request">current request</a>,
        it is in the <a data-anolis-xref="img-none" href="#img-none">unavailable</a> state,
        and the user agent is able to determine <var data-anolis-xref="">image request</var>'s image's width and height,
        set the <a href="#current-request">current request</a>'s state to <a data-anolis-xref="img-inc" href="#img-inc">partially available</a>.</p>

       </li>

       <li>

        <p>Otherwise, if <var data-anolis-xref="">image request</var> is the <a href="#current-request">current request</a>,
        it is in the <a data-anolis-xref="img-none" href="#img-none">unavailable</a> state,
        and the user agent is able to determine that <var data-anolis-xref="">image request</var>'s image
        is corrupted in some fatal way such that the image dimensions cannot be obtained,
        set the <a href="#current-request">current request</a>'s state to <a data-anolis-xref="img-error" href="#img-error">broken</a>.
        
        <!--XXX abort the fetch? fire error event?--></p>

       </li>

      </ol><p>Each <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a
      task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> while the image is being <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> must update the presentation of the image, but as each new body
      part comes in, it must replace the previous image. Once one body part has been completely
      decoded, the user agent must set the <code><a href="#the-img-element">img</a></code> element to the <a data-anolis-xref="img-all" href="#img-all">completely available</a> state and <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire
      a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the <code><a href="#the-img-element">img</a></code>
      element.  <!--XXX what if the image is broken? --></p>

      <p class="note">The <code data-anolis-xref="event-progress"><a href="index.html#event-progress">progress</a></code> and <code data-anolis-xref="event-loadend"><a href="index.html#event-loadend">loadend</a></code> events are not fired for
      <code><a href="iana.html#multipart/x-mixed-replace">multipart/x-mixed-replace</a></code> image streams.</p>

     </dd>

     <dt>If the resource type and data corresponds to a supported image format, <a href="#img-determine-type">as described below</a></dt>

     <dd>

      <p>The next <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a
      task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> while the image is being <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> must run the following steps:</p>

      <ol><li>

        <p>If the user agent is able to determine <var data-anolis-xref="">image request</var>'s image's width and height,
        and <var data-anolis-xref="">image request</var> is <a href="#pending-request">pending request</a>,
        <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a>,
        <a href="#upgrade-the-pending-request-to-the-current-request">upgrade the pending request to the current request</a>,
        update the <code><a href="#the-img-element">img</a></code> element's presentation appropriately,
        and set <var data-anolis-xref="">image request</var>'s state to <a data-anolis-xref="img-inc" href="#img-inc">partially available</a>.</p>

       </li>

       <li>

        <p>Otherwise, if the user agent is able to determine <var data-anolis-xref="">image request</var>'s image's width and height,
        and <var data-anolis-xref="">image request</var> is <a href="#current-request">current request</a>,
        update the <code><a href="#the-img-element">img</a></code> element's presentation appropriately
        and set <var data-anolis-xref="">image request</var>'s state to <a data-anolis-xref="img-inc" href="#img-inc">partially available</a>.</p>

       </li>

       <li>

        <p>Otherwise, if the user agent is able to determine that <var data-anolis-xref="">image request</var>'s image
        is corrupted in some fatal way such that the image dimensions cannot be obtained,
        and <var data-anolis-xref="">image request</var> is <a href="#pending-request">pending request</a>,
        <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a> and the <a href="#pending-request">pending request</a>,
        <a href="#upgrade-the-pending-request-to-the-current-request">upgrade the pending request to the current request</a>,
        set <a href="#current-request">current request</a> to the <a data-anolis-xref="img-error" href="#img-error">broken</a> state,
        <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <code><a href="#the-img-element">img</a></code> element,
        <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-loadend"><a href="index.html#event-loadend">loadend</a></code> at the <code><a href="#the-img-element">img</a></code> element,
        and abort these steps.</p>

       </li>

       <li>

        <p>Otherwise, if the user agent is able to determine that <var data-anolis-xref="">image request</var>'s image
        is corrupted in some fatal way such that the image dimensions cannot be obtained,
        and <var data-anolis-xref="">image request</var> is <a href="#current-request">current request</a>,
        <a href="#abort-the-image-request">abort the image request</a> for <var data-anolis-xref="">image request</var>,
        <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <code><a href="#the-img-element">img</a></code> element,
        <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-loadend"><a href="index.html#event-loadend">loadend</a></code> at the <code><a href="#the-img-element">img</a></code> element,
        and abort these steps.</p>

       </li>

      </ol><p id="img-load">That <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a>, and each subsequent <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a>, that is <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the
      <a href="webappapis.html#networking-task-source">networking task source</a> while the image is being <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a>,
      if <var data-anolis-xref="">image request</var> is the <a href="#current-request">current request</a>,
      must update the presentation of the image appropriately (e.g. if
      the image is a progressive JPEG, each packet can improve the resolution of the image).</p>

      <p>Furthermore, the last <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a
      task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> once the resource has been
      <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> must additionally run these steps:</p>

      <ol><!--
       the download was successful
       the user agent was able to determine the image's width and height
       image request is current request
       pending request might be null or non-null
       --><li><p>Set <var data-anolis-xref="">image request</var> to the <a data-anolis-xref="img-all" href="#img-all">completely
       available</a> state.</p>

       </li><li><p>Add the image to the <a href="#list-of-available-images">list of available images</a> using the key <var data-anolis-xref="">key</var>, with the <a href="#ignore-higher-layer-caching">ignore higher-layer caching</a> flag set.</li>

       <li><p><a href="#fire-a-progress-event-or-simple-event">Fire a progress event or simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code>
       at the <code><a href="#the-img-element">img</a></code> element, depending on the resource in <var data-anolis-xref="">image request</var>.</li>

       <li><p><a href="#fire-a-progress-event-or-simple-event">Fire a progress event or simple event</a> named <code data-anolis-xref="event-loadend"><a href="index.html#event-loadend">loadend</a></code>
       at the <code><a href="#the-img-element">img</a></code> element, depending on the resource in <var data-anolis-xref="">image request</var>.</li>

      </ol></dd>

     <dt>そうでなければ</dt>

     <dd>

      <p>The image data is not in a supported file format; the user agent must set
      <var data-anolis-xref="">image request</var> to the <a data-anolis-xref="img-error" href="#img-error">broken</a> state,
      <a href="#abort-the-image-request">abort the image request</a> for the <a href="#current-request">current request</a> and the <a href="#pending-request">pending request</a>,
      <a href="#upgrade-the-pending-request-to-the-current-request">upgrade the pending request to the current request</a>,
      and then <a href="webappapis.html#queue-a-task">queue a task</a> to first <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <code><a href="#the-img-element">img</a></code> element and then <a href="webappapis.html#fire-a-simple-event">fire a simple
      event</a> named <code data-anolis-xref="event-loadend"><a href="index.html#event-loadend">loadend</a></code> at the <code><a href="#the-img-element">img</a></code>
      element.</p>

     </dd>

    </dl></li>

  </ol><p>To <dfn id="abort-the-image-request">abort the image request</dfn> for an <a href="#image-request">image request</a> <var data-anolis-xref="">image request</var> means to run the following steps:</p>

  <ol><li><p>Forget <var data-anolis-xref="">image request</var>'s <a data-anolis-xref="img-req-data" href="#img-req-data">image data</a>, if any.</li>

   <li><p>Abort any instance of the <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching</a> algorithm for <var data-anolis-xref="">image request</var>,
   discarding any pending tasks generated by that algorithm.</li>

  </ol><p>To <dfn id="upgrade-the-pending-request-to-the-current-request">upgrade the pending request to the current request</dfn> for an <code><a href="#the-img-element">img</a></code> element means to run the following steps:</p>

  <ol><li><p>Let the <code><a href="#the-img-element">img</a></code> element's <a href="#current-request">current request</a> be the <a href="#pending-request">pending request</a>.</li>

   <li><p>Let the <code><a href="#the-img-element">img</a></code> element's <a href="#pending-request">pending request</a> be null.</li>

  </ol><p>To <dfn id="fire-a-progress-event-or-simple-event">fire a progress event or simple event</dfn> named <var data-anolis-xref="">type</var> at an element <var data-anolis-xref="">e</var>,
  depending on resource <var data-anolis-xref="">r</var>, means to
  <a href="infrastructure.html#fire-a-progress-event">fire a progress event</a> named <var data-anolis-xref="">type</var> at <var data-anolis-xref="">e</var> if <var data-anolis-xref="">r</var> is <a href="infrastructure.html#cors-same-origin">CORS-same-origin</a>,
  and otherwise <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <var data-anolis-xref="">type</var> at <var data-anolis-xref="">e</var>.</p>

  <p>To <dfn id="restart-the-animation">restart the animation</dfn> for an <code><a href="#the-img-element">img</a></code> element means that,
  if the image is an animated image,
  all animated images with the same <a href="infrastructure.html#absolute-url">absolute URL</a> and the same image data in the <code><a href="#the-img-element">img</a></code> element's <code><a href="dom.html#document">Document</a></code>
  are expected to restart their animation.</p>

  <p>While a user agent is running the above algorithm for an element <var data-anolis-xref="">x</var>, there
  must be a strong reference from the element's <code><a href="dom.html#document">Document</a></code> to the element <var data-anolis-xref="">x</var>, even if that element is not <a data-anolis-xref="in a Document" href="infrastructure.html#in-a-document">in</a> its
  <code><a href="dom.html#document">Document</a></code>.</p>

  <p>When an <code><a href="#the-img-element">img</a></code> element is in the <a data-anolis-xref="img-all" href="#img-all">completely available</a>
  state <em>and</em> the user agent can decode the media data without errors, then the
  <code><a href="#the-img-element">img</a></code> element is said to be <dfn data-anolis-xref="img-good" id="img-good">fully decodable</dfn>.</p>

  <p>Whether the image is fetched successfully or not (e.g. whether the response code was a 2xx code
  <a data-anolis-xref="concept-http-equivalent-codes" href="infrastructure.html#concept-http-equivalent-codes">or equivalent</a>) must be ignored when determining
  the image's type and whether it is a valid image.</p>

  <p class="note">This allows servers to return images with error responses, and have them
  displayed.</p>

  <p id="img-determine-type">The user agent should apply the <a data-anolis-xref="Content-Type sniffing:
  image" href="infrastructure.html#content-type-sniffing:-image">image sniffing rules</a> to determine the type of the image, with the image's <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">associated Content-Type headers</a> giving the <var data-anolis-xref="">official
  type</var>. If these rules are not applied, then the type of the image must be the type given by
  the image's <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">associated Content-Type headers</a>.</p>

  <p>User agents must not support non-image resources with the <code><a href="#the-img-element">img</a></code> element (e.g. XML
  files whose root element is an HTML element). User agents must not run executable code (e.g.
  scripts) embedded in the image resource. User agents must only display the first page of a
  multipage resource (e.g. a PDF file). User agents must not allow the resource to act in an
  interactive fashion, but should honor any animation in the resource.</p>

  <p>This specification does not specify which image types are to be supported.</p>

  <hr><p>An <code><a href="#the-img-element">img</a></code> element is associated with a <a href="#source-set">source set</a>.</p>

  <p>A <dfn id="source-set">source set</dfn> is a set of zero or more <a data-anolis-xref="image source" href="#image-source">image sources</a>
  and a <a href="#source-size-0">source size</a>.</p>

  <p>An <dfn id="image-source">image source</dfn> is a <a href="infrastructure.html#url">URL</a>,
  and optionally either a density descriptor, or a width descriptor.</p>

  <p>A <dfn id="source-size-0">source size</dfn> is a <a href="#source-size-value">&lt;source-size-value&gt;</a>.
  When a <a href="#source-size-0">source size</a> has a unit relative to the viewport,
  it must be interpreted relative to the <code><a href="#the-img-element">img</a></code> element's document's viewport.
  Other units must be interpreted the same as in Media Queries. <a href="references.html#refsMQ">[MQ]</a></p>

  <p>When asked to <dfn id="select-an-image-source">select an image source</dfn> for a given <code><a href="#the-img-element">img</a></code> element <var data-anolis-xref="">el</var>,
  user agents must do the following:</p>

  <ol><li><p><a href="#update-the-source-set">Update the source set</a> for <var data-anolis-xref="">el</var>.</li>

   <li><p>If <var data-anolis-xref="">el</var>'s <a href="#source-set">source set</a> is empty,
   return null as the URL and undefined as the pixel density and abort these steps.</li>

   <li><p>Otherwise, take <var data-anolis-xref="">el</var>'s <a href="#source-set">source set</a>
   and let it be <var data-anolis-xref="">source set</var>.</li>

   <li><p>In a user agent-specific manner,
   choose one <a href="#image-source">image source</a> from <var data-anolis-xref="">source set</var>.
   Let this be <var data-anolis-xref="">selected source</var>.</li>

   <li><p>Return <var data-anolis-xref="">selected source</var> and its associated pixel density.</li>

  </ol><p>When asked to <dfn id="update-the-source-set">update the source set</dfn> for a given <code><a href="#the-img-element">img</a></code> element <var data-anolis-xref="">el</var>,
  user agents must do the following:</p>

  <ol><li><p>Set <var data-anolis-xref="">el</var>'s <a href="#source-set">source set</a> to an empty <a href="#source-set">source set</a>.</li>

   <li><p>If <var data-anolis-xref="">el</var> has a parent node and that is a <code><a href="#the-picture-element">picture</a></code> element,
   let <var data-anolis-xref="">elements</var> be an array containing <var data-anolis-xref="">el</var>'s parent node's child elements, retaining relative order.
   Otherwise, let <var data-anolis-xref="">elements</var> be array containing only <var data-anolis-xref="">el</var>.</li>

   <li>

    <p>Iterate through <var data-anolis-xref="">elements</var>,
    doing the following for each item <var data-anolis-xref="">child</var>:</p>

    <ol><li>

      <p>If <var data-anolis-xref="">child</var> is <var data-anolis-xref="">el</var>:</p>

      <ol><li><p>If <var data-anolis-xref="">child</var> has a <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code> attribute,
       <a data-anolis-xref="parse a srcset attribute" href="#parse-a-srcset-attribute">parse <var data-anolis-xref="">child</var>'s srcset attribute</a>
       and let the returned <a href="#source-set">source set</a> be <var data-anolis-xref="">source set</var>.
       Otherwise, let <var data-anolis-xref="">source set</var> be an empty <a href="#source-set">source set</a>.</li>

       <li><p><a data-anolis-xref="parse a sizes attribute" href="#parse-a-sizes-attribute">Parse <var data-anolis-xref="">child</var>'s sizes attribute</a> and
       let <var data-anolis-xref="">source set</var>'s <a href="#source-size-0">source size</a> be the returned value.</li>

       <li><p>If <var data-anolis-xref="">child</var> has a <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute
       whose value is not the empty string
       and <var data-anolis-xref="">source set</var> does not contain an
       <a href="#image-source">image source</a> with a density descriptor value of 1,
       and no <a href="#image-source">image source</a> with a width descriptor,
       append <var data-anolis-xref="">child</var>'s <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute value to <var data-anolis-xref="">source set</var>.</li>

       <li><p>Let <var data-anolis-xref="">el</var>'s <a href="#source-set">source set</a> be <var data-anolis-xref="">source set</var>.</li>

       <li><p>Abort this algorithm.</li>

      </ol></li>

     <li><p>If <var data-anolis-xref="">child</var> is not a <code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code> element,
     continue to the next child.
     Otherwise, <var data-anolis-xref="">child</var> is a <code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code> element.</li>

     <li><p>If <var data-anolis-xref="">child</var> does not have a <code data-anolis-xref="attr-picture-source-srcset"><a href="#attr-picture-source-srcset">srcset</a></code> attribute,
     continue to the next child.</li>

     <li><p><a data-anolis-xref="parse a srcset attribute" href="#parse-a-srcset-attribute">Parse <var data-anolis-xref="">child</var>'s srcset attribute</a> and
     let the returned <a href="#source-set">source set</a> be <var data-anolis-xref="">source set</var>.</li>

     <li><p>If <var data-anolis-xref="">source set</var> has zero <a data-anolis-xref="image source" href="#image-source">image sources</a>,
     continue to the next child.</li>

     <li><p>If <var data-anolis-xref="">child</var> has a <code data-anolis-xref="attr-picture-source-media"><a href="#attr-picture-source-media">media</a></code> attribute,
     and its value is not a <a href="infrastructure.html#valid-media-query">valid media query</a>,
     or is a <a href="infrastructure.html#valid-media-query">valid media query</a> that evaluates to false,
     continue to the next child.</li>

     <li><p><a data-anolis-xref="parse a sizes attribute" href="#parse-a-sizes-attribute">Parse <var data-anolis-xref="">child</var>'s sizes attribute</a>
     and let <var data-anolis-xref="">source set</var>'s <a href="#source-size-0">source size</a> be the returned value.</li>

     <li><p>If <var data-anolis-xref="">child</var> has a <code data-anolis-xref="attr-picture-source-type"><a href="attr-picture-source-type">type</a></code> attribute,
     and its value is an unknown or unsupported <a href="infrastructure.html#mime-type">MIME type</a>,
     continue to the next child.</li>

     <li><p><a href="#normalize-the-source-densities">Normalize the source densities</a> of <var data-anolis-xref="">source set</var>.</li>

     <li><p>Let <var data-anolis-xref="">el</var>'s <a href="#source-set">source set</a> be <var data-anolis-xref="">source set</var>.</li>

     <li><p>Abort this algorithm.</li>

    </ol></li>

  </ol><p class="note">Each <code><a href="#the-img-element">img</a></code> element independently considers
  its previous sibling <code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code> elements
  plus the <code><a href="#the-img-element">img</a></code> element itself
  for selecting an <a href="#image-source">image source</a>, ignoring any other (invalid) elements,
  including other <code><a href="#the-img-element">img</a></code> elements in the same <code><a href="#the-picture-element">picture</a></code> element,
  or <code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code> elements that are following siblings
  of the relevant <code><a href="#the-img-element">img</a></code> element.</p>

  <p>When asked to <dfn id="parse-a-srcset-attribute">parse a srcset attribute</dfn> from an element,
  parse the value of the element's <code>srcset</code> attribute as follows:</p>

  <ol><li><p>Let <var data-anolis-xref="">input</var> be the value passed to this algorithm.</li>

   <li><p>Let <var data-anolis-xref="">position</var> be a pointer into <var data-anolis-xref="">input</var>,
   initially pointing at the start of the string.</li>

   <li><p>Let <var data-anolis-xref="">raw candidates</var> be an initially empty
   ordered list of URLs with associated unparsed descriptor list.
   The order of entries in the lists is the order in which entries are added to the lists.</li>

   <li><p><i data-anolis-xref="">Splitting loop</i>: <a href="infrastructure.html#collect-a-sequence-of-characters">Collect a sequence of characters</a>
   that are <a data-anolis-xref="space character" href="infrastructure.html#space-character">space characters</a> or U+002C COMMA characters.</li>

   <li><p>If <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>,
   then jump to the step labeled <i data-anolis-xref="">descriptor parser</i>.</li>

   <li><p><a href="infrastructure.html#collect-a-sequence-of-characters">Collect a sequence of characters</a> that are not
   <a data-anolis-xref="space character" href="infrastructure.html#space-character">space characters</a>, and let that be <var data-anolis-xref="">url</var>.</li>

   <li><p>Let <var data-anolis-xref="">descriptors</var> be a new empty list.</li>

   <li>

    <p>If <var data-anolis-xref="">url</var> ends with a "," (U+002C) character,
    follow these substeps:</p>

    <ol><li><p>Remove all trailing U+002C COMMA characters from <var data-anolis-xref="">url</var>.</li>

     <li><p>If <var data-anolis-xref="">url</var> is empty,
     then jump to the step labeled <i data-anolis-xref="">splitting loop</i>.</li>

    </ol><p>Otherwise, follow these substeps:</p>

    <ol><li><p>Let <var data-anolis-xref="">current token</var> be the empty string.</li>

     <li><p>Let <var data-anolis-xref="">state</var> be <i data-anolis-xref="">start</i>.</li>

     <li>

      <p>Let <var data-anolis-xref="">c</var> be the character at <var data-anolis-xref="">position</var>.
      Do the following depending on the value of <var data-anolis-xref="">state</var>.
      For the purpose of this step, "EOF" is a special character representing
      that <var data-anolis-xref="">position</var> is past the end of <var data-anolis-xref="">input</var>.</p>

      <dl class="switch"><dt><i title="">Start</i></dt>

       <dd>

        <p>Do the following, depending on the value of <var data-anolis-xref="">c</var>:</p>

        <dl class="switch"><dt><a href="infrastructure.html#space-character">Space character</a></dt>

         <dd><p>If <var data-anolis-xref="">current token</var> is not empty,
         append <var data-anolis-xref="">current token</var> to <var data-anolis-xref="">descriptors</var>
         and let <var data-anolis-xref="">current token</var> be the empty string.
         Set <var data-anolis-xref="">state</var> to <i data-anolis-xref="">after token</i>.</dd>

         <dt>"," (U+002C)</dt>

         <dd><p>Advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>.
         If <var data-anolis-xref="">current token</var> is not empty,
         append <var data-anolis-xref="">current token</var> to <var data-anolis-xref="">descriptors</var>.
         Jump to the step labeled <i data-anolis-xref="">add candidate</i>.</dd>

         <dt>"(" (U+0028)</dt>

         <dd><p>Append <var data-anolis-xref="">c</var> to <var data-anolis-xref="">current token</var>.
         Set <var data-anolis-xref="">state</var> to <i data-anolis-xref="">in parens</i>.</dd>

         <dt>EOF</dt>

         <dd><p>If <var data-anolis-xref="">current token</var> is not empty,
         append <var data-anolis-xref="">current token</var> to <var data-anolis-xref="">descriptors</var>.
         Jump to the step labeled <i data-anolis-xref="">add candidate</i>.</dd>

         <dt>Anything else</dt>

         <dd><p>Append <var data-anolis-xref="">c</var> to <var data-anolis-xref="">current token</var>.</dd>

        </dl></dd>

       <dt><i title="">In parens</i></dt>

       <dd>

        <p>Do the following, depending on the value of <var data-anolis-xref="">c</var>:</p>

        <dl class="switch"><dt>")" (U+0029)</dt>

         <dd><p>Append <var data-anolis-xref="">c</var> to <var data-anolis-xref="">current token</var>.
         Set <var data-anolis-xref="">state</var> to <i data-anolis-xref="">start</i>.</dd>

         <dt>EOF</dt>

         <dd><p>Append <var data-anolis-xref="">current token</var> to <var data-anolis-xref="">descriptors</var>.
         Jump to the step labeled <i data-anolis-xref="">add candidate</i>.</dd>

         <dt>Anything else</dt>

         <dd><p>Append <var data-anolis-xref="">c</var> to <var data-anolis-xref="">current token</var>.</dd>

        </dl></dd>

       <dt><i title="">After token</i></dt>

       <dd>

        <p>Do the following, depending on the value of <var data-anolis-xref="">c</var>:</p>

        <dl class="switch"><dt><a href="infrastructure.html#space-character">Space character</a></dt>

         <dd><p>Stay in this state.</dd>

         <dt>EOF</dt>

         <dd><p>Jump to the step labeled <i data-anolis-xref="">add candidate</i>.</dd>

         <dt>Anything else</dt>

         <dd><p>Set <var data-anolis-xref="">state</var> to <i data-anolis-xref="">start</i>.
         Set <var data-anolis-xref="">position</var> to the <em>previous</em> character in <var data-anolis-xref="">input</var>.</dd>

        </dl></dd>

      </dl><p>Advance <var data-anolis-xref="">position</var> to the next character in <var data-anolis-xref="">input</var>.
      Repeat this step.</p>

     </li>

    </ol></li>

   <li><p><i data-anolis-xref="">Add candidate</i>: Add <var data-anolis-xref="">url</var> to <var data-anolis-xref="">raw candidates</var>,
   associated with <var data-anolis-xref="">descriptors</var>.</li>

   <li><p>Return to the step labeled <i data-anolis-xref="">splitting loop</i>.</li>

   <li><p><i data-anolis-xref="">Descriptor parser</i>:
   Let <var data-anolis-xref="">candidates</var> be an initially empty <a href="#source-set">source set</a>.
   The order of entries in the list is the order in which entries are added to the list.</li>

   <li>

    <p>For each entry in <var data-anolis-xref="">raw candidates</var> with URL <var data-anolis-xref="">url</var>
    associated with the unparsed descriptor list <var data-anolis-xref="">descriptor list</var>,
    run these substeps:</p>

    <ol><li><p>Let <var data-anolis-xref="">error</var> be <i data-anolis-xref="">no</i>.</li>

     <li><p>Let <var data-anolis-xref="">width</var> be <i data-anolis-xref="">absent</i>.</li>

     <li><p>Let <var data-anolis-xref="">density</var> be <i data-anolis-xref="">absent</i>.</li>

     <li><p>Let <var data-anolis-xref="">future-compat-h</var> be <i data-anolis-xref="">absent</i>.</li>

     <li>

      <p>For each token in <var data-anolis-xref="">descriptor list</var>,
      run the appropriate set of steps from the following list:</p>

      <dl class="switch"><dt>If the token consists of a <a href="infrastructure.html#valid-non-negative-integer">valid non-negative integer</a>
       followed by a U+0077 LATIN SMALL LETTER W character</dt>

       <dd>

        <ol><li><p>If <var data-anolis-xref="">width</var> and <var data-anolis-xref="">density</var>
         are not both <i data-anolis-xref="">absent</i>,
         then let <var data-anolis-xref="">error</var> be <i data-anolis-xref="">yes</i>.</li>

         <li><p>Apply the <a href="infrastructure.html#rules-for-parsing-non-negative-integers">rules for parsing non-negative integers</a> to the token.
         If the result is zero, let <var data-anolis-xref="">error</var> be <i data-anolis-xref="">yes</i>.
         Otherwise, let <var data-anolis-xref="">width</var> be the result.</li>

        </ol></dd>

       <dt>If the token consists of a <a href="infrastructure.html#valid-floating-point-number">valid floating-point number</a>
       followed by a U+0078 LATIN SMALL LETTER X character</dt>

       <dd>

        <ol><li><p>If <var data-anolis-xref="">width</var>, <var data-anolis-xref="">density</var> and <var data-anolis-xref="">future-compat-h</var>
         are not all <i data-anolis-xref="">absent</i>,
         then let <var data-anolis-xref="">error</var> be <i data-anolis-xref="">yes</i>.</li>

         <li>

          <p>Apply the <a href="infrastructure.html#rules-for-parsing-floating-point-number-values">rules for parsing floating-point number values</a> to the token.
          If the result is less than zero, let <var data-anolis-xref="">error</var> be <i data-anolis-xref="">yes</i>.
          Otherwise, let <var data-anolis-xref="">density</var> be the result.</p>

          <p class="note">If <var data-anolis-xref="">density</var> is zero,
          the intrinsic dimensions will be infinite.
          User agents are expected to have limits in how big images can be rendered,
          which is allowed by the <a href="infrastructure.html#hardwareLimitations">hardware limitations</a> clause.</p>

         </li>

        </ol></dd>

       <dt>If the token consists of a <a href="infrastructure.html#valid-non-negative-integer">valid non-negative integer</a>
       followed by a U+0068 LATIN SMALL LETTER H character</dt>

       <dd>

        <ol><li><p>If <var data-anolis-xref="">future-compat-h</var> and <var data-anolis-xref="">density</var>
         are not both <i data-anolis-xref="">absent</i>,
         then let <var data-anolis-xref="">error</var> be <i data-anolis-xref="">yes</i>.</li>

         <li><p>Apply the <a href="infrastructure.html#rules-for-parsing-non-negative-integers">rules for parsing non-negative integers</a> to the token.
         If the result is zero, let <var data-anolis-xref="">error</var> be <i data-anolis-xref="">yes</i>.
         Otherwise, let <var data-anolis-xref="">future-compat-h</var> be the result.</li>

        </ol></dd>

      </dl></li>

     <li><p>If <var data-anolis-xref="">error</var> is still <i data-anolis-xref="">no</i>,
     then add a new <a href="#image-source">image source</a> to <var data-anolis-xref="">candidates</var>
     whose URL is <var data-anolis-xref="">url</var>,
     associated with a width <var data-anolis-xref="">width</var> if not <i data-anolis-xref="">absent</i>
     and a pixel density <var data-anolis-xref="">density</var> if not <i data-anolis-xref="">absent</i>.</li>

    </ol></li>

   <li><p>Return <var data-anolis-xref="">candidates</var>.</li>

  </ol><p>When asked to <dfn id="parse-a-sizes-attribute">parse a sizes attribute</dfn> from an element,
  <a href="#parse-a-comma-separated-list-of-component-values">parse a comma-separated list of component values</a>
  from the value of the element's <code data-anolis-xref="">sizes</code> attribute
  (or the empty string, if the attribute is absent),
  and let <var data-anolis-xref="">unparsed sizes list</var> be the result. <a href="references.html#refsCSSSYNTAX">[CSSSYNTAX]</a></p>

  <p>For each <var data-anolis-xref="">unparsed size</var> in <var data-anolis-xref="">unparsed sizes list</var>:</p>

  <ol><li><p>Remove all consecutive <a href="#whitespace-token">&lt;whitespace-token&gt;</a>s
   from the end of <var data-anolis-xref="">unparsed size</var>.
   If <var data-anolis-xref="">unparsed size</var> is now empty,
   continue to the next iteration of this algorithm.</li>

   <li><p>If the last <a href="#component-value">component value</a> in <var data-anolis-xref="">unparsed size</var>
   is a valid non-negative <a href="#source-size-value">&lt;source-size-value&gt;</a>,
   let <var data-anolis-xref="">size</var> be its value
   and remove the <a href="#component-value">component value</a> from <var data-anolis-xref="">unparsed size</var>.
   Otherwise, continue to the next iteration of this algorithm.</li>

   <li><p>Remove all consecutive <a href="#whitespace-token">&lt;whitespace-token&gt;</a>s
   from the end of <var data-anolis-xref="">unparsed size</var>.
   If <var data-anolis-xref="">unparsed size</var> is now empty,
   return <var data-anolis-xref="">size</var> and exit this algorithm.</li>

   <li><p>Parse the remaining <a data-anolis-xref="component value" href="#component-value">component values</a> in <var data-anolis-xref="">unparsed size</var>
   as a <a href="#media-condition">&lt;media-condition&gt;</a>.
   If it does not parse correctly,
   or it does parse correctly but the <a href="#media-condition">&lt;media-condition&gt;</a> evaluates to false,
   continue to the next iteration of this algorithm. <a href="references.html#refsMQ">[MQ]</a></li>

   <li><p>Return <var data-anolis-xref="">size</var> and exit this algorithm.</li>

  </ol><p>If the above algorithm exhausts <var data-anolis-xref="">unparsed sizes list</var> without returning a <var data-anolis-xref="">size</var> value,
  return <code data-anolis-xref="">100vw</code>.</p>

  <p class="note">While a <a href="#valid-source-size-list">valid source size list</a> only contains a bare <a href="#source-size-value">&lt;source-size-value&gt;</a>
  (without an accompanying <a href="#media-condition">&lt;media-condition&gt;</a>)
  as the last entry in the <a href="#source-size-list">&lt;source-size-list&gt;</a>,
  the parsing algorithm technically allows such at any point in the list,
  and will accept it immediately as the size
  if the preceding entries in the list weren't used.
  This is to enable future extensions,
  and protect against simple author errors such as a final trailing comma.</p>

  <p>An <a href="#image-source">image source</a> can have a density descriptor,
  a width descriptor,
  or no descriptor at all accompanying its URL.
  Normalizing a <a href="#source-set">source set</a> gives every <a href="#image-source">image source</a> a density descriptor.</p>

  <p>When asked to <dfn id="normalize-the-source-densities">normalize the source densities</dfn> of a <a href="#source-set">source set</a> <var data-anolis-xref="">source set</var>,
  the user agent must do the following:</p>

  <ol><li><p>Let <var data-anolis-xref="">source size</var> be <var data-anolis-xref="">source set</var>'s <a href="#source-size-0">source size</a>.</li>

   <li>

    <p>For each <a href="#image-source">image source</a> in <var data-anolis-xref="">source set</var>:</p>

    <ol><li><p>If the <a href="#image-source">image source</a> has a density descriptor,
     continue to the next <a href="#image-source">image source</a>.</li>

     <li>

      <p>Otherwise, if the <a href="#image-source">image source</a> has a width descriptor,
      replace the width descriptor with a density descriptor
      with a value of the width descriptor divided by the <a href="#source-size-0">source size</a>
      and a unit of <code data-anolis-xref="">x</code>.</p>

      <p class="note">If the <a href="#source-size-0">source size</a> is zero,
      the density would be infinity,
      which results in the intrinsic dimensions being zero by zero.</p>

     </li>

     <li><p>Otherwise, give the <a href="#image-source">image source</a> a density descriptor of <code data-anolis-xref="">1x</code>.</li>

    </ol></li>

  </ol><p>The user agent may at any time run the following algorithm to update an <code><a href="#the-img-element">img</a></code>
  element's image in order to react to changes in the environment. (User agents are <em>not
  required</em> to ever run this algorithm; for example, if the user is not looking at the page any
  more, the user agent might want to wait until the user has returned to the page before determining
  which image to use, in case the environment changes again in the meantime.)</p>

  <ol><li><p>Asynchronously <a href="webappapis.html#await-a-stable-state">await a stable state</a>. The <a href="webappapis.html#synchronous-section">synchronous section</a>
   consists of all the remaining steps of this algorithm until the algorithm says the
   <a href="webappapis.html#synchronous-section">synchronous section</a> has ended. (Steps in <a data-anolis-xref="synchronous
   section" href="webappapis.html#synchronous-section">synchronous sections</a> are marked with ⌛.)</li>

   <li><p>⌛ If the <code><a href="#the-img-element">img</a></code> element does not have a <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code> attribute specified and it either has no parent
   or it is not a <code><a href="#the-picture-element">picture</a></code> element, is not in the <a data-anolis-xref="img-all" href="#img-all">completely available</a> state, has image data whose resource type is
   <code><a href="iana.html#multipart/x-mixed-replace">multipart/x-mixed-replace</a></code>, or if its <a href="#update-the-image-data">update the image data</a> algorithm is
   running, then abort this algorithm.</li><!-- we don't support replacing push-JPEG images
   because defining what happens with the tasks and events and so on in that case would become
   implausibly complicated. --> 

   <li><p>⌛ Let <var data-anolis-xref="">selected source</var> and <var data-anolis-xref="">selected pixel
   density</var> be the URL and pixel density that results from <a data-anolis-xref="select an image source" href="#select-an-image-source">selecting an image source</a>, respectively.</li>

   <li><p>⌛ If <var data-anolis-xref="">selected source</var> is null, then abort these steps.</li><!-- not sure this can ever actually happen -->
   

   <li><p>⌛ If <var data-anolis-xref="">selected source</var> and <var data-anolis-xref="">selected pixel
   density</var> are the same as the element's <a href="#last-selected-source">last selected source</a> and <a href="#current-pixel-density">current
   pixel density</a>, then abort these steps.</li><!-- note that this check happens before
   base URL resolution, so changing the base URL doesn't trigger an update if nothing else changed
   --> 

   <li><p>⌛ <a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">Resolve</a> <var data-anolis-xref="">selected source</var>,
   relative to the element.</li>

   <li><p>⌛ Let <var data-anolis-xref="">CORS mode</var> be the state of the element's <code data-anolis-xref="attr-img-crossorigin"><a href="#attr-img-crossorigin">crossorigin</a></code> content attribute.</li>

   <li><p>⌛ If the <a href="infrastructure.html#resolve-a-url">resolve a URL</a> algorithm is not successful, abort these
   steps.</p>

   </li><li><p>End the <a href="webappapis.html#synchronous-section">synchronous section</a>, continuing the remaining steps
   asynchronously.</li>

   <li>

    <p>Do a <a href="infrastructure.html#potentially-cors-enabled-fetch">potentially CORS-enabled fetch</a><!--FETCH-->  of the resulting <a href="infrastructure.html#absolute-url">absolute
    URL</a>, with the <i data-anolis-xref="">mode</i> being <var data-anolis-xref="">CORS mode</var>, the <i data-anolis-xref="">origin</i>
    being the <a href="browsers.html#origin-0">origin</a> of the <code><a href="#the-img-element">img</a></code> element's <code><a href="dom.html#document">Document</a></code>, and the
    <i data-anolis-xref="">default origin behaviour</i> set to <i data-anolis-xref="">taint</i>.</p>

    <p>If this download fails in any way (other than the response code not being a 2xx code, as
    mentioned earlier), or if the image format is unsupported (as determined by applying the <a data-anolis-xref="Content-Type sniffing: image" href="infrastructure.html#content-type-sniffing:-image">image sniffing rules</a>, again as mentioned earlier),
    or if the resource type is <code><a href="iana.html#multipart/x-mixed-replace">multipart/x-mixed-replace</a></code>, then abort these steps.</p>

    <p>Otherwise, wait for the <a href="infrastructure.html#fetch">fetch</a> algorithm to queue its last task, and then
    continue with these steps. The data obtained in this way is used in the steps below.</p>

   </li>

   <li>

    <p><a href="webappapis.html#queue-a-task">Queue a task</a> to run the following substeps:</p>

    <ol><li><p>If the <code><a href="#the-img-element">img</a></code> element has experienced <a href="#relevant-mutations">relevant mutations</a>
     since this algorithm started, then abort these steps.</p>

     </li><li><p>Let the <code><a href="#the-img-element">img</a></code> element's <a href="#last-selected-source">last selected source</a> be <var data-anolis-xref="">selected source</var> and the <code><a href="#the-img-element">img</a></code> element's <a href="#current-pixel-density">current pixel
     density</a> be <var data-anolis-xref="">selected pixel density</var>.</li>

     <li><p>Let the <code><a href="#the-img-element">img</a></code> element's <a href="#current-request">current request</a>'s
     <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a> be the resulting <a href="infrastructure.html#absolute-url">absolute URL</a> from the earlier step.</li>

     <li><p>Replace the <code><a href="#the-img-element">img</a></code> element's image data with the resource obtained by the
     earlier step of this algorithm. It can be either <a href="infrastructure.html#cors-same-origin">CORS-same-origin</a> or
     <a href="infrastructure.html#cors-cross-origin">CORS-cross-origin</a>; this affects the <a href="browsers.html#origin-0">origin</a> of the image itself (e.g.
     when used on a <code><a href="scripting-1.html#the-canvas-element">canvas</a></code>).</li>

     <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the
     <code><a href="#the-img-element">img</a></code> element.</li>

    </ol></li>

  </ol><hr><p>The <a href="webappapis.html#task-source">task source</a> for the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> <a data-anolis-xref="queue
  a task" href="webappapis.html#queue-a-task">queued</a> by algorithms in this section is the <a href="webappapis.html#dom-manipulation-task-source">DOM manipulation task
  source</a>.</p>

  <hr><p>What an <code><a href="#the-img-element">img</a></code> element represents depends on the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute and the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>
  attribute.</p>

  <dl class="switch"><dt>If the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute is set and the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute is set to the empty string</dt>

   <dd>

    <p>The image is either decorative or supplemental to the rest of the content, redundant with
    some other information in the document.</p>

    <p>If the image is <a data-anolis-xref="img-available" href="#img-available">available</a> and the user agent is configured
    to display that image, then the element <a href="dom.html#represents">represents</a> the element's image data.</p>

    <p>Otherwise, the element <a href="dom.html#represents">represents</a> nothing, and may be omitted completely from
    the rendering. User agents may provide the user with a notification that an image is present but
    has been omitted from the rendering.</p>

   </dd>

   <dt>If the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute is set and the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute is set to a value that isn't empty</dt>

   <dd>

    <p>The image is a key part of the content; the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute
    gives a textual equivalent or replacement for the image.</p>

    <p>If the image is <a data-anolis-xref="img-available" href="#img-available">available</a> and the user agent is configured
    to display that image, then the element <a href="dom.html#represents">represents</a> the element's image data.</p>

    <p>Otherwise, the element <a href="dom.html#represents">represents</a> the text given by the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute. User agents may provide the user with a notification
    that an image is present but has been omitted from the rendering.</p>

   </dd>

   <dt>If the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute is set and the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute is not</dt>

   <dd>

   <p>There is no textual equivalent of the image available.</p>

   <p>If the image is <a data-anolis-xref="img-available" href="#img-available">available</a> and the user agent is configured
   to display that image, then the element <a href="dom.html#represents">represents</a> the element's image data.</p>

   <p>Otherwise, the user agent should display some sort of indicator that there is an image that
   is not being rendered, and may, if requested by the user, or if so configured, or when required
   to provide contextual information in response to navigation, provide caption information for the
   image, derived as follows:</p>

   <ol><!-- when editing this list, search for the two other occurrences of 'critical-no-alt' --><li><p>If the image is a descendant of a <code><a href="grouping-content.html#the-figure-element">figure</a></code> element that has a child
    <code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code> element, and, ignoring the <code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code> element and its
    descendants, the <code><a href="grouping-content.html#the-figure-element">figure</a></code> element has no <code><a href="infrastructure.html#text-0">Text</a></code> node descendants other
    than <a href="dom.html#inter-element-whitespace">inter-element whitespace</a>, and no <a href="dom.html#embedded-content-category">embedded content</a> descendant
    other than the <code><a href="#the-img-element">img</a></code> element, then the contents of the first such
    <code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code> element are the caption information; abort these steps.</li>

    <li><p>There is no caption information.</li>

   </ol></dd>

   <dt>If the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute is not set and either the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute is set to the empty string or the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute is not set at all</dt>

   <dd>

    <p>The element <a href="dom.html#represents">represents</a> nothing.</p>

   </dd>

   <dt>そうでなければ</dt>

   <dd>

    <p>The element <a href="dom.html#represents">represents</a> the text given by the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute.</p>

   </dd>

  </dl><p>The <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute does not represent advisory information.
  User agents must not present the contents of the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute
  in the same way as content of the <code data-anolis-xref="attr-title"><a href="dom.html#attr-title">title</a></code> attribute.</p><!--POLITICS-->


  <p class="warning">While user agents are encouraged to repair cases of missing <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attributes, authors must not rely on such behavior. <a href="#alt">Requirements for providing text to act as an alternative for images</a> are described
  in detail below.</p>

  <p>The <em>contents</em> of <code><a href="#the-img-element">img</a></code> elements, if any, are ignored for the purposes of
  rendering.</p>

  </div>

  <hr><p><code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code>属性が存在する場合、画像が関連付けられた<a href="#image-map">イメージマップ</a>を示すことができる。</p>

  <p><code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code>属性を持つ<code><a href="text-level-semantics.html#the-a-element">a</a></code>要素の子孫である要素で使用される場合、<dfn data-anolis-xref="attr-img-ismap" id="attr-img-ismap"><code>ismap</code></dfn>属性は、要素がサーバーサイドのイメージマップへのアクセスを提供することによって、その存在を示す。これは、イベントが対応する<code><a href="text-level-semantics.html#the-a-element">a</a></code>要素でどのように処理されるかに影響する。</p>

  <p><code data-anolis-xref="attr-img-ismap"><a href="#attr-img-ismap">ismap</a></code>属性は<a href="infrastructure.html#boolean-attribute">真偽属性</a>である。属性は、<code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code>属性を持つ祖先<code><a href="text-level-semantics.html#the-a-element">a</a></code>要素を持たない要素に指定してはならない。</p>

  <p class="note"><code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code>および<code data-anolis-xref="attr-img-ismap"><a href="#attr-img-ismap">ismap</a></code>属性は、<code><a href="#the-picture-element">picture</a></code>要素で指定される<code data-anolis-xref="attr-picture-source-media"><a href="#attr-picture-source-media">media</a></code>属性をもつ<code data-anolis-xref="picture-source"><a href="#the-source-element-when-used-with-the-picture-element">source</a></code>要素と一緒に使用される場合に混乱する振る舞いをもたらすかもしれない。</p>

  <p><code><a href="#the-img-element">img</a></code>要素は、<a href="#dimension-attributes">寸法属性</a>をサポートする。</p>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-img-alt" id="dom-img-alt"><code>alt</code></dfn>, <dfn data-anolis-xref="dom-img-src" id="dom-img-src"><code>src</code></dfn>, <dfn data-anolis-xref="dom-img-srcset" id="dom-img-srcset"><code>srcset</code></dfn> and <dfn data-anolis-xref="dom-img-sizes" id="dom-img-sizes"><code>sizes</code></dfn> IDL attributes must <a href="infrastructure.html#reflect">reflect</a> the
  respective content attributes of the same name.</p>

  <p>The <dfn data-anolis-xref="dom-img-crossOrigin" id="dom-img-crossorigin"><code>crossOrigin</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-img-crossorigin"><a href="#attr-img-crossorigin">crossorigin</a></code> content attribute,
  <a href="infrastructure.html#limited-to-only-known-values">limited to only known values</a>.</p>

  <p>The <dfn data-anolis-xref="dom-img-useMap" id="dom-img-usemap"><code>useMap</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code> content attribute.</p>

  <p>The <dfn data-anolis-xref="dom-img-isMap" id="dom-img-ismap"><code>isMap</code></dfn> IDL attribute must <a href="infrastructure.html#reflect">reflect</a>
  the <code data-anolis-xref="attr-img-ismap"><a href="#attr-img-ismap">ismap</a></code> content attribute.</p>

  </div><!--TOPIC:DOM APIs-->


  <dl class="domintro"><dt><var data-anolis-xref="">image</var> . <code data-anolis-xref="dom-img-width"><a href="#dom-img-width">width</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dt><var data-anolis-xref="">image</var> . <code data-anolis-xref="dom-img-height"><a href="#dom-img-height">height</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd><!--CLEANUP-->


    <p>これらの属性は、実際のレンダリングされた画像の大きさ、または寸法が未知である場合に0を返す。</p>

    <p>対応するコンテンツ属性を変更するために、設定が可能である。</p>

   </dd>

   <dt><var data-anolis-xref="">image</var> . <code data-anolis-xref="dom-img-naturalWidth"><a href="#dom-img-naturalwidth">naturalWidth</a></code></dt>
   <dt><var data-anolis-xref="">image</var> . <code data-anolis-xref="dom-img-naturalHeight"><a href="#dom-img-naturalheight">naturalHeight</a></code></dt>

   <dd><!--CLEANUP-->


    <p>これらの属性は、画像の内在寸法、または寸法が未知の場合に0を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">image</var> . <code data-anolis-xref="dom-img-complete"><a href="#dom-img-complete">complete</a></code></dt>

   <dd><!--CLEANUP-->


    <p>画像が完全にダウンロードされている場合、または、何も画像が指定されない場合にtrueを返す。そうでなければ、falseを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">image</var> . <code data-anolis-xref="dom-img-currentSrc"><a href="#dom-img-currentsrc">currentSrc</a></code></dt>

   <dd>

    <p>画像の<a href="infrastructure.html#absolute-url">絶対URL</a>を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">image</var> = new <code data-anolis-xref="dom-image"><a href="#dom-image">Image</a></code>( [ <var data-anolis-xref="">width</var> [, <var data-anolis-xref="">height</var> ] ] )</dt>

   <dd><!--CLEANUP-->


    <p>該当する場合、適切な引数で渡された値に設定された<code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code>と<code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code>属性を持つ、新しい<code><a href="#the-img-element">img</a></code>要素を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The IDL attributes <dfn data-anolis-xref="dom-img-width" id="dom-img-width"><code>width</code></dfn> and <dfn data-anolis-xref="dom-img-height" id="dom-img-height"><code>height</code></dfn> must return the rendered width and height of the
  image, in CSS pixels, if the image is <a href="rendering.html#being-rendered">being rendered</a>, and is being rendered to a
  visual medium; or else the intrinsic width and height of the image, in CSS pixels, if the image is
  <i data-anolis-xref="img-available"><a href="#img-available">available</a></i> but not being rendered to a visual medium; or else 0, if
  the image is not <i data-anolis-xref="img-available"><a href="#img-available">available</a></i>. <a href="references.html#refsCSS">[CSS]</a></p>

  <p>On setting, they must act as if they <a data-anolis-xref="reflect" href="infrastructure.html#reflect">reflected</a> the respective
  content attributes of the same name.</p>

  <p>The IDL attributes <dfn data-anolis-xref="dom-img-naturalWidth" id="dom-img-naturalwidth"><code>naturalWidth</code></dfn> and <dfn data-anolis-xref="dom-img-naturalHeight" id="dom-img-naturalheight"><code>naturalHeight</code></dfn> must return the intrinsic width and
  height of the image, in CSS pixels, if the image is <i data-anolis-xref="img-available"><a href="#img-available">available</a></i>, or
  else 0. <a href="references.html#refsCSS">[CSS]</a></p>

  <p>The IDL attribute <dfn data-anolis-xref="dom-img-complete" id="dom-img-complete"><code>complete</code></dfn> must return true if
  any of the following conditions is true:</p>

  <ul class="brief"><!--XXXX check picture parent--><li>Both the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute and the <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code> attribute are omitted.

   

   </li><li>The <code data-anolis-xref="attr-img-srcset"><a href="#attr-img-srcset">srcset</a></code> attribute is omitted and the <code data-anolis-xref="attr-img-src"><a href="#attr-img-src">src</a></code> attribute's value is the empty string.  <!-- we only have this
   hack for src="", not srcset=""; present but empty or bogus srcset="" still means complete=false
   if it's not in the img-error state -->

   </li><li>The final <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a
   task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> once the resource has been <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> has been <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a>.

   

   </li><li>The <code><a href="#the-img-element">img</a></code> element is <a data-anolis-xref="img-all" href="#img-all">completely available</a>.

   

   </li><li>The <code><a href="#the-img-element">img</a></code> element is <a data-anolis-xref="img-error" href="#img-error">broken</a>.

  

  </li></ul><p>Otherwise, the attribute must return false.</p>

  <p class="note">The value of <code data-anolis-xref="dom-img-complete"><a href="#dom-img-complete">complete</a></code> can thus change while
  a <a data-anolis-xref="concept-script" href="webappapis.html#concept-script">script</a> is executing.</p>

  <p>The <dfn data-anolis-xref="dom-img-currentSrc" id="dom-img-currentsrc"><code>currentSrc</code></dfn> IDL attribute
  must return the <code><a href="#the-img-element">img</a></code> element's <a href="#current-request">current request</a>'s <a data-anolis-xref="img-req-url" href="#img-req-url">current URL</a>.</p>

  <p>A constructor is provided for creating <code><a href="#htmlimageelement">HTMLImageElement</a></code> objects (in addition to
  the factory methods from DOM such as <code data-anolis-xref="">createElement()</code>): <dfn data-anolis-xref="dom-image" id="dom-image"><code>Image(<var data-anolis-xref="">width</var>, <var data-anolis-xref="">height</var>)</code></dfn>.
  When invoked as a constructor, this must return a new <code><a href="#htmlimageelement">HTMLImageElement</a></code> object (a new
  <code><a href="#the-img-element">img</a></code> element). If the <var data-anolis-xref="">width</var> argument is present, the new object's
  <code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code> content attribute must be set to <var data-anolis-xref="">width</var>. If the <var data-anolis-xref="">height</var> argument is also present, the new object's
  <code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code> content attribute must be set to <var data-anolis-xref="">height</var>. The element's document must be the <a href="browsers.html#active-document">active document</a> of the
  <a href="browsers.html#browsing-context">browsing context</a> of the <code><a href="browsers.html#window">Window</a></code> object on which the interface object of
  the invoked constructor is found.</p>

  </div><!-- NOTE: hixies generic image examples removed from here as they are redundant/and or contradictory with the following section --><!--TOPIC:HTML--><!-- END OF PICTURE SECTION --><!-- base alt advice on acc requirements and best practice (note whole section rewritten) SF-->
  
  


  
  


  <h5 id="alt"><span class="secno">4.7.5.1</span> 画像に対して代替として動作するテキストを提供に対する要件</h5>

  <p><a href="http://www.w3.org/TR/WCAG20/#text-altdef">テキストによる代替</a> <a href="references.html#refsWCAG">[WCAG]</a>は、視覚情報をアクセシブルにするための最も重要な方法である。これによりユーザーのニーズに合うように、任意の感覚様式（たとえば、視覚、聴覚や触覚）を介してレンダリングできるのである。テキストによる代替を提供することは、情報をさまざまなユーザーエージェントによって様々な方法でレンダリングすることを可能にする。たとえば、画像を見ることができない人は、合成音声を使用してテキストによる代替を読み上げさせることができる。</p>
 
  <p class="note">画像の<code>alt</code>属性は非常に重要なアクセシビリティー属性である。有用な<code>alt</code>属性コンテンツを作成することは、画像が出現するコンテキストおよびそのコンテキストにおいて画像が持ってもよい機能を著者に注意深く考慮することを要求する。ここを含むガイダンスは、著者が画像を使用するもっとも一般的な方法を扱う。追加のガイダンスおよびテクニックは<a href="http://w3.org/WAI/alt/">Resources on Alternative Text for Images</a>で利用可能である。</p>

  <h6 id="examples-of-scenarios-where-users-benefit-from-text-alternatives-for-images"><span class="secno">4.7.5.1.1</span> ユーザーが画像のテキストによる代替の恩恵を受けるシナリオの例</h6>

  <ul><li>非常に低速な接続であり、画像を無効化して表示している。</li>
      <li>視覚障害を持ち、音声ソフトウェアでテキストを扱う。</li>
      <li>認知障害を持ち、音声ソフトウェアでテキストを扱う。</li>
      <li>テキストのみのブラウザを使用する。</li>
      <li>音声ブラウザによって読み出されているページを聞いている。</li>
      <li>ダウンロードのコストを節約するために画像を無効化する。</li>
      <li>画像を読み込む問題や画像のソースの誤りがある。</li>
    </ul><h6 id="general-guidelines"><span class="secno">4.7.5.1.2</span> 一般的なガイドライン</h6>

  <p>特に指定されている場合を除き、<code>alt</code>属性を指定しなければならず、その値が空であってはならない。値は画像に対して適切な置換でなければならない。<code>alt</code>属性に対する具体的な要件は、以下の節で説明するように、ページでの画像の機能に依存する。</p>
  
  <p>適切なテキストによる代替を判断するために、画像がページに含まれている理由を考えることが重要である。その目的は何か？このように考えることは、読者に意図する画像に関して何が重要かを理解するのに役立つ。すべての画像は、有用な情報を提供する、機能を実行する、インタラクティブな要素を分類する、美意識を高めるまたは純粋に装飾的といったページ上に存在する理由を持つ。したがって、画像が何のために存在するのかを理解することは、適切なテキストによる代替の記述を容易にする。</p>
  
  <h6 id="a-link-or-button-containing-nothing-but-an-image"><span class="secno">4.7.5.1.3</span> 画像のみを含むリンクまたはボタン</h6>

  <p><a href="links.html#hyperlink">ハイパーリンク</a>、または<code><a href="forms.html#the-button-element">button</a></code>要素をもつ<code><a href="text-level-semantics.html#the-a-element">a</a></code>要素が、テキストコンテンツがないが1つ以上の画像を含む場合、<code>alt</code>属性がリンクやボタンの目的を同時に伝えるテキストを含む。</p>
  
	<div class="example">

  <p>この例において、エディターインターフェースの一部が表示されている。各ボタンは、ユーザーが編集しているコンテンツに対して実行できるアクションを表すアイコンを持つ。画像を見ることができないユーザーのために、アクション名は画像の<code>alt</code>属性内に含まれる：</p>
  <p><img alt="5つのボタン：太字、斜体、打ち消し線、
箇条書きリストおよび番号付きリスト。" src="http://www.w3.org/html/wg/drafts/html/master/images/buttons1.png"></p>
        
  <pre>  &lt;ul&gt;
  &lt;li&gt;&lt;button&gt;&lt;img src="b.png" <strong>alt="Bold"</strong>&gt;&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button&gt;&lt;img src="i.png" <strong>alt="Italics"</strong>&gt;&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button&gt;&lt;img src="strike.png" <strong>alt="Strike through"</strong>&gt;&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button&gt;&lt;img src="blist.png" <strong>alt="Bulleted list"</strong>&gt;&lt;/button&gt;&lt;/li&gt;
  &lt;li&gt;&lt;button&gt;&lt;img src="nlist.png" <strong>alt="Numbered list"</strong>&gt;&lt;/button&gt;&lt;/li&gt;
  &lt;/ul&gt;
  </pre>
	</div>

  <div class="example">

  <p>この例では、a要素のリンクはロゴを含む。リンクは<strong>外部サイトから</strong>W3Cのウェブサイトを指す。テキストによる代替はリンク先の簡単な説明である。</p>
  <p><abbr title="World Wide Web Consortium"><img alt="W3C logo used as link content." height="48" src="http://www.w3.org/TR/html5/images/w3c_home.png" width="72"></abbr></p>

  <pre>  &lt;a href="http://w3.org"&gt;
  &lt;img src="images/w3c_home.png" width="72" height="48" <strong>alt="W3C web site"</strong>&gt;
  &lt;/a&gt;
  </pre>
  </div>
	  
	<div class="example">
  <p><strong>リンクがW3Cのウェブサイトにある</strong>ことを除いて、この例は前の例と同じである。テキストによる代替はリンク先の簡単な説明である。</p>
  <p><abbr title="World Wide Web Consortium"><img alt="W3C logo used as link content." height="48" src="http://www.w3.org/TR/html5/images/w3c_home.png" width="72"></abbr></p>

  <pre>  &lt;a href="http://w3.org"&gt;
  &lt;img src="images/w3c_home.png" width="72" height="48" <strong>alt="W3C home"</strong>&gt;
  &lt;/a&gt;
  </pre>
  <p class="note">ロゴの画像を使用するコンテキストに依存することは、画像がテキストによる代替の一部として、<em>ロゴ</em>であることの指示を提供するために適切だろう。<a href="#logos,-insignia,-flags,-or-emblems">4.7.1.1.19 ロゴ、記号、旗、またはエンブレム</a>の節を参照のこと。</p>
  </div>
  
  <div class="example">
  <p>この例において、a要素のリンクがプレビューアイコンを含む。リンクは印刷用スタイルシートを適用するページを指す。テキストによる代替はリンク先の簡単な説明である。</p>
  <p><img alt="Print preview icon used as link content." height="30" src="http://www.w3.org/TR/html5/images/preview.png" width="32"></p>

  <pre>  &lt;a href="preview.html"&gt;
  &lt;img src="images/preview.png" width="32" height="30" <strong>alt="Print preview."</strong>&gt;
  &lt;/a&gt;
  </pre>
  </div>

  <div class="example">
  <p>この例で、ボタンは検索アイコンを含んでいる。ボタンは検索フォームを送信する。テキストによる代替はボタンが何をするかの簡単な説明である。</p>
  <p><img alt="Search icon used as button content." height="29" src="http://www.w3.org/TR/html5/images/search.png" width="74"></p>

  <pre>  &lt;button&gt;
  &lt;img src="images/search.png" width="74" height="29" <strong>alt="Search"</strong>&gt;
  &lt;/button&gt;
  </pre>
  </div>

  <div class="example">
  <p>この例において、<i>PIP社</i>の会社のロゴは2つの画像に分割されており、1枚目は単語<i>PIP</i>を含み、2枚目は略語<i>CO</i>をもつ。画像は、<i>PIPCO</i>のホームページへのリンクに属する唯一のコンテンツである。この場合、リンク先の簡単な説明が提供される。単一の実体として画像はユーザーに提供されるので、最初の画像の<code>alt</code>属性におけるテキストによる代替は<i>PIP CO home</i>である。</p>

  <p><img alt="Image containing the text 'PIP'." height="64" src="http://www.w3.org/TR/html5/images/pip.gif" width="99"><img alt="Image containing the text 'CO'." height="64" src="http://www.w3.org/TR/html5/images/co.gif" width="103"></p>

  <pre>  &lt;a href="pipco-home.html"&gt;
  &lt;img src="pip.gif" <strong>alt="PIP CO home"</strong>&gt;&lt;img src="co.gif" <strong>alt=""</strong>&gt;
  &lt;/a&gt;
  </pre>
  </div>
 
  <h6 id="graphical-representations:-charts,-diagrams,-graphs,-maps,-illustrations"><span class="secno">4.7.5.1.4</span> グラフィカルな表現：チャート、図、グラフ、マップ、イラスト</h6>

  <p>たとえばフローチャート、図表、グラフ、または方角を示す地図などとして、グラフ形式でコンテンツが表示される際にユーザーは恩恵を受けるだろう。グラフ形式で提示されるコンテンツもテキスト形式で提供される場合、ユーザーもまた利益を得る。このユーザーは、画像を表示できない人たちを含む。（たとえば、非常に低速な接続である、またはテキストのみのブラウザを使用している、またはハンズフリー自動車音声ウェブブラウザによって読み出されるページを聞いている、あるいは、視覚障害を持ち、テキストを音声にレンダリングする支援技術使用しているため。）</p>

  <div class="example">
  <p>次の円グラフの画像例において、円グラフに表示されるデータを表す<code>alt</code>属性でテキストをもつ：</p>
  <p><img alt="Browser Share: Internet Explorer 25%, Firefox 40%, Chrome 25%, Safari 6% and Opera 4%." height="299" src="http://www.w3.org/TR/html5/images/browserShare.png" width="380"></p>

  <pre>  &lt;img src="piechart.gif" <strong>alt="Pie chart: Browser Share - Internet Explorer 25%, Firefox 40%, Chrome 25%, Safari 6% and Opera 4%."</strong>&gt;
  </pre>
  </div>

  <div class="example">
  <p>この場合、グラフィカルな形式で画像が前の段落を繰り返す。<code>alt</code>属性コンテンツは画像を分類する。</p>

  <pre> &lt;p&gt;According to a recent study Firefox has a 40% browser share, Internet Explorer has 25%, Chrome has 25%, Safari has 6% and Opera has 4%.&lt;/p&gt;
 &lt;p&gt;&lt;img src="piechart.gif" <strong>alt="Pie chart representing the data in the previous paragraph."</strong>&gt;&lt;/p&gt;</pre>
  <p>たとえば<code>src</code>属性値が間違っているため、画像が利用できない場合に、テキストによる代替が画像コンテンツの簡単な説明をユーザーに提供するのが見られる：</p>
  <p><img alt="Representation of the code snippet above." src="http://www.w3.org/TR/html5/images/brokenimg.png"></p>
  </div>
  
  <p class="note">テキストによる代替が長くなる場合において、1つ以上の文は、構造化マークアップを使用することの恩恵を受けるだろう、簡単な説明または<code>alt</code>属性を使用するラベル、および関連付けられた代替テキストを提供する。</p>
  
  <div class="example">
  <p>これは、<code>alt</code>属性に含まれる短いテキストによる代替をもフローチャート画像の例である。この場合、テキストによる代替は画像が唯一のリンク内容としてリンク先の説明となる。リンクは、フローチャートで表されるプロセスの、同じ文書の中で説明を指す。</p>
  
  <p><img alt="Flowchart: Dealing with a broken lamp." height="320" src="http://www.w3.org/TR/html5/images/flowchart.png" width="221"></p>

  <pre>  <strong>
  &lt;a href="#desc"&gt;</strong>&lt;img src="flowchart.gif" <strong>alt="Flowchart: Dealing with a broken lamp."</strong>&gt;<strong>&lt;/a&gt;</strong>

  ...

  ...

  &lt;div <strong>id="desc"</strong>&gt;
  &lt;h2&gt;Dealing with a broken lamp&lt;/h2&gt;
  <strong data-anolis-xref="">&lt;ol&gt;</strong>
  <strong data-anolis-xref="">&lt;li&gt;</strong>Check if it's plugged in, if not, plug it in.<strong>&lt;/li&gt;</strong>
  <strong data-anolis-xref="">&lt;li&gt;</strong>If it still doesn't work; check if the bulb is burned out. If it is, replace the bulb.<strong>&lt;/li&gt;</strong>
  <strong data-anolis-xref="">&lt;li&gt;</strong>If it still doesn't work; buy a new lamp.<strong>&lt;/li&gt;</strong>
  <strong data-anolis-xref="">&lt;/ol&gt;</strong>
  &lt;/div&gt;</pre>
  </div>  

  <div class="example">
  <p>この例では、グラフの画像が存在する。情報がデータ集合であるため、<code>alt</code>属性でプレーンテキストによる代替としてグラフに示される情報を提供することは不適切である。グラフ画像で表されるデータを使用するデータテーブルの形式で画像の下に、構造化されたテキストによる代替が代わりに提供される。</p>

  <p><img alt="Bar Chart showing average rainfall in millimetres by Country and Season." height="341" src="http://www.w3.org/TR/html5/images/table.gif" width="407"></p>
  <p class="note">各シーズンの最高および最低降雨の表示が表に含まれているため、グラフで容易に識別される傾向がデータテーブルにも利用できる。</p>
  
  <table border="1" style="width:28em"><caption>Average rainfall in millimetres  by country and season.</caption>
  <tr><td><th scope="col">United Kingdom</th><th scope="col">Japan</th><th scope="col">Australia</th></td></tr><tr><th scope="row">Spring<td>5.3 (highest)</td><td>2.4</td><td>2 (lowest)</td></th></tr><tr><th scope="row">Summer<td>4.5 (highest)</td><td>3.4</td><td>2 (lowest)</td></th></tr><tr><th scope="row">Autumn<td>3.5 (highest)</td><td>1.8</td><td>1.5 (lowest)</td></th></tr><tr><th scope="row">Winter<td>1.5 (highest)</td><td>1.2</td><td>1 (lowest)</td></th></tr></table><pre>  &lt;figure&gt;
  &lt;figcaption&gt;Rainfall Data&lt;/figcaption&gt;
  &lt;img src="rainchart.gif" <strong>alt="Bar chart: Average rainfall in millimetres by Country and Season."</strong>&gt;
  &lt;table&gt;
  &lt;caption&gt;Rainfall in millimetres by Country and Season.&lt;/caption&gt;
  &lt;tr&gt;&lt;td&gt;&lt;th scope="col"&gt;UK &lt;th scope="col"&gt;Japan&lt;th scope="col"&gt;Australia&lt;/tr&gt;
  &lt;tr&gt;&lt;th scope="row"&gt;Spring &lt;td&gt;5.5 (highest)&lt;td&gt;2.4 &lt;td&gt;2 (lowest)&lt;/tr&gt;
  &lt;tr&gt;&lt;th scope="row"&gt;Summer &lt;td&gt;4.5 (highest)&lt;td&gt;3.4&lt;td&gt;2 (lowest)&lt;/tr&gt;
  &lt;tr&gt;&lt;th scope="row"&gt;Autumn &lt;td&gt;3.5 (highest) &lt;td&gt;1.8 &lt;td&gt;1.5 (lowest)&lt;/tr&gt;
  &lt;tr&gt;&lt;th scope="row"&gt;Winter &lt;td&gt;1.5 (highest) &lt;td&gt;1.2 &lt;td&gt;1 lowest&lt;/tr&gt;
  &lt;/table&gt;
  &lt;/figure&gt;
  </pre>
  <p class="note"><code><a href="grouping-content.html#the-figure-element">figure</a></code>要素は、棒グラフ画像およびデータのテーブルをグループ化するために使用される。<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素は、グループ化されたコンテンツに対するキャプションを提供する。</p>
  
  </div>
  <p class="note">このセクションにおける例のいずれかに対して<code><a href="interactive-elements.html#the-details-element">details</a></code>および<code><a href="interactive-elements.html#the-summary-element">summary</a></code>要素は使用され、その結果画像に対する説明は要求に応じて表示のみされる：</p>
  
  <div class="example">
  <p><img alt="Details element in the closed state." src="http://www.w3.org/TR/html51/images/altdetails-collapsed.png"></p>
  <p><img alt="Details element in the open state with list content displayed." src="http://www.w3.org/TR/html51/images/altdetails-expanded.png"></p>
  <pre>  &lt;figure&gt;
  &lt;img src="flowchart.gif" alt="Flowchart: Dealing with a broken lamp."&gt;
  <strong title="">&lt;details&gt;</strong>
  <strong>&lt;summary&gt;Dealing with a broken lamp&lt;/summary&gt;</strong>
  &lt;ol&gt;
  lt;li&gt;Check if it's plugged in, if not, plug it in.&lt;/li&gt;
  &lt;li&gt;If it still doesn't work; check if the bulb is burned out. If it is, replace the bulb.&lt;/li&gt;
  &lt;li&gt;If it still doesn't work; buy a new lamp.&lt;/li&gt;
  &lt;/ol&gt;
  <strong data-anolis-xref="">&lt;/details&gt;</strong>
  &lt;/figure&gt;
  </pre>
  <p class="note">そのような時にサポートされるまで、<code><a href="interactive-elements.html#the-details-element">details</a></code>および<code><a href="interactive-elements.html#the-summary-element">summary</a></code>要素は、現在ブラウザであまりサポートされず、使用した場合に、機能を提供するためにスクリプトを使用する必要があるだろう。スクリプト化されたポリフィル、利用可能なスクリプト化されたカスタムコントロール、同様の機能を提供する人気のJavaScript UIウィジェットライブラリは多数存在する。</p>
  </div>
  <h6 id="images-of-text"><span class="secno">4.7.5.1.5</span> テキストの画像</h6>

  <p>時として画像はテキストのみを含み、そして画像の目的は、視覚効果とフォントの両方またはいずれか一方を利用するテキストを表示することにある。CSSを用いたスタイル付きテキストを使用することを<em>強く</em>推奨するが、これが不可能な場合、画像であるがままに<code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性で同じテキストを提供する。</p>

  <div class="example">
  <p>この例は、テキストの画像を"Get Happy!"と表示する。派手な色とりどりのフリーハンド風に書かれている。画像は見出しの内容を構成する。この例において、画像のテキストによる代替は"Get Happy!"とすべきである。</p>

   <p><img alt="Get Happy!" height="77" src="http://www.w3.org/TR/html5/images/text.png" width="275"></p>

  <pre>&lt;h1&gt;&lt;img src="gethappy.gif" <strong>alt="Get Happy!"</strong>&gt;&lt;/h1&gt;</pre>
  </div>

  <div class="example">
  <p>この例では、テキストからなる広告画像であり、フレーズ"The BIG sale"が3回繰り返され、回を重ねるごとにテキストはより小さくかつより暗くなり、最後の行は"...ends Friday"と読む。広告として、コンテキストにおける使用は、画像のテキストによる代替は一度だけテキスト"The BIG sale"を含むことが推奨される。視覚効果とテキストの繰り返しは、画像が表示できないユーザーにとって不要であり、混乱を招くかもしれない。</p>

  <p><img alt="The big sale ...ends Friday." height="190" src="http://www.w3.org/TR/html5/images/sale.png" width="400"></p>
  <pre>  &lt;p&gt;&lt;img src="sale.gif" <strong>alt="The BIG sale ...ends Friday."</strong>&gt;&lt;/p&gt;
  </pre>
  <p class="note">テキストの画像と一緒に写真または他のグラフィックも存在する状況において、情報がまた画像を表示できないユーザーにも使用できるように、画像を表示できるユーザーに意味を伝える画像の他の説明とともに、テキストによる代替に含まれている画像テキスト内の単語を保証する。</p>
  </div>
 <p>画像がUnicodeで表現できない文字を表すために別の方法で使用される場合、たとえば外字、異体字、または新規の通貨記号のような新しい文字において、テキストによる代替は、たとえば、文字の発音を与えるために表音のひらがなやカタカナを使用するなど、同じものを記述するより伝統的な方法であるべきである。</p>

  <div class="example">

   <p>1997年からのこの例において、中央の2つのバーとともに渦巻き状のEのように見える最新式の通貨記号のかわりに、画像を使用して表現される。代替テキストは、文字の発音を与える。</p>

<p>Only <img alt="euro " height="18" src="http://www.w3.org/TR/html5/images/euro.png" width="21">5.99!</p>

   <pre>&lt;p&gt;Only &lt;img src="euro.png" alt="euro "&gt;5.99!</pre>

  </div>

  <p>Unicode文字が同じ目的を果たすならば画像を使用すべきでない。たとえば装飾のためや、文字がUnicode文字集合にない（外字の場合のような）文字であるためなど、テキストが直接Unicodeを使用して表すことができない場合にのみ、画像が適切だろう。</p>

  <p class="note">デフォルトのシステムフォントが指定された文字をサポートしないため、著者が画像を使用するように誘惑される場合、ウェブフォントは画像よりも優れた解決策である。</p><!-- Fork - move example to correct section and add image example SF-->
  
  <div class="example">

   <p>装飾写本は、その文字の一部のグラフィックスを使用するかもしれない。このような状況でテキストによる代替は、単に画像が表す文字である。</p>
   <p><img alt="O" height="32" src="http://www.w3.org/TR/html5/images/fancyO.png" width="24">nce upon a time and a long long time ago...</p>
   <pre>&lt;p&gt;&lt;img src="initials/fancyO.png" <mark>alt="O"</mark>&gt;nce upon a time and a long long time ago...</pre> 
  </div>
  
  <h6 id="images-that-include-text"><span class="secno">4.7.5.1.6</span> テキストを含む画像</h6>

  <p>時として、画像はグラフおよび関連するテキストのようなグラフィックスを構成する。この場合、テキストによる代替に画像内のテキストを含めることを推奨する。</p>

  <div class="example">
  <p>円グラフと関連するテキストを含む画像を考えてみる。テキストの画像でなく、任意の関連するテキストを可能な限りテキストとして提供することを推奨する。これが不可能な場合、画像で伝えられる関連情報とともにテキストによる代替内のテキストを含む。</p>

  <p><img alt="Figure 1. Distribution of Articles by Journal 
  Category. Pie chart: Language=68%, Education=14% and Science=18%." height="279" id="piechart" src="http://www.w3.org/TR/html5/images/figure1.png" width="351"></p>
  <pre>  &lt;p&gt;&lt;img src="figure1.gif" <strong>alt="Figure 1. Distribution of Articles by Journal Category.
  Pie chart: Language=68%, Education=14% and Science=18%."</strong>&gt;&lt;/p&gt;
  </pre>
  </div>

  <div class="example">
  <p>同じ<a href="#piechart">円グラフ</a>の画像のもう1つの例では、<code>alt</code>属性と長い代替テキストに含まれる短いテキストによる代替を表示する。<code><a href="grouping-content.html#the-figure-element">figure</a></code>および<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素は、画像とより長いテキストによる代替を関連付けるために使用される。<code>alt</code>属性は、画像にラベル付けするために使用される。</p>

  <pre>  &lt;figure&gt;
  &lt;img src="figure1.gif" <strong>alt="Figure 1"</strong>&gt;
  &lt;figcaption&gt;&lt;strong&gt;Figure 1.&lt;/strong&gt; Distribution of Articles by Journal Category.
  Pie chart: Language=68%, Education=14% and Science=18%.&lt;/figcaption&gt;
  &lt;/figure&gt;
  </pre>
  <p class="note">前の例と比べたこの方法の利点は、テキストによる代替が常にすべてのユーザーに利用可能であることにある。また、テキストによる代替が<code>alt</code>属性を使用して提供されない場所で、テキストによる代替で使用されるために構造化されたマークアップを許可する。</p>
  </div>

  <h6 id="images-that-enhance-the-themes-or-subject-matter-of-the-page-content"><span class="secno">4.7.5.1.7</span>テーマを向上させる画像やページ内容の主題</h6>

  <p>周囲のテキストで直接議論されないが、依然として一部の関連性を持つ画像は<code><a href="#the-img-element">img</a></code>要素を使用して、ページに含めることが可能である。このような画像は単なる装飾以上のものであり、テーマやページ内容の主題を補強するので、内容の一部を相変わらず形成することがある。この場合、テキストによる代替を提供することを推奨する。 </p>

  <div class="example">
  <p>これはページ内容の主題に密接に関連するが、直接説明されない画像の一例である。その詩の暗唱ページで、詩に触発された絵の画像である。次の断片は例を示す。画像は、"Lady of Shallot"（シャロットの貴婦人）と題した絵画であり、絵は詩に触発され、絵の主題は詩から派生している。したがって、テキストによる代替が提供されることを強く推奨する。<code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性に画像の内容の短い説明があり、文の下に長い説明へのリンクがある。長い説明の最後に絵についての詳しい情報へのリンクもある。</p>
  <p><img alt="アルフレッド・テニスンの詩シャロットの貴婦人に触発された絵" height="234" src="http://www.w3.org/TR/html5/images/shalott.jpg" width="338"></p>
  <pre>  &lt;header&gt;
  &lt;h1&gt;The Lady of Shalott&lt;/h1&gt;
  &lt;p&gt;A poem by Alfred Lord Tennyson&lt;/p&gt;
  &lt;/header&gt;

  &lt;img src="shalott.jpeg" <strong>alt="Painting of a  young woman with long hair, sitting in a wooden boat. "</strong>&gt;
  &lt;p&gt;&lt;a href="#des"&gt;Description of the painting&lt;/a&gt;.&lt;/p&gt;


  &lt;!-- Full Recitation of Alfred, Lord Tennyson's Poem.  --&gt;

  ...
  ...
  ...
  &lt;p id="des"&gt;<strong>The woman in the painting is wearing a flowing white dress. A large piece of intricately 
  patterned fabric is draped over the side. In her right hand she holds the chain mooring the boat. Her expression 
  is mournful. She stares at a crucifix lying in front of her. Beside it are three candles. Two have blown out.</strong> 
  <strong>&lt;a href="http://bit.ly/5HJvVZ"&gt;Further information about the painting&lt;/a&gt;.</strong>&lt;/p&gt;
  </pre>
  </div>
  <div class="example">
  <p>この例は、ページの主題の写真として画像を識別するテキストによる代替の提供を説明する。</p>
  <img alt="Portrait photo(black and white) of Robin, accompanied by a heading 'Robin Berjon' and a question
  'what more needs to be said?'" height="138" src="http://www.w3.org/TR/html5/images/robin.png" width="354"><pre>  &lt;img src="orateur_robin_berjon.png" <strong>alt="Portrait photo(black and white) of Robin."</strong>&gt;
  &lt;h1&gt;Robin Berjon&lt;/h1&gt;
  &lt;p&gt;What more needs to be said?&lt;/p&gt;
  </pre>
</div>

  <h6 id="a-graphical-representation-of-some-of-the-surrounding-text"><span class="secno">4.7.5.1.8</span> 周囲のテキストの一部をグラフィカルに表現</h6>

  <p>多くの場合、画像は実際には単なる補足であり、その存在は単に周囲のテキストを強調するだけである。この場合、<code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性が存在しなければならないが、その値は空文字列でなければならない。</p>

  <p>一般に画像は、画像を削除してもページの有用性が弱まるわけでない場合にこのカテゴリに分類されるが、画像を含めることは、視覚ブラウザのユーザーにとって概念を理解することがはるかに容易になる。</p>


  <div class="example">
  <p>画像の有用なテキストによる代替を記述することは必ずしも容易ではない。別のオプションは、画像についての詳しい情報へのリンクを提供することである。 </p>
  <p>同じ画像のこの例では、<code>alt</code>属性に含まれる短いテキストによる代替があり、画像の後にリンクがある。リンクは<a href="http://www.tate.org.uk/servlet/ViewWork?cgroupid=-1&amp;workid=15984">絵に関する情報</a>を含むページを指す。 </p>

  <p><strong>The Lady of Shalott</strong><br><small>A poem by Alfred Lord Tennyson.</small></p>
  <p><img alt="小さなボートに座る、白い流れるようなドレスの女性の絵。" height="171" src="http://www.w3.org/TR/html5/images/shalott.jpg" width="271"></p>
  <p><a href="http://bit.ly/5HJvVZ">About this painting.</a></p>
  <p><em>Full recitation of Alfred, Lord Tennyson's poem.</em></p>
  <pre>  &lt;header&gt;&lt;h1&gt;The Lady of Shalott&lt;/h1&gt;
  &lt;p&gt;A poem by Alfred Lord Tennyson&lt;/p&gt;&lt;/header&gt;
  &lt;figure&gt;
  &lt;img src="shalott.jpeg" <strong>alt="Painting of a woman in a white flowing dress, sitting in a small boat."</strong>&gt;
  &lt;p&gt;&lt;a href="http://bit.ly/5HJvVZ"&gt;<strong>About this painting.</strong>&lt;/a&gt;&lt;/p&gt;
  &lt;/figure&gt;
  &lt;!-- Full Recitation of Alfred, Lord Tennyson's Poem.  --&gt;
  </pre>
  </div>

  <h6 id="a-purely-decorative-image-that-doesn't-add-any-information"><span class="secno">4.7.5.1.9</span> 情報を追加しない、純粋に装飾的な画像</h6>

  <p>純粋に装飾的な画像は、視覚的な機能強化や装飾、画像を表示できるユーザーへの美意識を超えた機能や情報を提供しない装飾である。</p>

  <p>空の<code>alt</code>属性（<code>alt=""</code>）を使用することによって支援技術が無視できるように、純粋に装飾的な画像をマークアップする。装飾的な画像をインラインで含むことが受け入れられないことはないが、CSSを使用した画像を含むために純粋に装飾的であることが推奨される。</p>

  <div class="example">
  <p>ある人のブログの装飾バナーとして使用される画像の例では、画像は何も情報を提供しないので、空の<code>alt</code>属性を持つべきである。</p>
  
  <div>
  <p><img alt="" height="30" src="http://www.w3.org/TR/html5/images/border.png" width="400"></p>
  <p><strong>Clara's Blog</strong></p>
  <p>Welcome to my blog...</p>
  </div>
  <pre>  &lt;header&gt;
  &lt;div&gt;&lt;img src="border.gif" <strong>alt=""</strong> width="400" height="30"&gt;&lt;/div&gt;
  &lt;h1&gt;Clara's Blog&lt;/h1&gt;
  &lt;/header&gt;
  &lt;p&gt;Welcome to my blog...&lt;/p&gt;
  </pre>
  </div>

  <h6 id="inline"><span class="secno">4.7.5.1.10</span> インライン画像</h6>

  <p>画像が文書でテキストの流れの一部としてインラインで使用される場合、離れている文書の文脈で理にかなったテキストによる代替として単語またはフレーズを提供する。</p>

  <div class="example">
  <p>I <img alt="love" height="24" src="http://www.w3.org/TR/html5/images/heart.png" width="27"> you.</p>

  <pre>I &lt;img src="heart.png" <strong>alt="love"</strong>&gt; you.</pre>

  <p>My <img alt="heart" height="24" src="http://www.w3.org/TR/html5/images/heart.png" width="27"> breaks.</p>

  <pre>My &lt;img src="heart.png" <strong>alt="heart"</strong>&gt; breaks.</pre>
  </div>    

  <h6 id="a-group-of-images-that-form-a-single-larger-picture-with-no-links"><span class="secno">4.7.5.1.11</span> リンクのない単一の大きな画像を形成する画像のグループ</h6>

  <p>画像が小さな画像ファイルに分割されている場合、再度完全な画像を形成するために一緒に表示され、全体として画像に関連するガイダンスに従って<code>alt</code>属性を使用する画像のいずれかに対するテキストによる代替を含み、そして他の画像で空の<code>alt</code>属性を含む。</p>

  <div class="example">
  <p>この例において、<i>PIP社</i>の会社のロゴを表す絵が2枚に分割されており、1枚目は文字"PIP"を含み、2枚目は単語"CO"を持つ。代替テキスト<i>PIP CO</i>は最初の画像の<code>alt</code>属性にある。</p>

  <p><img alt="Image containing the text 'PIP'." height="64" src="http://www.w3.org/TR/html5/images/pip.gif" width="99"><img alt="Image containing the text 'CO'." height="64" src="http://www.w3.org/TR/html5/images/co.gif" width="103"></p>

  <pre>  &lt;img src="pip.gif" <strong>alt="PIP CO"</strong>&gt;&lt;img src="co.gif" <strong>alt=""</strong>&gt;
  </pre>
  </div>

  <div class="example">
  <p>次の例において、評価は、3つの塗りつぶされた星と、2つの中抜きの星として示される。テキストによる代替は"★★★☆☆"かもしれないが、代わりに著者は、より親切な形式"3 out of 5"の評価を与えるようにした。これは最初の画像のテキストによる代替であり、残りは空の<code>alt</code>属性を持つ。</p>
  <p><img alt="3 out of 5." height="30" src="http://www.w3.org/TR/html5/images/rating.png" width="149"></p>

  <pre>  &lt;p&gt;Rating: &lt;meter max=5 value=3&gt;
  &lt;img src="1" <strong>alt="3 out of 5"</strong>&gt;
  &lt;img src="1" <strong>alt=""</strong>&gt;&lt;img src="1" <strong>alt=""</strong>&gt;
  &lt;img src="0" <strong>alt=""</strong>&gt;&lt;img src="0" <strong>alt=""</strong>&gt;
  &lt;/meter&gt;&lt;/p&gt;
  </pre>

  </div>
 
  <h6 id="image-maps-0"><span class="secno">4.7.5.1.12</span> イメージマップ</h6>
  <code><a href="#the-img-element">img</a></code>要素が、<code>href</code>属性を持つ<code><a href="#the-area-element">area</a></code>要素を含む<code><a href="#the-map-element">map</a></code>要素を参照する<code>usemap</code>属性を持つ場合、<code><a href="#the-img-element">img</a></code>はインタラクティブコンテンツであると見なされる。このような場合、<code>alt</code>属性を使用して画像のテキストによる代替を常に提供する。<p></p>
<div class="example">

   <p><a href="http://en.wikipedia.org/wiki/Katoomba,_New_South_Wales">カトゥーンバ</a>の地図である以下の画像を考える。地図が南北カトゥーンバの領域に対応する2つのインタラクティブ領域を持つ。</p>
   
   <p><img alt="Map of Katoomba." height="249" src="http://www.w3.org/TR/html5/images/imagemap.png" usemap="#Map" width="209"></p>
<map name="Map"><area alt="North Katoomba" coords="78,124,124,10,189,29,173,93,168,132,136,151,110,130" href="#" shape="poly"><area alt="South Katoomba" coords="66,63,80,135,106,138,137,154,167,137,175,133,144,240,49,223,17,137,17,61" href="#" shape="poly"></map><p>テキストによる代替は、画像の簡単な説明である。各<code><a href="#the-area-element">area</a></code>要素の<code>alt</code>属性は、それぞれリンクされた地域のターゲットページのコンテンツを説明するテキストを提供する。</p>

 <pre>&lt;p&gt;View houses for sale in North Katoomba or South Katoomba:&lt;/p&gt;
 &lt;p&gt;&lt;img src="imagemap.png" width="209" <mark>alt="Map of Katoomba"</mark> height="249" usemap="#Map"&gt;

 &lt;map name="Map"&gt; 
 &lt;area shape="poly" coords="78,124,124,10,189,29,173,93,168,132,136,151,110,130" 
 href="north.html" <mark>alt="Houses in North Katoomba"</mark>&gt;
 &lt;area shape="poly" coords="66,63,80,135,106,138,137,154,167,137,175,133,144,240,49,223,17,137,17,61" 
 <mark>alt="Houses in South Katoomba"</mark> href="south.html"&gt;
 &lt;/map&gt; </pre>

  </div>

  <h6 id="a-group-of-images-that-form-a-single-larger-picture-with-links"><span class="secno">4.7.5.1.13</span> リンクのある単一の大きな画像を形成する画像のグループ</h6>

  <p class="note">一般に<a data-anolis-xref="image map" href="#image-map">イメージマップ</a>は、リンク用の画像をスライスする代わりに使用されるべきである。</p>

  <p>複数画像から合成写真を作成する場合、画像の1つ以上をリンクしたいと思うかもしれない。リンクの目的を説明するために、各リンクされた画像に対して<code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性を提供する。
  </p>

  <div class="example">
  <p>次の例において、合成写真は"Crocoduck"を示すために使用される。これは、ワニの一部とアヒルの一部によって進化の原則を無視する架空の生き物である。Crocoduckと交流するように求めているが、用心する必要がある。</p>

  <p><img alt="crocodile's angry, chomping head" src="http://www.w3.org/TR/html5/images/crocoduck1.png"><img alt="duck's soft, feathery body" src="http://www.w3.org/TR/html5/images/crocoduck2.png"></p>
  <pre>  &lt;h1&gt;The crocoduck&lt;/h1&gt;
  &lt;p&gt;You encounter a strange creature called a "crocoduck".
  The creature seems angry!Perhaps some friendly stroking will help to calm
  it, but be careful not to stroke any crocodile parts. This would just enrage
  the beast further.&lt;/p&gt;
  &lt;a href="?stroke=head"&gt;&lt;img src="crocoduck1.png" <strong>alt="Stroke crocodile's angry, chomping head"</strong>&gt;&lt;/a&gt;
  &lt;a href="?stroke=body"&gt;&lt;img src="crocoduck2.png" <strong>alt="Stroke duck's soft, feathery body"</strong>&gt;&lt;/a&gt;  
  </pre>

  </div>
  
  <h6 id="images-of-pictures"><span class="secno">4.7.5.1.14</span> 写真の画像</h6>

  <p>写真やグラフィックス画像は、視覚オブジェクトの表現、人、風景、抽象化などが含まれる。この<a href="http://www.w3.org/TR/WCAG20/#non-text-contentdef">非テキストコンテンツ</a> <a href="references.html#refsWCAG">[WCAG]</a> は、視覚的に大量の情報を伝えるか、晴眼者に<a href="http://www.w3.org/TR/WCAG20/#sensoryexpdef">特定の感覚的な体験</a> <a href="references.html#refsWCAG">[WCAG]</a>を提供できる。例としては、写真、絵画、図面やアートワークが含まれる。</p>
  
  <p>画像に対する適切なテキストによる代替は、簡単な説明または<a href="http://www.w3.org/TR/WCAG20/#namedef">識別名</a>である<a href="references.html#refsWCAG">[WCAG]</a>。すべてのテキストによる代替のオーサリング判定のように、画像に対して適切なテキストによる代替を書くことは人間の判断を必要とする。テキスト値は、画像が使用されるコンテキストとページ作者の文体の主観的なものである。したがって、特定の画像に対する<code>alt</code>テキストの'正しい'ものはない。非テキストコンテンツの簡単な説明を与える短いテキストによる代替の提供に加えて、適切な有用である場合にも別のものを介して補足的コンテンツの提供を意味する。</p>
  
  <div class="example">
  <p>この例は、写真共有サイトにアップロードした画像を示す。写真は風呂に座っている猫である。画像は、<code><a href="#the-img-element">img</a></code>要素の<code>alt</code>属性を用いて提供されるテキストによる代替を持つ。また、<code><a href="grouping-content.html#the-figure-element">figure</a></code>要素およびキャプションテキストを識別するための<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素を使用したもので<code><a href="#the-img-element">img</a></code>要素を含むことで、キャプションを提供する。</p>
  
  <p><img alt="ローラ猫はお風呂の浴槽に傘の下で座っている。" height="242" src="http://www.w3.org/TR/html5/images/lola.png" width="300"></p>
  <p>Lola prefers a bath to a shower.</p>
   
  <pre>  &lt;figure&gt;
  &lt;img src="664aef.jpg" <strong>alt="Lola the cat sitting under an umbrella in the bath tub."</strong>&gt;
  &lt;figcaption&gt;Lola prefers a bath to a shower.&lt;/figcaption&gt;
  &lt;/figure&gt;
  </pre>
  </div>
   
  <div class="example">
  <p>画像の主題が解釈が自由であるため、この例は完全な記述を受け付けない画像である。画像を表示できないユーザーにどのような画像であるかを提供する<code>alt</code>属性でテキストによる代替を画像は持つ。画像はまた、<code><a href="grouping-content.html#the-figure-element">figure</a></code>要素において<code><a href="#the-img-element">img</a></code>要素を含む、およびキャプションテキストを識別するために<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素を使用することによって、提供されるキャプションも持つ。</p>
  
  <p><img alt="An abstract, freeform, vertically symmetrical, black inkblot on a light background." height="197" src="http://www.w3.org/TR/html5/images/inkblot1.png" width="300"></p>
  <p>The first of the ten cards in the Rorschach test.</p>
   
  <pre>&lt;figure&gt;
  &lt;img src="Rorschach1.jpg" <strong>alt="An abstract, freeform, vertically symmetrical, black inkblot on a light background."</strong>&gt;
  &lt;figcaption&gt;The first of the ten cards in the Rorschach test.&lt;/figcaption&gt;
  &lt;/figure&gt; </pre>
  </div>
   
  <h6 id="webcam-images"><span class="secno">4.7.5.1.15</span> ウェブカメラ画像</h6>

  <p>ウェブカメラの画像は、自動で定期的に更新される静的な画像である。一般に画像は固定された場所からのものであり、それぞれ新しい画像がカメラからアップロードされるか、またはユーザーが更新された画像を表示ためにページを再読み込みする必要があるので、画像は自動的にページ上で更新してもよい。例としては、交通および天気カメラなどがある。</p>

  <div class="example">
  <p>この例はかなり典型的である。タイトルとタイムスタンプは画像に含まれ、自動的にウェブカメラのソフトウェアによって生成される。テキスト情報が画像に含まれていなかった場合により良いが、テキスト情報は画像の一部であるので、テキストによる代替の一部としてテキスト情報を含む。キャプションはまた、<code><a href="grouping-content.html#the-figure-element">figure</a></code>および<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素を使って提供される。画像は建物近くの現在の天気について視覚情報を伝えるために提供されるが、ウェブカメラの画像が自動的に生成されてアップロードされるので、地元の天気予報が提供されるリンクが、テキストによる代替としてそのような情報を提供することは実用的でないだろう。</p>

  <p><code>alt</code>属性のテキストは、音声ソフトウェアへのテキストによって知らせる場合にテキストをよりわかりやすくするために設計された、タイムスタンプの単調なバージョンを含む。気象条件と日時が変化するにもかかわらず、テキストによる代替はまた、変化しない画像で見られることの一部の側面の記述を含む。</p>

  <p><img alt="ソッピース家の気象カメラ。Taken on the 21/04/10 at 11:51 and 34 seconds. In the foreground are the safety
  rails on the flat part of the roof. 近くに低層の工業用建物があり、向こうに平らなブロックがある。In the distance there's a
  church steeple." height="225" src="http://www.w3.org/TR/html5/images/webcam1.png" width="296"></p>

  <p>View from the top of Sopwith house, looking towards North Kingston. This image is updated every hour.</p>

  <p>View the <a href="http://news.bbc.co.uk/weather/forecast/4296?area=Kingston">latest weather details</a> for Kingston upon Thames.</p>
   
  <pre>&lt;figure&gt;
  &lt;img src="webcam1.jpg" <strong>alt="Sopwith house weather cam. Taken on the 21/04/10 at 11:51 and 34 seconds.
  In the foreground are the safety rails on the flat part of the roof. Nearby there are low rise industrial buildings,
  beyond are blocks of flats. In the distance there's a church steeple."</strong>&gt;
  &lt;figcaption&gt;View from Sopwith house, looking towards north Kingston. This image is updated every hour.&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;p&gt;View the &lt;a href="http://news.bbc.co.uk/weather/forecast/4296?area=Kingston"&gt;latest weather details&lt;/a&gt; for Kingston upon Thames.&lt;/p&gt;
  </pre>
  </div>

  <h6 id="when-a-text-alternative-is-not-available-at-the-time-of-publication"><span class="secno">4.7.5.1.16</span> 公開時にテキストによる代替が利用不能である場合</h6>

  <p>一部のケースにおいて、画像は公開された文書に含まれるが、著者が適切なテキストによる代替を提供することができない。このような場合における最小要件は、以下の条件のもとで<code><a href="grouping-content.html#the-figure-element">figure</a></code>および<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素を用いて画像のキャプションを提供することである。</p>

  <ul id="figcaption-as-alt-condition"><li><code><a href="grouping-content.html#the-figure-element">figure</a></code>要素内の<code><a href="#the-img-element">img</a></code>要素
  </li><li><code><a href="grouping-content.html#the-figure-element">figure</a></code>要素は<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素を含む
  </li><li><code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素は、要素内空白文字以外のコンテンツを含む
  </li><li><code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素とその子孫を無視し、<code><a href="grouping-content.html#the-figure-element">figure</a></code>要素は、要素内空白文字以外の<code><a href="infrastructure.html#text-0">Text</a></code>ノードの子孫を持たず、かつ<code><a href="#the-img-element">img</a></code>要素以外のエンベディッドコンテンツの子孫を持たない。
  </li></ul><p class="note">言い換えれば、<code><a href="grouping-content.html#the-figure-element">figure</a></code>の最良のコンテンツは、<code><a href="#the-img-element">img</a></code>要素と<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素であり、かつ<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素は（キャプション）コンテンツを含まなければならない。</p>
  <p class="note">そのような場合は最小限に保たれるべきである。実際の代替テキストを提供する能力を有する著者のわずかな可能性がある場合、<code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性の省略を許容しないだろう。</p>
  
  <div class="example">
  <p>この例において、写真共有サイトに多数の画像のようなバルクアップロードの一部として、ある人が写真をアップロードする。ユーザーは、テキストによる代替または画像のキャプションを提供していない。サイトのオーサリングツールは、画像に対して持っている有用な情報を使ってキャプションを自動的に挿入する。この場合において、それはファイル名および、写真が撮影された日付である。</p> 
  <p class="warning">下記例のキャプションテキストは適切なテキストによる代替でなく、ウェブアクセシビリティーガイドライン2.0に準拠していない。<a href="references.html#refsWCAG">[WCAG]</a></p>
  <p><img alt="no text alternative provided" height="258" src="http://www.w3.org/TR/html5/images/clara.png" width="300"></p>
  <p><strong>clara.jpg, taken on 12/11/2010.</strong></p>

  <pre>  &lt;figure&gt;
  &lt;img src="clara.jpg"&gt;
  &lt;figcaption&gt;<strong>clara.jpg, taken on 12/11/2010.</strong>&lt;/figcaption&gt;
  &lt;/figure&gt;
  </pre>
  <p>この例ですら、できる限り多くの有用な情報が依然として<code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code>要素に含まれることに注意する。</p>
  </div>

  <div class="example">
  <p>次の2番目の例において、ある人が写真共有サイトに写真をアップロードする。彼女は、テキストによる代替でなく、画像のキャプションを提供している。サイトは<code>alt</code>属性でテキストによる代替を追加する機能をユーザーに提供していないため、この可能性がある。</p> 
  
  <p><img alt="no text alternative provided" height="250" src="http://www.w3.org/TR/html5/images/elo.png" width="205"></p>
  <p><strong>Eloisa with Princess Belle</strong></p>

  <pre>  &lt;figure&gt;
  &lt;img src="elo.jpg"&gt;
  &lt;figcaption&gt;<strong>Eloisa with Princess Belle</strong>&lt;/figcaption&gt;
  &lt;/figure&gt;
  </pre>

  </div>

  <div class="example">
  <p>時として画像全体の要点は、テキストの説明が利用できず、ユーザーが説明を提供する。もう一つの例は、画像を表示し、正しい代替テキストをもつページを書く目的に対して正確に代替テキストを求めるソフトウェアだろう。そのようなページは次のように、画像のテーブルを持つことができる：</p>

  <pre>&lt;table&gt;
  &lt;tr&gt;&lt;tr&gt; &lt;th&gt; Image &lt;th&gt; Description&lt;tr&gt;
  &lt;td&gt;
  &lt;figure&gt;
  &lt;img src="2421.png"&gt;
  &lt;figcaption&gt;Image 640 by 100, filename 'banner.gif'&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;td&gt; &lt;input name="alt2421"&gt;
  &lt;tr&gt;
  &lt;td&gt; &lt;figure&gt;
  &lt;img src="2422.png"&gt;
  &lt;figcaption&gt;Image 200 by 480, filename 'ad3.gif'&lt;/figcaption&gt;
  &lt;/figure&gt;
  &lt;td&gt; &lt;input name="alt2422"&gt;
  &lt;/table&gt;</pre>

  </div>

  <p class="note">（たとえば目が見えないため、など）一部のユーザーは一切画像を使用することができないので、<code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性は、上記の例のように、全くテキストによる代替が利用できず、誰も利用できない際に省略することが許可される。</p>
  
  <h6 id="an-image-not-intended-for-the-user"><span class="secno">4.7.5.1.17</span> ユーザーを意図しない画像</h6>

  <p class="auth">一般に、著者は画像を表示する以外の目的で<code><a href="#the-img-element">img</a></code>要素を使用することは避けるべきである。</p>

  <p>たとえばページビューをカウントするサービスの一部として用いるなど、画像を表示する以外の目的で<code><a href="#the-img-element">img</a></code>要素を使用する場合、空の<code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code>属性を使用する。</p>

  <div class="example">
  <p>ウェブページの統計情報を収集するために使用される<code><a href="#the-img-element">img</a></code>要素の例を示す。画像に意味がないので<code>alt</code>属性は空である。</p>
 
  <pre>  &lt;img src="http://server3.stats.com/count.pl?NeonMeatDream.com" width="0" height="0" <strong>alt=""</strong>&gt;
  </pre>
  </div>
  
  <p class="note">上記例のように0に設定する<code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code>および<code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code>属性を使用するよう推奨される。</p>
  
  <div class="example">
  <p>もう1つの用例は、<i>spacer.gif</i>のような画像がコンテンツの位置決めを補助するために使用される場合である。画像に意味がないので<code>alt</code>属性は空である。</p>
   
  <pre>  &lt;img src="spacer.gif" width="10" height="10" <strong>alt=""</strong>&gt;
  </pre>
  </div>

  <p class="note"><code><a href="#the-img-element">img</a></code>要素の代わりにCSSコンテンツを配置して使用することを推奨する。</p>
  
  <h6 id="icon-images"><span class="secno">4.7.5.1.18</span> アイコン画像</h6>

  <p>アイコンは通常、プログラム、アクション、データファイルや概念を表す単純な絵である。アイコンは、視覚ブラウザのユーザーに一目で機能を認識するのを助けることを意図する。</p>

  <p>アイコンが同じ意味を伝えるテキストを補足する際に空の<code x-data="attr-img-alt">alt</code>属性を使用する。</p>

 <div class="example">
 <p>この例では、サイトのホームページを指すリンクは、家のアイコン画像とテキスト"home"を含む。画像は、空の<code>alt</code>テキストを持つ。画像がこの方法で使用される場合、CSSを使用して画像を追加することが適切でもあるだろう。</p>
        
  <p><img alt="A house icon next to the word 'home'." height="38" src="http://www.w3.org/TR/html5/images/home.png" width="100"></p>
       
  <pre>  &lt;a href="home.html"&gt;&lt;img src="home.gif" width="15" height="15" <strong>alt=""</strong>&gt;Home&lt;/a&gt;
  </pre>

  <pre>  #home:before
  { 
  content: url(home.png);
  }

  &lt;a href="home.html" id="home"&gt;Home&lt;/a&gt;
  </pre>
 </div>

 <div class="example">
 <p>この例では、警告アイコンを伴う警告メッセージを表示している。単語"Warning!"はアイコンの次の強調テキストである。アイコンによって伝えられる情報が冗長であるため、<code><a href="#the-img-element">img</a></code>要素は空の<code>alt</code>属性が与えられる。</p>

 <p><img alt="Warning!" height="34" src="http://www.w3.org/TR/html5/images/warning.png" width="38"><strong>Warning!</strong> Your session is about to expire.</p>

  <pre>  &lt;p&gt;&lt;img src="warning.png" width="15" height="15" <strong>alt=""</strong>&gt;
  &lt;strong&gt;Warning!&lt;/strong&gt; 
  Your session is about to expire&lt;/p&gt;
  </pre>
 </div>

 <p>アイコンがテキストで使用できない追加情報を伝える場合、テキストによる代替を提供する。</p>
 
 <div class="example">
 <p>この例では、警告アイコンを伴う警告メッセージを表示している。アイコンはメッセージの重要性を強調し、特定の内容型として識別する。</p>
 <p><img alt="Warning!" height="34" src="http://www.w3.org/TR/html5/images/warning.png" width="38"><strong>Your session is about to expire.</strong></p>

  <pre>  &lt;p&gt;&lt;img src="warning.png" width="15" height="15" <strong>alt="Warning!"</strong>&gt;
  Your session is about to expire&lt;/p&gt;
  </pre>

 </div>

  <h6 id="logos,-insignia,-flags,-or-emblems"><span class="secno">4.7.5.1.19</span> ロゴ、 記号、旗、またはエンブレム</h6>
  <p>多くのページは、会社、組織、プロジェクト、バンド、ソフトウェアパッケージ、国、またはその他団体を表すロゴ、記号、旗、またはエンブレムを含む。適切なテキストによる代替として考えることができるものは、すべての画像のように、使用されている画像におけるコンテキスト、与えられたコンテキストで役立つ機能に依存する。</p>
  
  <p>ロゴがリンクの唯一のコンテンツである場合、<code>alt</code>属性でリンク先の簡単な説明を提供する。</p>
  <div class="example">
  <p>この例は、HTML仕様へリンクの唯一のコンテンツとして、HTML5ロゴの使用方法を示す。</p>
  <p><a href="http://www.w3.org/html/wg/drafts/html/master/">
  <img alt="HTML 5.1 Nightly specification" height="128" src="http://www.w3.org/TR/html5/images/HTML5_Logo.png" width="128"></a></p>
  <pre>  &lt;a href="http://dev.w3.org/html5/spec/spec.html"&gt;
  &lt;img src="HTML5_Logo.png" <strong>alt="HTML 5.1 specification"</strong>&gt;&lt;/a&gt;
  </pre>
  </div>
  <p>たとえばページの見出しのように、ロゴが団体を表すために使用されている場合、テキストによる代替としてはロゴによって表されるその団体の名前を提供する。</p>
  <div class="example">
  <p>この例は、自身を表現するために使用されているWebPlatform.orgロゴの使用を示す。</p>
  <p><img alt="WebPlatform.org" height="100" src="http://www.w3.org/TR/html5/images/logo-with-text.png" width="110">  and other developer resources</p>
  
  <pre>  &lt;h2&gt;&lt;img src="images/webplatform.png" <strong>alt="WebPlatform.org"</strong>&gt; and other developer resources&lt;h2&gt;
  </pre>
  <p class="note">上記の例におけるテキストによる代替はまた、画像コンテンツのタイプを説明するために単語"logo"を含むかもしれない。そのような場合、この情報を表現するために角括弧を用いることが提案される：<code>alt="[logo] WebPlatform.org"</code>.</p> 
  </div>
  <p>ロゴが表すものの名前の横にロゴが使用される場合、そのロゴは補足である。テキストによる代替がすでに提供されているように空の<code>alt</code>属性を含める。</p>
  
  <div class="example">
  <p>この例は、ロゴが表す組織名の横にロゴマークの使用を示す。</p>
  <p><img alt="" height="68" src="http://www.w3.org/TR/html5/images/webplatform.png" width="72">  WebPlatform.org</p>
  <pre>  &lt;img src="images/webplatform1.png" <strong>alt=""</strong>&gt; WebPlatform.org
  </pre>
  
  </div>
  <p>ロゴが表す主題または団体を説明するテキストと同時にロゴが使用される場合、ロゴを説明するテキストによる代替を提供する。</p>

  <div class="example">
  <p>この例は、ロゴが表す主題を説明するテキストの横にロゴの使用方法を示す。</p>
  <p style="float:left;"><img alt="HTML5 logo: Shaped like a shield with the 
  text 'HTML' above and the numeral '5' prominent on the face of the shield." height="128" src="http://www.w3.org/TR/html5/images/HTML5_Logo.png" width="128"></p>
  <p style="width:30em;"><strong>HTML5</strong> is a language for structuring and presenting content for the World 
    Wide Web, a core technology of the Internet. It is the latest revision of the HTML standard 
   (originally created in 1990 and most recently standardized as HTML4 in 1997) and currently remains 
   under development. Its core aims have been to improve the language with support for the latest 
   multimedia while keeping it easily readable by humans and consistently understood by computers and 
   devices (web browsers, parsers etc.).  </p>
  <pre style="clear:both">  &lt;p&gt;&lt;img src="HTML5_Logo.png" <strong>alt="HTML5 logo: Shaped like a shield with the
  text 'HTML' above and the numeral '5' prominent on the face of the shield."</strong>&gt;&lt;/p&gt;
  
  <i>Information about HTML5</i></pre>
  </div>
  
  <h6 id="captcha-images"><span class="secno">4.7.5.1.20</span> CAPTCHA画像</h6>
  <p>CAPTCHA（キャプチャ）は、"Completely Automated Public Turing test to tell Computers and Humans Apart"（コンピュータと人間を区別する完全に自動化された公開チューリングテスト）の略である。CAPTCHA 画像は、コンテンツがコンピュータではなく人間によってアクセスされていることを確認する、セキュリティー目的のために使用される。この認証は、画像の視覚的な検証を介して行われる。CAPTCHAは一般的に、文字や単語をもつ画像を提示し、ユーザーがそれを入力する。画像は通常、歪められており、文字を読解困難にするために適用されるノイズを持つ。</p>
  
  <p>CAPTCHAのアクセシビリティーを改良することは画像の目的を識別して説明するテキストによる代替を提供し、知覚のさまざまな種類の出力モードを使用するCAPTCHAの代替形式を提供する。たとえば、視覚的な画像とともに音声代替手段を提供する。視覚的な画像のすぐ隣に音声のオプションを設置する。これは役立つが、それでもサウンドカードのない人、視聴覚障害者、一部の制限された聴力をもつ人に対して問題である。もう一つの方法は、視覚的な画像とともに質問フォームを含めることである。これは役立つが、認知障害を持つ人々に対して問題となるかもしれない。</p>
  <p class="note">すべてのCAPTCHAの方式は、障害をもつユーザーに対する入力への容認できない障壁を導入するため、CAPTCHAの代替品を使用することを強く推奨する。更なる情報は、W3Cの<a href="http://www.w3.org/TR/turingtest/">Inaccessibility of CAPTCHA</a>で利用可能である。 </p>
  <div class="example">
  <p>この例では、文字の歪んだ画像を使用するCAPTCHAのテストを示す。<code>alt</code>属性でのテキストによる代替は、画像コンテンツにアクセスできない場合にユーザーに対する手順を説明する。 </p>
  <p><img alt="captcha containing the words 'aides' and 'sprucest'. The letters are distorted and the color of the letters and background is partially inverted," height="60" src="http://www.w3.org/TR/html5/images/captcha.png" width="270"></p>
  <p><strong>コード例:</strong></p>
  <pre>&lt;img src="captcha.png" <strong>alt="If you cannot view this image an audio challenge is provided."</strong>&gt; 
  &lt;!-- audio CAPTCHA option that allows the user to listen and type the word --&gt;  
  &lt;!-- form that asks a question --&gt;
  </pre>
  </div>
  
  <h6 id="an-image-in-a-picture-element"><span class="secno">4.7.5.1.21</span> <code><a href="#the-picture-element">picture</a></code>要素における画像</h6>
  <p><code><a href="#the-picture-element">picture</a></code>要素および任意の<code><a href="#the-source-element">source</a></code>要素はユーザーに対してセマンティックを持たず、<code><a href="#the-img-element">img</a></code>要素または要素のテキストによる代替のみがユーザーに表示される。<code><a href="#the-picture-element">picture</a></code>要素内で存在するテキストによる代替を考慮せずに<code><a href="#the-img-element">img</a></code>要素に対するテキストによる代替を提供する。画像に対して有用な<code>alt</code>テキストを提供する方法に関するより詳しい情報については、<a href="#alt">画像に対して代替として動作するテキストを提供に対する要件</a>を参照のこと。</p>
  <p class="note"><code><a href="#the-picture-element">picture</a></code>に依存する<a href="#art-direction">Art directed</a>画像は、（サイズ、ピクセル密度、または任意の他の判別する要素に関係なく）同じコンテンツを描写する必要がある。したがって、画像に対する適切なテキストによる代替は、ソースファイルが最後にブラウザによって選択されるものにかかわらず常に同じになるだろう。</p>

   <div class="example">

<pre>&lt;h2&gt;Is it a ghost?&lt;/h2&gt;
&lt;picture&gt;
  &lt;source <strong>media="(min-width: 32em)"</strong> srcset="large.jpg"&gt;
  &lt;img src="small.jpg" alt="Reflection of a girls face in a train window."&gt;
&lt;/picture&gt;</pre>
<p>画像の大きなおよび小さなバージョン（両方のバージョンがデモンストレーションの目的で表示される）は、同じシーンを記述する：（より小さいスクリーンで表示される）小さなバージョンは切り取られる間、車窓で女性の顔を反射する、これは目的または<code>alt</code>テキストの適切さに影響しない。</p> 
<p><img alt="Reflection of a girls face in a train window." height="315" src="http://www.w3.org/TR/html51/images/face_large.png" width="300"> <img alt="Reflection of a girls face in a train window." height="237" src="http://www.w3.org/TR/html51/images/face_small.png" width="228"></p>
</div><!-- alt advice SF-->
  


  <div class="impl">

  <h6 id="guidance-for-markup-generators"><span class="secno">4.7.5.1.22 </span>Guidance for markup generators</h6>

  <p>Markup generators (such as WYSIWYG authoring tools) should,
  wherever possible, obtain a text alternative from their
  users. However, it is recognized that in many cases, this will not
  be possible.</p>

  <p>For images that are the sole contents of links, markup generators
  should examine the link target to determine the title of the target,
  or the URL of the target, and use information obtained in this
  manner as the text alternative.</p><!-- WHATWG recommend use of @title this is bad for usability and accessibility -->

  
  <p>For images that have captions, markup generators should use the
  <code><a href="grouping-content.html#the-figure-element">figure</a></code> and <code><a href="grouping-content.html#the-figcaption-element">figcaption</a></code> elements to provide the
  image's caption.</p>
    <p>As a last resort, implementors should either set the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute to the empty string, under
  the assumption that the image is a purely decorative image that
  doesn't add any information but is still specific to the surrounding
  content, or omit the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute
  altogether, under the assumption that the image is a key part of the
  content.</p>

  <p>Markup generators may specify a <dfn data-anolis-xref="attr-img-generator-unable-to-provide-required-alt" id="attr-img-generator-unable-to-provide-required-alt"><code>generator-unable-to-provide-required-alt</code></dfn>
  attribute on <code><a href="#the-img-element">img</a></code> elements for which they have been
  unable to obtain a text alternative and for which they have therefore
  omitted the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute. The
  value of this attribute must be the empty string. Documents
  containing such attributes are not conforming, but conformance
  checkers will <a href="#guidance-for-conformance-checkers">silently
  ignore</a> this error.</p>

  <p class="note">This is intended to avoid markup generators from
  being pressured into replacing the error of omitting the <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute with the even more
  egregious error of providing phony text alternatives, because
  state-of-the-art automated conformance checkers cannot distinguish
  phony text alternatives from correct text alternatives.</p>

  <p>Markup generators should generally avoid using the image's own
  file name as the text alternative. Similarly, markup generators
  should avoid generating text alternatives from any content that will
  be equally available to presentation user agents (e.g. Web
  browsers).</p>

  <p class="note">This is because once a page is generated, it will
  typically not be updated, whereas the browsers that later read the
  page can be updated by the user, therefore the browser is likely to
  have more up-to-date and finely-tuned heuristics than the markup
  generator did when generating the page.</p>

  </div>

  <div class="impl">

  <h6 id="guidance-for-conformance-checkers"><span class="secno">4.7.5.1.23 </span>Guidance for conformance checkers</h6>

  <p>A conformance checker must report the lack of an <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute as an error unless one of
  the conditions listed below applies:</p>

  <ul><!-- when editing this list, search for the two other occurrences
   of 'critical-no-alt' --><li><p>The <code><a href="#the-img-element">img</a></code> element is in a <code><a href="grouping-content.html#the-figure-element">figure</a></code>
   element that satisfies <a href="#figcaption-as-alt-condition">the
   conditions described above</a>.</li><!--TITLE--><!-- the following are additional entries not included in the
   aforementioned list, as they apply only to conformance checkers -->



   


   <li><p>The <code><a href="#the-img-element">img</a></code> element has a (non-conforming) <code data-anolis-xref="attr-img-generator-unable-to-provide-required-alt"><a href="#attr-img-generator-unable-to-provide-required-alt">generator-unable-to-provide-required-alt</a></code>
   attribute whose value is the empty string. A conformance checker
   that is not reporting the lack of an <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute as an error must also not
   report the presence of the empty <code data-anolis-xref="attr-img-generator-unable-to-provide-required-alt"><a href="#attr-img-generator-unable-to-provide-required-alt">generator-unable-to-provide-required-alt</a></code>
   attribute as an error. (This case does not represent a case where
   the document is conforming, only that the generator could not
   determine appropriate alternative text — validators are not
   required to show an error in this case, because such an error might
   encourage markup generators to include bogus alternative text
   purely in an attempt to silence validators. Naturally, conformance
   checkers <em>may</em> report the lack of an <code data-anolis-xref="attr-img-alt"><a href="#attr-img-alt">alt</a></code> attribute as an error even in the
   presence of the <code data-anolis-xref="attr-img-generator-unable-to-provide-required-alt"><a href="#attr-img-generator-unable-to-provide-required-alt">generator-unable-to-provide-required-alt</a></code>
   attribute; for example, there could be a user option to report
   <em>all</em> conformance errors even those that might be the more
   or less inevitable result of using a markup generator.)</li>

  </ul></div>

  <h4 id="the-iframe-element"><span class="secno">4.7.6</span> <dfn><code>iframe</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>。</dd>
   <dd><a href="dom.html#interactive-content-0">インタラクティブコンテンツ</a>。</dd>
   <dd><a href="dom.html#palpable-content-0">パルパブルコンテンツ</a>。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>が期待される場所。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd><a href="#iframe-content-model">文で与えられる要件</a>に適合しているテキスト。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code> - <code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">iframe</a></code>内で描画する文書</dd>
   <dd><code data-anolis-xref="attr-iframe-name"><a href="#attr-iframe-name">name</a></code> - <a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>名</dd>
   <dd><code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code> - ネストされたコンテンツのセキュリティールール</dd>
   <dd><code data-anolis-xref="attr-iframe-seamless"><a href="#attr-iframe-seamless">seamless</a></code> - 文書のスタイルをネストされたコンテンツに適用するかどうか</dd>
   <dd><code data-anolis-xref="attr-iframe-allowfullscreen"><a href="#attr-iframe-allowfullscreen">allowfullscreen</a></code> - <code><a href="#the-iframe-element">iframe</a></code>のコンテンツに<code data-anolis-xref="dom-element-requestFullscreen"><a href="infrastructure.html#dom-element-requestfullscreen">requestFullscreen()</a></code>の使用を許可するかどうか</dd>
   <dd><code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code> - 横の次元</dd>
   <dd><code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code> - 縦の次元</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd>どちらのタグも省略不可</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd><a href="dom.html#index-aria-application"><code title="">application</code></a>、<a href="dom.html#index-aria-document"><code title="">document</code></a>、<a href="dom.html#index-aria-img"><code title="">img</code></a>または<a href="dom.html#index-aria-presentation"><code title="">presentation</code></a>。</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dd><a href="dom.html#allowed-aria-roles,-states-and-properties">許可されるロールで受け入れ可能な</a>任意の<code title="">aria-*</code>属性。</dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmliframeelement">HTMLIFrameElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-iframe-src" href="#dom-iframe-src">src</a>;
           attribute DOMString <a data-anolis-xref="dom-iframe-srcdoc" href="#dom-iframe-srcdoc">srcdoc</a>;
           attribute DOMString <a data-anolis-xref="dom-iframe-name" href="#dom-iframe-name">name</a>;
  [PutForwards=<span data-anolis-xref="dom-DOMSettableTokenList-value">value</span>] readonly attribute <a href="infrastructure.html#domsettabletokenlist">DOMSettableTokenList</a> <a data-anolis-xref="dom-iframe-sandbox" href="#dom-iframe-sandbox">sandbox</a>;
           attribute boolean <a data-anolis-xref="dom-iframe-seamless" href="#dom-iframe-seamless">seamless</a>;
           attribute boolean <a data-anolis-xref="dom-iframe-allowFullscreen" href="#dom-iframe-allowfullscreen">allowFullscreen</a>;
           attribute DOMString <a data-anolis-xref="dom-dim-width" href="#dom-dim-width">width</a>;
           attribute DOMString <a data-anolis-xref="dom-dim-height" href="#dom-dim-height">height</a>;
  readonly attribute <a href="dom.html#document">Document</a>? <a data-anolis-xref="dom-iframe-contentDocument" href="#dom-iframe-contentdocument">contentDocument</a>;
  readonly attribute <a href="browsers.html#windowproxy">WindowProxy</a>? <a data-anolis-xref="dom-iframe-contentWindow" href="#dom-iframe-contentwindow">contentWindow</a>;
};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><!-- INTRO --><p><code><a href="#the-iframe-element">iframe</a></code>要素は、<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>を<a href="dom.html#represents">表す</a>。</p><!-- SRC/SRCDOC -->


  

  <p><dfn data-anolis-xref="attr-iframe-src" id="attr-iframe-src"><code>src</code></dfn>属性は、<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>が含むのに適当なページのアドレスを与える。属性が存在する場合、<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>でなければならない。<code data-anolis-xref="attr-itemprop">itemprop</code>が<code><a href="#the-iframe-element">iframe</a></code>要素で指定される場合、<code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code>も指定されなければならない。</p>

  <p><dfn data-anolis-xref="attr-iframe-srcdoc" id="attr-iframe-srcdoc"><code>srcdoc</code></dfn>属性は、<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>が含むのに適当なページのコンテンツを提供する。属性の値は、<dfn id="an-iframe-srcdoc-document"><code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code>文書</dfn>のソースである。</p>

  <p>属性が存在する場合、<a href="infrastructure.html#html-documents">HTML文書</a>内の<code><a href="#the-iframe-element">iframe</a></code>要素は、指定された順序で、<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>が存在するならば、次の構文上のコンポーネントを構成する<a href="syntax.html#syntax">HTML構文</a>を使用した値を持たなければならない。</p>

  <ol><li>任意の数の<a data-anolis-xref="syntax-comments" href="syntax.html#syntax-comments">コメント</a>および<a data-anolis-xref="space
   character" href="infrastructure.html#space-character">空白文字</a>。</li>

   <li>任意で、<a data-anolis-xref="syntax-doctype" href="syntax.html#syntax-doctype">DOCTYPE</a>。

   </li><li>任意の数の<a data-anolis-xref="syntax-comments" href="syntax.html#syntax-comments">コメント</a>および<a data-anolis-xref="space
   character" href="infrastructure.html#space-character">空白文字</a>。</li>

   <li><code><a href="semantics.html#the-html-element">html</a></code><a data-anolis-xref="syntax-elements" href="syntax.html#syntax-elements">要素</a>の形式で、ルート要素。</li>

   <li>任意の数の<a data-anolis-xref="syntax-comments" href="syntax.html#syntax-comments">コメント</a>および<a data-anolis-xref="space
   character" href="infrastructure.html#space-character">空白文字</a>。</li>

  </ol><p><a href="infrastructure.html#xml-documents">XML文書</a>内の<code><a href="#the-iframe-element">iframe</a></code>要素のために、<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性が存在する場合、XML仕様でラベル付き<code data-anolis-xref="">document</code>生成物に一致する値を持たなければならない。<a href="references.html#refsXML">[XML]</a></p>

  <div class="example">

   <p>ここでブログは、ブログの記事のコメントで、スクリプトインジェクションから追加の保護レイヤーとともに、この機能をサポートするユーザーエージェントのユーザーに提供するため、以下に記載の<code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>および<code data-anolis-xref="attr-iframe-seamless"><a href="#attr-iframe-seamless">seamless</a></code>属性と一緒に<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性を使用する。</p>

   <pre>&lt;article&gt;
 &lt;h1&gt;I got my own magazine!&lt;/h1&gt;
 &lt;p&gt;After much effort, I've finally found a publisher, and so now I
 have my own magazine!Isn't that awesome?!The first issue will come
 out in September, and we have articles about getting food, and about
 getting in boxes, it's going to be great!&lt;/p&gt;
 &lt;footer&gt;
  &lt;p&gt;Written by &lt;a href="/users/cap"&gt;cap&lt;/a&gt;, 1 hour ago.
 &lt;/footer&gt;
 &lt;article&gt;
  &lt;footer&gt; Thirteen minutes ago, &lt;a href="/users/ch"&gt;ch&lt;/a&gt; wrote: &lt;/footer&gt;
  &lt;iframe seamless sandbox srcdoc="&lt;p&gt;did you get a cover picture yet?"&gt;&lt;/iframe&gt;
 &lt;/article&gt;
 &lt;article&gt;
  &lt;footer&gt; Nine minutes ago, &lt;a href="/users/cap"&gt;cap&lt;/a&gt; wrote: &lt;/footer&gt;
  &lt;iframe seamless sandbox srcdoc="&lt;p&gt;Yeah, you can see it &lt;a href=&amp;quot;/gallery?mode=cover&amp;amp;amp;page=1&amp;quot;&gt;in my gallery&lt;/a&gt;."&gt;&lt;/iframe&gt;
 &lt;/article&gt;
 &lt;article&gt;
  &lt;footer&gt; Five minutes ago, &lt;a href="/users/ch"&gt;ch&lt;/a&gt; wrote: &lt;/footer&gt;
  &lt;iframe seamless sandbox srcdoc="&lt;p&gt;hey that's earl's table.
&lt;p&gt;you should get earl&amp;amp;amp;me on the next cover."&gt;&lt;/iframe&gt;
 &lt;/article&gt;</pre>

   <p>引用符をエスケープする必要がある方法に注意し（そうでなければ<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性が途中で終わるだろう）、サンドボックス化されたコンテンツに記載される生のアンパサンド（たとえば、URL内または文で）が<em>二重に</em>エスケープされる必要がある―最初に<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性を解析する際、一度アンパサンドが保持されるように、サンドボックスのコンテンツを解析する際、誤ってもう一度アンパサンドを解析されるの防ぐために。</p>

   <p>さらに、<a data-anolis-xref="syntax-doctype" href="syntax.html#syntax-doctype">DOCTYPE</a>は<a data-anolis-xref="an iframe srcdoc document" href="#an-iframe-srcdoc-document"><code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code>文書</a>で任意であり、かつ<code><a href="semantics.html#the-html-element">html</a></code>、<code><a href="document-metadata.html#the-head-element">head</a></code>、および<code><a href="sections.html#the-body-element">body</a></code>要素は<a data-anolis-xref="syntax-tag-omission" href="syntax.html#syntax-tag-omission">任意の開始タグ</a>を持ち、しかも<code><a href="document-metadata.html#the-title-element">title</a></code>要素は<a data-anolis-xref="an iframe
   srcdoc document" href="#an-iframe-srcdoc-document"><code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code>文書</a>でも任意であるため、<code><a href="sections.html#the-body-element">body</a></code>要素のコンテンツだけが構文でリテラルに出現する必要があるため、<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性でのマークアップは、文書全体を表すにもかかわらず比較的簡潔にできる。他の要素は依然として存在するが、暗に存在するのみである。</p>

  </div>

  <p class="note"><a href="syntax.html#syntax">HTML構文</a>において、著者は属性の内容を包むために"""（U+0022）文字を使用することを単に覚えておく必要があり、それからすべて"""（U+0022）およびU+0026 AMPERSAND（&amp;）文字をエスケープし、および<code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>属性を指定し、コンテンツの安全な埋め込みを確実にする必要がある。</p>

  <p class="note"><a href="the-xhtml-syntax.html#the-xhtml-syntax">XHTML構文</a>の制約のために、XMLの"&lt;"（U+003C）文字も同様にエスケープする必要がある。<a href="http://www.w3.org/TR/xml/#AVNormalize">属性値正規化</a>を防ぐために、一部のXMLの空白文字―具体的には"tab"（U+0009）、"LF"（U+000D）、"CR"（U+000A）―もまたエスケープする必要がある。<a href="references.html#refsXML">[XML]</a></p>

  <p class="note"><code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code>属性と<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性が両方ともに指定される場合、<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性が優先される。これは、著者に<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性をサポートしないレガシーユーザーエージェントに対してフォールバック<a href="infrastructure.html#url">URL</a>を提供できる。</p>


  <div class="impl">

  <hr><!-- SRC/SRCDOC PROCESSING MODEL --><p>When an <code><a href="#the-iframe-element">iframe</a></code> element is <a data-anolis-xref="insert an element into a document" href="infrastructure.html#insert-an-element-into-a-document">inserted
  into a document</a>, the user agent must create a <a href="browsers.html#nested-browsing-context">nested browsing context</a>, and
  then <a href="#process-the-iframe-attributes">process the <code>iframe</code> attributes</a> for the "first time".</p>

  <p>When an <code><a href="#the-iframe-element">iframe</a></code> element is <a data-anolis-xref="remove an element from a document" href="infrastructure.html#remove-an-element-from-a-document">removed
  from a document</a>, the user agent must <a data-anolis-xref="a browsing context is
  discarded" href="browsers.html#a-browsing-context-is-discarded">discard</a> the <a href="browsers.html#nested-browsing-context">nested browsing context</a>.</p>

  <p class="note">This happens without any <code data-anolis-xref="event-unload"><a href="index.html#event-unload">unload</a></code> events firing
  (the <a href="browsers.html#nested-browsing-context">nested browsing context</a> and its <code><a href="dom.html#document">Document</a></code> are <em data-anolis-xref="a browsing
  context is discarded"><a href="browsers.html#a-browsing-context-is-discarded">discarded</a></em>, not <em data-anolis-xref="unload a document"><a href="browsers.html#unload-a-document">unloaded</a></em>).</p><!-- START of section that's very similar to <frame> -->

  

  <p>Whenever an <code><a href="#the-iframe-element">iframe</a></code> element with a <a href="browsers.html#nested-browsing-context">nested browsing context</a> has its
  <code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code> attribute set, changed, or removed, the user agent
  must <a href="#process-the-iframe-attributes">process the <code>iframe</code> attributes</a>.</p>

  <p>Similarly, whenever an <code><a href="#the-iframe-element">iframe</a></code> element with a <a href="browsers.html#nested-browsing-context">nested browsing context</a>
  but with no <code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code> attribute specified has its <code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code> attribute set, changed, or removed, the user agent must
  <a href="#process-the-iframe-attributes">process the <code>iframe</code> attributes</a>.</p><!-- It doesn't happen when the base
  URL is changed, though. --> 

  <p>When the user agent is to <dfn id="process-the-iframe-attributes">process the <code>iframe</code> attributes</dfn>, it must run
  the first appropriate steps from the following list:</p>

  <dl class="switch"><dt>If the <code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code> attribute is specified</dt>

   <dd><p><a href="browsers.html#navigate">Navigate</a><!--DONAV iframe-->  the element's <a href="browsers.html#child-browsing-context">child browsing context</a>
   to a resource whose <a href="infrastructure.html#content-type">Content-Type</a> is <code><a href="iana.html#text/html">text/html</a></code>, whose <a href="infrastructure.html#url">URL</a>
   is <code><a href="infrastructure.html#about:srcdoc">about:srcdoc</a></code>, and whose data consists of the value of the attribute. The
   resulting <code><a href="dom.html#document">Document</a></code> must be considered <a href="#an-iframe-srcdoc-document">an <code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code> document</a>.</dd>

   <dt>Otherwise, if the element has no <code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code> attribute
   specified, and the user agent is processing the <code><a href="#the-iframe-element">iframe</a></code>'s attributes for the "first
   time"</dt>

   <dd>

    <p><a href="webappapis.html#queue-a-task">Queue a task</a> to run the <a href="#iframe-load-event-steps">iframe load event steps</a>.</p>

    <p>The <a href="webappapis.html#task-source">task source</a> for this <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> is the
    <a href="webappapis.html#dom-manipulation-task-source">DOM manipulation task source</a>.</p>

   </dd>

   <dt>そうでなければ</dt>

   <dd>

    <ol><li>

      <p>If the value of the <code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code> attribute is missing, or its
      value is the empty string, let <var data-anolis-xref="">url</var> be the string
      "<code><a href="infrastructure.html#about:blank">about:blank</a></code>".</p><!-- http://software.hixie.ch/utilities/js/live-dom-viewer/saved/2641 -->
      

      <p>Otherwise, <a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">resolve</a> the value of the <code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code> attribute, relative to the <code><a href="#the-iframe-element">iframe</a></code> element.</p>

      <p>If that is not successful, then let <var data-anolis-xref="">url</var> be the string
      "<code><a href="infrastructure.html#about:blank">about:blank</a></code>". Otherwise, let <var data-anolis-xref="">url</var> be the resulting
      <a href="infrastructure.html#absolute-url">absolute URL</a>.</p>

     </li>

     <li>

      <p>If there exists an <a href="browsers.html#ancestor-browsing-context">ancestor browsing context</a> whose <a href="browsers.html#active-document">active
      document</a>'s <a data-anolis-xref="the document's address" href="dom.html#the-document's-address">address</a>, ignoring fragment
      identifiers, is equal to <var data-anolis-xref="">url</var>, then abort these steps.</p><!-- http://www.hixie.ch/tests/adhoc/html/frames/iframes/ 008.html and 009.html --><!-- http://software.hixie.ch/utilities/js/live-dom-viewer/saved/1969 --><!-- I'm assuming that "resolve" will normalise things like scheme and hostname case -->
      
      
      

     </li>

     <li>

      <p><a href="browsers.html#navigate">Navigate</a><!--DONAV iframe-->  the element's <a href="browsers.html#child-browsing-context">child browsing context</a>
      to <var data-anolis-xref="">url</var>.</p>

     </li>

    </ol></dd>

  </dl><p>Any <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> required of the user agent in the <a href="#process-the-iframe-attributes">process
  the <code>iframe</code> attributes</a> algorithm must be completed as an <a href="browsers.html#explicit-self-navigation-override">explicit
  self-navigation override</a> and with the <code><a href="#the-iframe-element">iframe</a></code> element's document's
  <a href="browsers.html#browsing-context">browsing context</a> as the <a href="browsers.html#source-browsing-context">source browsing context</a>.</p>

  <p>Furthermore, if the <a href="browsers.html#active-document">active document</a> of the element's <a href="browsers.html#child-browsing-context">child browsing
  context</a> before such a <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> was not <a href="syntax.html#completely-loaded">completely
  loaded</a> at the time of the new <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a>, then the <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> must be completed with <a href="browsers.html#replacement-enabled">replacement enabled</a>.</p>

  <p>Similarly, if the <a href="browsers.html#child-browsing-context">child browsing context</a>'s <a href="browsers.html#session-history">session history</a> contained
  only one <code><a href="dom.html#document">Document</a></code> when the <a href="#process-the-iframe-attributes">process the <code>iframe</code> attributes</a>
  algorithm was invoked, and that was the <code><a href="infrastructure.html#about:blank">about:blank</a></code> <code><a href="dom.html#document">Document</a></code> created
  when the <a href="browsers.html#child-browsing-context">child browsing context</a> was created, then any <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> required of the user agent in that algorithm must be completed
  with <a href="browsers.html#replacement-enabled">replacement enabled</a>.</p><!-- see also the note near similar text for the
  location.assign() method --> 

  <p>When a <code><a href="dom.html#document">Document</a></code> in an <code><a href="#the-iframe-element">iframe</a></code> is marked as <a href="syntax.html#completely-loaded">completely
  loaded</a>, the user agent must synchronously run the <a href="#iframe-load-event-steps">iframe load event steps</a>.</p>

  <p class="note">A <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> event is also fired at the
  <code><a href="#the-iframe-element">iframe</a></code> element when it is created if no other data is loaded in it.</p>

  <p>Each <code><a href="dom.html#document">Document</a></code> has an <dfn id="iframe-load-in-progress">iframe load in progress</dfn> flag and a <dfn id="mute-iframe-load">mute
  iframe load</dfn> flag. When a <code><a href="dom.html#document">Document</a></code> is created, these flags must be unset for
  that <code><a href="dom.html#document">Document</a></code>.</p>

  <p>The <dfn id="iframe-load-event-steps">iframe load event steps</dfn> are as follows:</p>

  <ol><li><p>Let <var data-anolis-xref="">child document</var> be the <a href="browsers.html#active-document">active document</a> of the
   <code><a href="#the-iframe-element">iframe</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>.</li>

   <li><p>If <var data-anolis-xref="">child document</var> has its <a href="#mute-iframe-load">mute iframe load</a> flag set,
   abort these steps.</li>

   <li><p>Set <var data-anolis-xref="">child document</var>'s <a href="#iframe-load-in-progress">iframe load in progress</a>
   flag.</li>

   <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the
   <code><a href="#the-iframe-element">iframe</a></code> element.</li>

   <li><p>Unset <var data-anolis-xref="">child document</var>'s <a href="#iframe-load-in-progress">iframe load in progress</a>
   flag.</li>

  </ol><p class="warning">This, in conjunction with scripting, can be used to probe the URL space of the
  local network's HTTP servers. User agents may implement <a data-anolis-xref="origin" href="browsers.html#origin-0">cross-origin</a>
  access control policies that are stricter than those described above to mitigate this attack, but
  unfortunately such policies are typically not compatible with existing Web content.</p>

  <p>When the <code><a href="#the-iframe-element">iframe</a></code>'s <a href="browsers.html#browsing-context">browsing context</a>'s <a href="browsers.html#active-document">active document</a> is
  not <a href="syntax.html#ready-for-post-load-tasks">ready for post-load tasks</a>, and when anything in the <code><a href="#the-iframe-element">iframe</a></code> is <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load event</a> of the <code><a href="#the-iframe-element">iframe</a></code>'s
  <a href="browsers.html#browsing-context">browsing context</a>'s <a href="browsers.html#active-document">active document</a>, and when the <code><a href="#the-iframe-element">iframe</a></code>'s
  <a href="browsers.html#browsing-context">browsing context</a> is in the <a href="browsers.html#delaying-load-events-mode">delaying <code data-anolis-xref="event-load">load</code> events
  mode</a>, the <code><a href="#the-iframe-element">iframe</a></code> must <a href="syntax.html#delay-the-load-event">delay the load event</a> of its document.</p>

  <p class="note">If, during the handling of the <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> event, the
  <a href="browsers.html#browsing-context">browsing context</a> in the <code><a href="#the-iframe-element">iframe</a></code> is again <a data-anolis-xref="navigate" href="browsers.html#navigate">navigated</a>, that will further <a href="syntax.html#delay-the-load-event">delay the load event</a>.</p>

  </div><!-- END of section that's very similar to <frame> -->

  

  <p class="note">要素が作成される際、<code data-anolis-xref="attr-iframe-srcdoc"><a href="#attr-iframe-srcdoc">srcdoc</a></code>属性が設定されず、<code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code>属性が設定されてない、または設定されるがその値が<a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">解決</a>できないのいずれかの場合、ブラウジングコンテキストは初期の<code><a href="infrastructure.html#about:blank">about:blank</a></code>ページのままになる。</p>

  <p class="note">ユーザーがこのページから<a data-anolis-xref="navigate" href="browsers.html#navigate">移動</a>する場合、<code><a href="#the-iframe-element">iframe</a></code>の対応<code><a href="browsers.html#windowproxy">WindowProxy</a></code>オブジェクトは、新規<code><a href="dom.html#document">Document</a></code>オブジェクトに対する新規<code><a href="browsers.html#window">Window</a></code>オブジェクトをプロキシサーバーに送るが、<code data-anolis-xref="attr-iframe-src"><a href="#attr-iframe-src">src</a></code>属性は変更されないだろう。</p>


  <hr><!-- NAME --><p><dfn data-anolis-xref="attr-iframe-name" id="attr-iframe-name"><code>name</code></dfn>属性が存在する場合、<a href="browsers.html#valid-browsing-context-name">妥当なブラウジングコンテキスト名</a>でなければならない。指定された値は、<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>に名前を付けるために使用される。<span class="impl">When the browsing context is created, if the attribute is present, the <a href="browsers.html#browsing-context-name">browsing context name</a> must be set to the value of this attribute; otherwise, the <a href="browsers.html#browsing-context-name">browsing context name</a> must be set to the empty string.</span></p>

  <div class="impl">

  <p>Whenever the <code data-anolis-xref="attr-iframe-name"><a href="#attr-iframe-name">name</a></code> attribute is set, the nested
  <a href="browsers.html#browsing-context">browsing context</a>'s <a data-anolis-xref="browsing context name" href="browsers.html#browsing-context-name">name</a> must be changed to
  the new value. If the attribute is removed, the <a href="browsers.html#browsing-context-name">browsing context name</a> must be set to
  the empty string.</p>

  </div>


  <hr><!-- SANDBOX --><p><dfn data-anolis-xref="attr-iframe-sandbox" id="attr-iframe-sandbox"><code>sandbox</code></dfn>属性が指定された場合、<code><a href="#the-iframe-element">iframe</a></code>によってホストされるあらゆるコンテンツに一連の追加の制限が可能になる。その値は、<a href="infrastructure.html#ascii-case-insensitive">ASCII大文字・小文字不区別</a>である<a href="infrastructure.html#unordered-set-of-unique-space-separated-tokens">順不同なユニークなスペース区切りのトークンのセット</a>でなければならない。許容される値は、<code data-anolis-xref="attr-iframe-sandbox-allow-forms"><a href="browsers.html#attr-iframe-sandbox-allow-forms">allow-forms</a></code>、<code data-anolis-xref="attr-iframe-sandbox-allow-pointer-lock"><a href="browsers.html#attr-iframe-sandbox-allow-pointer-lock">allow-pointer-lock</a></code>、<code data-anolis-xref="attr-iframe-sandbox-allow-popups"><a href="browsers.html#attr-iframe-sandbox-allow-popups">allow-popups</a></code>、<code data-anolis-xref="attr-iframe-sandbox-allow-same-origin"><a href="browsers.html#attr-iframe-sandbox-allow-same-origin">allow-same-origin</a></code>、<code data-anolis-xref="attr-iframe-sandbox-allow-scripts"><a href="browsers.html#attr-iframe-sandbox-allow-scripts">allow-scripts</a></code>、<code data-anolis-xref="attr-iframe-sandbox-allow-top-navigation"><a href="browsers.html#attr-iframe-sandbox-allow-top-navigation">allow-top-navigation</a></code>である。</p>

  <p>この属性が設定される場合、コンテンツは一意な<a href="browsers.html#origin-0">生成元</a>からのものとして扱われ、フォームやスクリプトは無効となり、リンクは他の<a data-anolis-xref="browsing context" href="browsers.html#browsing-context">ブラウジングコンテキスト</a>をターゲットすることを防ぎ、プラグインは保護される。<code data-anolis-xref="attr-iframe-sandbox-allow-same-origin"><a href="browsers.html#attr-iframe-sandbox-allow-same-origin">allow-same-origin</a></code>キーワードは、コンテンツにユニークな生成元を強制する代わりに、コンテンツを実際の生成元からのものとして扱わさせる。<code data-anolis-xref="attr-iframe-sandbox-allow-top-navigation"><a href="browsers.html#attr-iframe-sandbox-allow-top-navigation">allow-top-navigation</a></code>キーワードは、コンテンツに<a href="browsers.html#top-level-browsing-context">トップレベルのブラウジングコンテキスト</a>を<a href="browsers.html#navigate">ナビゲート</a>することができる。<code data-anolis-xref="attr-iframe-sandbox-allow-forms"><a href="browsers.html#attr-iframe-sandbox-allow-forms">allow-forms</a></code>、<code data-anolis-xref="attr-iframe-sandbox-allow-pointer-lock"><a href="browsers.html#attr-iframe-sandbox-allow-pointer-lock">allow-pointer-lock</a></code>、<code data-anolis-xref="attr-iframe-sandbox-allow-popups"><a href="browsers.html#attr-iframe-sandbox-allow-popups">allow-popups</a></code>および<code data-anolis-xref="attr-iframe-sandbox-allow-scripts"><a href="browsers.html#attr-iframe-sandbox-allow-scripts">allow-scripts</a></code>キーワードは、フォーム、ポインタロックAPI、ポップアップ、およびスクリプトそれぞれを再有効にする。<a href="references.html#refsPOINTERLOCK">[POINTERLOCK]</a></p>

  <p class="warning">効果的に完全にサンドボックスを破壊する、<code><a href="#the-iframe-element">iframe</a></code>を含むページが埋め込まれたページに簡単に<code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>属性を削除して再読み込みできるので、埋め込まれたページが<a href="browsers.html#same-origin">同一生成元</a>を持つ際に、<code data-anolis-xref="attr-iframe-sandbox-allow-scripts"><a href="browsers.html#attr-iframe-sandbox-allow-scripts">allow-scripts</a></code>および<code data-anolis-xref="attr-iframe-sandbox-allow-same-origin"><a href="browsers.html#attr-iframe-sandbox-allow-same-origin">allow-same-origin</a></code>の両方のキーワードを共に設定する。</p>

  <p class="warning"><code><a href="#the-iframe-element">iframe</a></code>の<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>が<a data-anolis-xref="navigate" href="browsers.html#navigate">ナビゲートされる</a>際、これらのフラグは効果のみを取る。それらを削除する、または全体の<code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>属性を削除することは、すでに読み込まれたページに影響を与えない。</p>

  <p class="warning">潜在的に敵対的なファイルは、<code><a href="#the-iframe-element">iframe</a></code>要素を含むファイルと同じサーバーから提供されるべきではない。攻撃者が<code><a href="#the-iframe-element">iframe</a></code>内よりむしろ、直接敵対コンテンツを単に訪問することをユーザーに納得させることができる場合、敵対コンテンツをサンドボックス化することは、最小限の助けとなる。敵対的なHTMLコンテンツが原因で発生する可能性のある損害を制限するために、それは独立した専用ドメインから提供されるべきである。たとえ<code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>属性の保護なしで、ユーザーが直接そのページを訪れるようだます場合でも、別のドメインを使用することは、ファイル内のスクリプトがサイトを攻撃できないことを保証する。</p>

  <div class="impl"><!-- v2: Add a new attribute that enables new restrictions, e.g.:
       - disallow cross-origin loads of any kind (networking
         override that only allows same-origin URLs or about:,
         javascript:, data:)
       - block access to 'parent.frames' from sandbox
  -->

  

  <p>When an <code><a href="#the-iframe-element">iframe</a></code> element with a <code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>
  attribute has its <a href="browsers.html#nested-browsing-context">nested browsing context</a> created (before the initial
  <code><a href="infrastructure.html#about:blank">about:blank</a></code> <code><a href="dom.html#document">Document</a></code> is created), and when an <code><a href="#the-iframe-element">iframe</a></code>
  element's <code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code> attribute is set or changed while it
  has a <a href="browsers.html#nested-browsing-context">nested browsing context</a>, the user agent must <a data-anolis-xref="parse a sandboxing
  directive" href="browsers.html#parse-a-sandboxing-directive">parse the sandboxing directive</a> using the attribute's value as the <var data-anolis-xref="">input</var>, the <code><a href="#the-iframe-element">iframe</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>'s
  <a href="browsers.html#iframe-sandboxing-flag-set"><code>iframe</code> sandboxing flag set</a> as the output, and, if the
  <code><a href="#the-iframe-element">iframe</a></code> has an <code data-anolis-xref="attr-iframe-allowfullscreen"><a href="#attr-iframe-allowfullscreen">allowfullscreen</a></code>
  attribute, the <var data-anolis-xref="">allow fullscreen flag</var>.</p>

  <p>When an <code><a href="#the-iframe-element">iframe</a></code> element's <code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>
  attribute is removed while it has a <a href="browsers.html#nested-browsing-context">nested browsing context</a>, the user agent must
  empty the <code><a href="#the-iframe-element">iframe</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>'s
  <a href="browsers.html#iframe-sandboxing-flag-set"><code>iframe</code> sandboxing flag set</a> as the output.</p>

  </div>

  <div class="example">

   <p>この例において、一部の完全に未知で、潜在的に敵対的な、ユーザーが提供するHTMLコンテンツは、ページに埋め込まれている。コンテンツが別のドメインから配信されているため、コンテンツはすべて通常のクロスサイト制限の影響を受ける。また、埋め込みページはスクリプティング、プラグイン、フォームを無効にし、コンテンツは、任意のフレームやそのもの（または任意のフレーム、またはウィンドウ自身が埋め込み）以外のウィンドウを移動できない。</p>

   <pre>&lt;p&gt;We're not scared of you! Here is your content, unedited:&lt;/p&gt;
&lt;iframe sandbox src="http://usercontent.example.net/getusercontent.cgi?id=12193"&gt;&lt;/iframe&gt;</pre>

   <p class="warning">攻撃者が直接そのページへユーザーにアクセスするように納得させる場合、ページがページ内で検出された攻撃に被害を受け易くなるであろうサイトの生成元のコンテキストで実行されないように別のドメインを使用することが重要である。</p>

  </div>

  <div class="example">

   <p>この例において、別のサイトからガジェットが埋め込まれている。ガジェットは、スクリプトやフォームが有効であり、生成元サンドボックスの制限は解除され、その発信元のサーバーと通信できる。しかし、プラグインおよびポップアップを無効にしたように、サンドボックスは依然として有用であり、したがってマルウェアやその他の脅威に晒されるユーザーのリスクを軽減する。</p>

   <pre>&lt;iframe sandbox="allow-same-origin allow-forms allow-scripts"
        src="http://maps.example.com/embedded.html"&gt;&lt;/iframe&gt;</pre>

  </div>

  <div class="example">

   <p>ファイルAに含まれる次の断片を仮定する：</p>

   <pre>&lt;iframe sandbox="allow-same-origin allow-forms" src=B&gt;&lt;/iframe&gt;</pre>

   <p>またファイルBに含まれるiframeを仮定する：</p>

   <pre>&lt;iframe sandbox="allow-scripts" src=C&gt;&lt;/iframe&gt;</pre>

   <p>さらに、ファイルCに含まれるリンクを仮定する：</p>

   <pre>&lt;a href=D&gt;Link&lt;/a&gt;</pre>

   <p>この例に対して、すべてのファイルが<code><a href="iana.html#text/html">text/html</a></code>として供給されると仮定する。</p>

   <p>このシナリオでは、ページCはすべてのサンドボックスのフラグを設定される。Aで<code><a href="#the-iframe-element">iframe</a></code>が無効であり、これがBにおいて<code><a href="#the-iframe-element">iframe</a></code>で設定される<code data-anolis-xref="attr-iframe-sandbox-allow-scripts"><a href="browsers.html#attr-iframe-sandbox-allow-scripts">allow-scripts</a></code>キーワードセットを上書きするので、スクリプトは無効である。フォームのiframeで設定できるように、スクリプトキーワードを上書きするためのスクリプトは、無効になっている。（Bにおける）内側の<code><a href="#the-iframe-element">iframe</a></code>は、<code data-anolis-xref="attr-iframe-sandbox-allow-forms"><a href="browsers.html#attr-iframe-sandbox-allow-forms">allow-forms</a></code>キーワードセットを設定されないため、フォームもまた無効である。</p>

   <p>Aにおけるスクリプトが、AとBですべての<code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>属性を削除すると仮定する。これはすぐには何も変わらないだろう。ユーザーがCのリンクをクリックした場合、Bで<code><a href="#the-iframe-element">iframe</a></code>にページDを読み込み、リンクはページBが読み込まれた際にAの<code><a href="#the-iframe-element">iframe</a></code>内の<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>の状態だったため、あたかもBで<code><a href="#the-iframe-element">iframe</a></code>が<code data-anolis-xref="attr-iframe-sandbox-allow-same-origin"><a href="browsers.html#attr-iframe-sandbox-allow-same-origin">allow-same-origin</a></code>と<code data-anolis-xref="attr-iframe-sandbox-allow-forms"><a href="browsers.html#attr-iframe-sandbox-allow-forms">allow-forms</a></code>キーワードが設定されていたかのように、ページDは振る舞うだろう。</p>

   <p>何が許可されて何が許可されないかについて判断することは非常に困難であるため、一般に、動的に除去したり、<code data-anolis-xref="attr-iframe-sandbox"><a href="#attr-iframe-sandbox">sandbox</a></code>属性を変更したりすることは賢明でない。</p>

  </div>


  <hr><!-- SEAMLESS --><p><dfn data-anolis-xref="attr-iframe-seamless" id="attr-iframe-seamless"><code>seamless</code></dfn>属性は<a href="infrastructure.html#boolean-attribute">真偽属性</a>である。指定された場合、属性は<code><a href="#the-iframe-element">iframe</a></code>要素の<a href="browsers.html#browsing-context">ブラウジングコンテキスト</a>が、含まれている文書を含んでいる（シームレスに親文書に含まれる）一部であるように見えるような方法でレンダリングされるよう指示する。</p>

  <div class="example">

   <p id="inclusion">次の例のように、HTMLのインクルードはこの属性を使用して行われる。この場合、インクルードはサイト全体のナビゲーションバーである。新しいユーザーエージェントにおいて、<code><a href="#the-iframe-element">iframe</a></code>内のすべてのリンクは、自動的に<code><a href="#the-iframe-element">iframe</a></code>の親のブラウジングコンテキストで開かれるだろう。レガシーユーザーエージェントに対して、サイトはまた、値<code data-anolis-xref="">_parent</code>をもつ<code data-anolis-xref="attr-base-target"><a href="document-metadata.html#attr-base-target">target</a></code>属性とともに<code><a href="document-metadata.html#the-base-element">base</a></code>要素を含むことができる。同様に、新しいユーザーエージェントで親ページのスタイルが自動的にフレームのコンテンツに適用されるが、レガシーユーザーエージェントをサポートするために、著者はスタイルを明示的に含めたいかもしれない。</p><!--FORK start: removed hgroup in example-->

   
   <pre>&lt;!DOCTYPE HTML&gt;
&lt;title&gt;Mirror Mirror — MovieInfo™&lt;/title&gt;
&lt;header&gt;
  &lt;h1&gt;Mirror Mirror&lt;/h1&gt;
  &lt;p&gt;Part of the MovieInfo™ Database&lt;/p&gt;
 &lt;nav&gt;
  <strong>&lt;iframe seamless src="nav.inc"&gt;&lt;/iframe&gt;</strong>
 &lt;/nav&gt;
&lt;/header&gt;
...</pre><!--FORK end: removed hgroup-->


  </div>

  <div class="impl">

  <p>An <code><a href="#the-iframe-element">iframe</a></code> element is said to be <dfn id="in-seamless-mode">in seamless mode</dfn> when all of the
  following conditions are met:</p>

  <ul><li>The <code data-anolis-xref="attr-iframe-seamless"><a href="#attr-iframe-seamless">seamless</a></code> attribute is set on the
   <code><a href="#the-iframe-element">iframe</a></code> element, and

   

   </li><li>The <code><a href="#the-iframe-element">iframe</a></code> element's owner <code><a href="dom.html#document">Document</a></code>'s <a href="browsers.html#active-sandboxing-flag-set">active sandboxing flag
   set</a> does not have the <a href="browsers.html#sandboxed-seamless-iframes-flag">sandboxed seamless iframes flag</a> set, and

   

   </li><li>Either:

    

    <ul><li>The <a href="browsers.html#browsing-context">browsing context</a>'s <a href="browsers.html#active-document">active document</a> has the <a href="browsers.html#same-origin">same
     origin</a> as the <code><a href="#the-iframe-element">iframe</a></code> element's <code><a href="dom.html#document">Document</a></code>, or

     

     </li><li>The <a href="browsers.html#browsing-context">browsing context</a>'s <a href="browsers.html#active-document">active document</a>'s <em><a href="sections.html#the-address-element"><span data-anolis-xref="the
     document's address">address</span></a></em> has the <a href="browsers.html#same-origin">same origin</a> as the
     <code><a href="#the-iframe-element">iframe</a></code> element's <code><a href="dom.html#document">Document</a></code>, or

     

     </li><li>The <a href="browsers.html#browsing-context">browsing context</a>'s <a href="browsers.html#active-document">active document</a> is <a href="#an-iframe-srcdoc-document">an
     <code>iframe</code> <code data-anolis-xref="attr-iframe-srcdoc">srcdoc</code> document</a>.

    

    </li></ul></li>

  </ul><p>When an <code><a href="#the-iframe-element">iframe</a></code> element is <a href="#in-seamless-mode">in seamless mode</a>, the following
  requirements apply:</p>

  <ul><li><p>The user agent must set the <dfn id="seamless-browsing-context-flag">seamless browsing context flag</dfn> to true for that
   <a href="browsers.html#browsing-context">browsing context</a>. This will <a href="browsers.html#seamlessLinks">cause links to open in the
   parent browsing context</a> unless an <a href="browsers.html#explicit-self-navigation-override">explicit self-navigation override</a> is used
   (<code data-anolis-xref="">target="_self"</code>).</li>

   <li><p>Media queries in the context of the <code><a href="#the-iframe-element">iframe</a></code>'s <a href="browsers.html#browsing-context">browsing context</a>
   (e.g. on <code data-anolis-xref="attr-style-media"><a href="document-metadata.html#attr-style-media">media</a></code> attributes of <code><a href="document-metadata.html#the-style-element">style</a></code> elements in
   <code><a href="dom.html#document">Document</a></code>s in that <code><a href="#the-iframe-element">iframe</a></code>) must be evaluated with respect to the nearest
   <a href="browsers.html#ancestor-browsing-context">ancestor browsing context</a> that is not itself being <a data-anolis-xref="browsing context
   nested through" href="browsers.html#browsing-context-nested-through">nested through</a> an <code><a href="#the-iframe-element">iframe</a></code> that is <a href="#in-seamless-mode">in seamless
   mode</a>. <a href="references.html#refsMQ">[MQ]</a></li>

   <li><p>In a CSS-supporting user agent: the user agent must add all the style sheets that apply to
   the <code><a href="#the-iframe-element">iframe</a></code> element to the cascade of the <a href="browsers.html#active-document">active document</a> of the
   <code><a href="#the-iframe-element">iframe</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>, at the appropriate cascade
   levels, before any style sheets specified by the document itself.</li>

   <li><p>In a CSS-supporting user agent: the user agent must, for the purpose of CSS property
   inheritance only, treat the root element of the <a href="browsers.html#active-document">active document</a> of the
   <code><a href="#the-iframe-element">iframe</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a> as being a child of the
   <code><a href="#the-iframe-element">iframe</a></code> element. (Thus inherited properties on the root element of the document in
   the <code><a href="#the-iframe-element">iframe</a></code> will inherit the computed values of those properties on the
   <code><a href="#the-iframe-element">iframe</a></code> element instead of taking their initial values.)</li>

   <li><p>In visual media, in a CSS-supporting user agent: the user agent should set the intrinsic
   width of the <code><a href="#the-iframe-element">iframe</a></code> to the width that the element would have if it was a
   non-replaced block-level element with 'width: auto', unless that width would be zero (e.g. if the
   element is floating or absolutely positioned), in which case the user agent should set the
   intrinsic width of the <code><a href="#the-iframe-element">iframe</a></code> to the shrink-to-fit width of the root element (if
   any) of the content rendered in the <code><a href="#the-iframe-element">iframe</a></code>.</li>

   <li><p>In visual media, in a CSS-supporting user agent: the user agent should set the intrinsic
   height of the <code><a href="#the-iframe-element">iframe</a></code> to the shortest height that would make the content rendered in
   the <code><a href="#the-iframe-element">iframe</a></code> at its current width (as given in the previous bullet point) have no
   scrollable overflow at its bottom edge<!--, if the scrolling position was such that the top of
   the viewport for the content rendered in the <code>iframe</code> was aligned with the origin of
   that content's canvas--> Scrollable overflow is any overflow that would increase the range to which a scrollbar or other scrolling mechanism can scroll.</li>

   <li>

    <p>In visual media, in a CSS-supporting user agent: the user agent must force the height of the
    initial containing block of the <a href="browsers.html#active-document">active document</a> of the <a href="browsers.html#nested-browsing-context">nested browsing
    context</a> of the <code><a href="#the-iframe-element">iframe</a></code> to zero.</p>

    <p class="note">This is intended to get around the otherwise circular dependency of percentage
    dimensions that depend on the height of the containing block, thus affecting the height of the
    document's bounding box, thus affecting the height of the viewport, thus affecting the size of
    the initial containing block.</p>

   </li>

   <li><p>In speech media, the user agent should render the <a href="browsers.html#nested-browsing-context">nested browsing context</a>
   without announcing that it is a separate document.</li>

   <li>

    <p>User agents should, in general, act as if the <a href="browsers.html#active-document">active document</a> of the
    <code><a href="#the-iframe-element">iframe</a></code>'s <a href="browsers.html#nested-browsing-context">nested browsing context</a> was part of the document that the
    <code><a href="#the-iframe-element">iframe</a></code> is in, if any.</p>

    <p class="example">For example if the user agent supports listing all the links in a document,
    links in "seamlessly" nested documents would be included in that list without being
    significantly distinguished from links in the document itself.</p>

   </li>

   <li><p>The <a href="browsers.html#nested-browsing-context">nested browsing context</a>'s <code><a href="browsers.html#window">Window</a></code> object's
   <a href="infrastructure.html#cross-boundary-event-parent">cross-boundary event parent</a> is the <a href="browsers.html#browsing-context-container">browsing context container</a>. <a href="references.html#refsDOM">[DOM]</a></li>

  </ul><p>If the attribute is not specified, or if the <a href="browsers.html#origin-0">origin</a> conditions listed above are
  not met, then the user agent should render the <a href="browsers.html#nested-browsing-context">nested browsing context</a> in a manner
  that is clearly distinguishable as a separate <a href="browsers.html#browsing-context">browsing context</a>, and the
  <a href="#seamless-browsing-context-flag">seamless browsing context flag</a> must be set to false for that <a href="browsers.html#browsing-context">browsing
  context</a>.</p>

  <p class="warning">It is important that user agents recheck the above conditions whenever the
  <a href="browsers.html#active-document">active document</a> of the <a href="browsers.html#nested-browsing-context">nested browsing context</a> of the
  <code><a href="#the-iframe-element">iframe</a></code> changes, such that the <a href="#seamless-browsing-context-flag">seamless browsing context flag</a> gets unset
  if the <a href="browsers.html#nested-browsing-context">nested browsing context</a> is <a data-anolis-xref="navigate" href="browsers.html#navigate">navigated</a> to another
  origin.</p>

  </div>

  <p class="note">属性は、並列で更新をレンダリングするとともに、動的に設定または削除できる。</p>

  <p class="note"><code data-anolis-xref="attr-contenteditable"><a href="editing.html#attr-contenteditable">contenteditable</a></code>属性は、<code data-anolis-xref="attr-iframe-seamless"><a href="#attr-iframe-seamless">seamless</a></code><code><a href="#the-iframe-element">iframe</a></code>へ伝達しない。</p>


  <hr><!-- FULLSCREEN --><p><dfn data-anolis-xref="attr-iframe-allowfullscreen" id="attr-iframe-allowfullscreen"><code>allowfullscreen</code></dfn>属性は、<a href="infrastructure.html#boolean-attribute">真偽属性</a>である。指定される場合、属性は、<code><a href="#the-iframe-element">iframe</a></code>要素の<a href="browsers.html#browsing-context">ブラウジングコンテキスト</a>での<code><a href="dom.html#document">Document</a></code>オブジェクトが<code data-anolis-xref="dom-element-requestFullscreen"><a href="infrastructure.html#dom-element-requestfullscreen">requestFullscreen()</a></code>の使用を許可されることを表示する（他の理由でブロックされない場合、たとえば、この属性が設定されない別の祖先<code><a href="#the-iframe-element">iframe</a></code>が存在する）。</p>

  <div class="example">

   <p>ここで、<code><a href="#the-iframe-element">iframe</a></code>はビデオサイトからのプレイヤーを埋め込むために使用される。<code data-anolis-xref="attr-iframe-allowfullscreen"><a href="#attr-iframe-allowfullscreen">allowfullscreen</a></code>属性はそのビデオをフルスクリーン表示するようなプレイヤーを有効にするために必要とされる。</p>

   <pre>&lt;article&gt;
 &lt;header&gt;
  &lt;p&gt;&lt;img src="/usericons/1627591962735"&gt; &lt;b&gt;Fred Flintstone&lt;/b&gt;&lt;/p&gt;
  &lt;p&gt;&lt;a href="/posts/3095182851" rel=bookmark&gt;12:44&lt;/a&gt; — &lt;a href="#acl-3095182851"&gt;Private Post&lt;/a&gt;&lt;/p&gt;
 &lt;/header&gt;
 &lt;main&gt;
  &lt;p&gt;Check out my new ride!&lt;/p&gt;
  <strong>&lt;iframe src="https://video.example.com/embed?id=92469812" allowfullscreen&gt;&lt;/iframe&gt;</strong>
 &lt;/main&gt;
&lt;/article&gt;</pre>

  </div>


  <hr><!-- DIM ATTRIBUTES --><p><code><a href="#the-iframe-element">iframe</a></code>要素は、埋め込まれたコンテンツが特定のサイズをもつ（たとえば単位が明確に定義された寸法をもつ）場合、<a href="#dimension-attributes">寸法属性</a>をサポートする。</p>

  <p>指定した初期コンテンツ内容が正常に使用されるかどうかに関わらず、常にネストした<a href="browsers.html#browsing-context">ブラウジングコンテキスト</a>を作成するので、<code><a href="#the-iframe-element">iframe</a></code>要素は<a href="dom.html#fallback-content">フォールバックコンテンツ</a>にならない。</p>


  <hr><!-- FALLBACK --><p><code><a href="#the-iframe-element">iframe</a></code>要素の子孫は何も表さない。（<code><a href="#the-iframe-element">iframe</a></code>要素をサポートしないレガシーユーザーエージェントにおいて、コンテンツはフォールバックコンテンツとして機能することができるマークアップとして解析される。）</p>

  <p id="iframe-content-model"><a href="infrastructure.html#html-documents">HTML文書</a>で使用する場合、<code><a href="#the-iframe-element">iframe</a></code>要素の許可されたコンテンツモデルはテキストである。ただし、<var data-anolis-xref="concept-frag-parse-context"><a href="syntax.html#concept-frag-parse-context">context</a></var>要素として<code><a href="#the-iframe-element">iframe</a></code>要素および<var data-anolis-xref="">input</var>としてテキストコンテンツをもつ<a href="syntax.html#html-fragment-parsing-algorithm">HTML断片解析アルゴリズム</a>を呼び出すことが、一切の<a data-anolis-xref="parse error" href="syntax.html#parse-error">解析エラー</a>なく、リスト内の任意の場所にまたはリスト内の要素の子孫として<code><a href="scripting-1.html#the-script-element">script</a></code>要素をもたず、かつ自身が適合するリスト（その子孫を含む）内のすべての要素をもつ、<a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>であるノードのリストをもたらさなければならないことを除く。</p>

  <p><code><a href="#the-iframe-element">iframe</a></code>要素は、<a href="infrastructure.html#xml-documents">XML文書</a>で空でなければならない。</p>

  <p class="note"><a href="syntax.html#html-parser">HTMLパーサ</a>は、テキストとして<code><a href="#the-iframe-element">iframe</a></code>要素の内側のマークアップを扱う。</p>


  <div class="impl">

  <hr><!-- DOM --><p>The IDL attributes <dfn data-anolis-xref="dom-iframe-src" id="dom-iframe-src"><code>src</code></dfn>, <dfn data-anolis-xref="dom-iframe-srcdoc" id="dom-iframe-srcdoc"><code>srcdoc</code></dfn>, <dfn data-anolis-xref="dom-iframe-name" id="dom-iframe-name"><code>name</code></dfn>, <dfn data-anolis-xref="dom-iframe-sandbox" id="dom-iframe-sandbox"><code>sandbox</code></dfn>, and <dfn data-anolis-xref="dom-iframe-seamless" id="dom-iframe-seamless"><code>seamless</code></dfn> must <a href="infrastructure.html#reflect">reflect</a> the respective
  content attributes of the same name.</p>

  <p>The <dfn data-anolis-xref="dom-iframe-allowFullscreen" id="dom-iframe-allowfullscreen"><code>allowFullscreen</code></dfn> IDL attribute
  must <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-iframe-allowfullscreen"><a href="#attr-iframe-allowfullscreen">allowfullscreen</a></code>
  content attribute.</p>

  <p>The <dfn data-anolis-xref="dom-iframe-contentDocument" id="dom-iframe-contentdocument"><code>contentDocument</code></dfn> IDL attribute
  must return the <code><a href="dom.html#document">Document</a></code> object of the <a href="browsers.html#active-document">active document</a> of the
  <code><a href="#the-iframe-element">iframe</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>, if any and if its
  <a href="browsers.html#effective-script-origin">effective script origin</a> is the <a href="browsers.html#same-origin">same origin</a> as the <a href="browsers.html#effective-script-origin">effective script
  origin</a> specified by the <a href="webappapis.html#incumbent-settings-object">incumbent settings object</a>, or null otherwise.</p>

  <p>The <dfn data-anolis-xref="dom-iframe-contentWindow" id="dom-iframe-contentwindow"><code>contentWindow</code></dfn> IDL attribute must
  return the <code><a href="browsers.html#windowproxy">WindowProxy</a></code> object of the <code><a href="#the-iframe-element">iframe</a></code> element's <a href="browsers.html#nested-browsing-context">nested
  browsing context</a>, if any, or null otherwise.</p>

  </div>

  <div class="example">

   <p>広告ブローカーから広告を含めるように<code><a href="#the-iframe-element">iframe</a></code>を使ったページの例は次のとおり：</p>

   <pre>&lt;iframe src="http://ads.example.com/?customerid=923513721&amp;amp;format=banner"
        width="468" height="60"&gt;&lt;/iframe&gt;</pre>

  </div>




  <h4 id="the-embed-element"><span class="secno">4.7.7</span> <dfn><code>embed</code></dfn>要素</h4><!-- (v2?)
 we have all kinds of quirks we should define if they come up during
 testing, as e.g. shown in:
 http://mxr.mozilla.org/mozilla-central/source/layout/generic/nsObjectFrame.cpp
 http://trac.webkit.org/browser/trunk/WebCore/html/HTMLEmbedElement.cpp
 http://trac.webkit.org/browser/trunk/WebCore/rendering/RenderPartObject.cpp (updateWidget)
 e.g. - 240x200 default
      - the attributes/params are sent in a name-value pair list as follows (for Gecko):
         + attributes of the element, in source order
         + a synthesised 'src' attribute, if there was no 'src' but
           there was a 'data', with the value of the 'data' attribute
         + the params, in source order
        (WebKit does something different still)
      - the HIDDEN attribute (might be moot now)
-->



  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>。</dd>
   <dd><a href="dom.html#interactive-content-0">インタラクティブコンテンツ</a>。</dd>
   <dd><a href="dom.html#palpable-content-0">パルパブルコンテンツ</a>。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>が期待される場所。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>空。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code> — 埋め込みリソースタイプ</dd>
   <dd><code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code> - 横の次元</dd>
   <dd><code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code> - 縦の寸法</dd>
   <dd>名前空間を持たないその他の属性（文参照）。</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd><a data-anolis-xref="syntax-end-tag" href="syntax.html#syntax-end-tag">終了タグ</a>なし</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd><a href="dom.html#index-aria-application"><code title="">application</code></a>、<a href="dom.html#index-aria-document"><code title="">document</code></a>、<a href="dom.html#index-aria-img"><code title="">img</code></a>または<a href="dom.html#index-aria-presentation"><code title="">presentation</code></a>。</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dd><a href="dom.html#allowed-aria-roles,-states-and-properties">許可されるロールで受け入れ可能な</a>任意の<code title="">aria-*</code>属性。</dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmlembedelement">HTMLEmbedElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-embed-src" href="#dom-embed-src">src</a>;
           attribute DOMString <a data-anolis-xref="dom-embed-type" href="#dom-embed-type">type</a>;
           attribute DOMString <a data-anolis-xref="dom-dim-width" href="#dom-dim-width">width</a>;
           attribute DOMString <a data-anolis-xref="dom-dim-height" href="#dom-dim-height">height</a>;
  <a data-anolis-xref="dom-embed-caller" href="#dom-embed-caller">legacycaller</a> any (any... arguments);
};</pre>
    <div class="impl">
    <p>Depending on the type of content instantiated by the
    <code><a href="#the-embed-element">embed</a></code> element, the node may also support other
    interfaces.</p>
    </div>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-embed-element">embed</a></code>要素は外部の（典型的には非HTML）アプリケーションやインタラクティブコンテンツの統合点を提供する。</p>

  <p><dfn data-anolis-xref="attr-embed-src" id="attr-embed-src"><code>src</code></dfn>属性は、埋め込まれているリソースのアドレスを与える。属性が存在する場合、<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>を含まなければならない。</p>

  <p><code data-anolis-xref="attr-itemprop">itemprop</code>が<code><a href="#the-embed-element">embed</a></code>要素で指定される場合、<code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code>属性も指定されなければならない。</p>

  <p><dfn data-anolis-xref="attr-embed-type" id="attr-embed-type"><code>type</code></dfn>属性が存在する場合は、インスタンスを生成するプラグインが選択される<a href="infrastructure.html#mime-type">MIMEタイプ</a>を提供する。値は<a href="infrastructure.html#valid-mime-type">妥当なMIMEタイプ</a>でなければならない。<code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code>属性と<code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code>属性の両方が存在する場合、<code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code>属性は、<code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code>属性で指定されたリソースの<a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">明示的なContent-Typeメタデータ</a>と同じ型を指定しなければならない。</p>

  <div class="impl">

  <p>While any of the following conditions are occurring, any <a href="infrastructure.html#plugin">plugin</a> instantiated for
  the element must be removed, and the <code><a href="#the-embed-element">embed</a></code> element <a href="dom.html#represents">represents</a>
  nothing:</p>

  <ul class="brief"><li><p>The element has neither a <code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> attribute nor a <code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code> attribute.</li>

   <li><p>The element has a <a href="#media-element">media element</a> ancestor.</li>

   <li><p>The element has an ancestor <code><a href="#the-object-element">object</a></code> element that is <em>not</em> showing its
   <a href="dom.html#fallback-content">fallback content</a>.</li>

  </ul><p>An <code><a href="#the-embed-element">embed</a></code> element is said to be <dfn data-anolis-xref="concept-embed-active" id="concept-embed-active">potentially
  active</dfn> when the following conditions are all met simultaneously:</p>

  <ul class="brief"><li>The element is <a data-anolis-xref="in a document" href="infrastructure.html#in-a-document">in a <code>Document</code></a> or was <a data-anolis-xref="in a document" href="infrastructure.html#in-a-document">in a <code>Document</code></a> the last time the <a href="webappapis.html#event-loop">event loop</a>
   reached step 1.</li>

   <li>The element's <code><a href="dom.html#document">Document</a></code> is <a href="browsers.html#fully-active">fully active</a>.</li>

   <li>The element has either a <code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> attribute set or a <code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code> attribute set (or both).</li>

   <li>The element's <code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> attribute is either absent or its value
   is not the empty string.</li>

   <li>The element is not a descendant of a <a href="#media-element">media element</a>.</li>

   <li>The element is not a descendant of an <code><a href="#the-object-element">object</a></code> element that is not showing its
   <a href="dom.html#fallback-content">fallback content</a>.</li>

   <li>The element is <a href="rendering.html#being-rendered">being rendered</a>, or was <a href="rendering.html#being-rendered">being rendered</a> the last time
   the <a href="webappapis.html#event-loop">event loop</a> reached step 1.</li>

  </ul><p>Whenever an <code><a href="#the-embed-element">embed</a></code> element that was not <a data-anolis-xref="concept-embed-active" href="#concept-embed-active">potentially active</a> becomes <a data-anolis-xref="concept-embed-active" href="#concept-embed-active">potentially active</a>, and whenever a <a data-anolis-xref="concept-embed-active" href="#concept-embed-active">potentially active</a> <code><a href="#the-embed-element">embed</a></code> element that is
  remaining <a data-anolis-xref="concept-embed-active" href="#concept-embed-active">potentially active</a> and has its <code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">src</a></code> attribute set, changed, or removed or its <code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code> attribute set, changed, or removed, the user agent must
  <a href="webappapis.html#queue-a-task">queue a task</a> using the <dfn id="embed-task-source">embed task source</dfn> to run <a href="#the-embed-element-setup-steps">the
  <code>embed</code> element setup steps</a>.</p>

  <p><dfn id="the-embed-element-setup-steps">The <code>embed</code> element setup steps</dfn> are as follows:</p>

  <ol><li><p>If another <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> has since been queued to run <a href="#the-embed-element-setup-steps">the
   <code>embed</code> element setup steps</a> for this element, then abort these steps.</li>

   <li>

    <dl class="switch"><dt>If the element has a <code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> attribute set</dt>

     <dd>

      <p>The user agent must <a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">resolve</a> the value of the element's
      <code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> attribute, relative to the element. If that is
      successful, the user agent should <a href="infrastructure.html#fetch">fetch</a> the resulting <a href="infrastructure.html#absolute-url">absolute
      URL</a>, from the element's <a href="browsers.html#browsing-context-scope-origin">browsing context scope origin</a> if it has one. The <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that
      is <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> once
      the resource has been <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> must run the following steps:</p><!-- Note that this doesn't happen when the base URL changes. -->
      

      <ol><li><p>If another <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> has since been queued to run
       <a href="#the-embed-element-setup-steps">the <code>embed</code> element setup steps</a> for this element, then abort these
       steps.</li>

       <li>

        <p>Determine the <dfn data-anolis-xref="concept-embed-type" id="concept-embed-type">type of the content</dfn> being embedded, as
        follows (stopping at the first substep that determines the type):</p>

        <ol><li><p>If the element has a <code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code> attribute, and that
         attribute's value is a type that a <a href="infrastructure.html#plugin">plugin</a> supports, then the value of the
         <code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code> attribute is the <a data-anolis-xref="concept-embed-type" href="#concept-embed-type">content's type</a>.</li>

         <li><!-- if we get to this point we know we can successfully parsed the URL, since this algorithm is
          only used after fetching the resource in the steps above -->

          

          <p>Otherwise, if applying the <a href="infrastructure.html#url-parser">URL parser</a> algorithm to the <a href="infrastructure.html#url">URL</a> of
          the specified resource (after any redirects) results in a <a href="infrastructure.html#parsed-url">parsed URL</a> whose
          <a data-anolis-xref="concept-url-path" href="infrastructure.html#concept-url-path">path</a> component matches a pattern that a
          <a href="infrastructure.html#plugin">plugin</a> supports, then the <a data-anolis-xref="concept-embed-type" href="#concept-embed-type">content's
          type</a> is the type that that plugin can handle.</p>

          <p class="example">For example, a plugin might say that it can handle resources with <a data-anolis-xref="concept-url-path" href="infrastructure.html#concept-url-path">path</a> components that end with the four character string
          "<code data-anolis-xref="">.swf</code>".</p><!-- it's sad that we have to do extension sniffing. sigh. --><!-- see also <object> which has a similar step -->

          
          

         </li>

         <li><p>Otherwise, if the specified resource has <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">explicit
         Content-Type metadata</a>, then that is the <a data-anolis-xref="concept-embed-type" href="#concept-embed-type">content's
         type</a>.</li>

         <li><p>Otherwise, the content has no <a data-anolis-xref="concept-embed-type" href="#concept-embed-type">type</a> and there
         can be no appropriate <a href="infrastructure.html#plugin">plugin</a> for it.</li><!-- This algorithm is a monument to bad design. Go legacy! -->

         

        </ol></li>

       <li>

        <p>If the previous step determined that the <a data-anolis-xref="concept-embed-type" href="#concept-embed-type">content's
        type</a> is <code data-anolis-xref="">image/svg+xml</code>, then run the following substeps:</p>

        <ol><li><p>If the <code><a href="#the-embed-element">embed</a></code> element is not associated with a <a href="browsers.html#nested-browsing-context">nested browsing
         context</a>, associate the element with a newly created <a href="browsers.html#nested-browsing-context">nested browsing
         context</a>, and, if the element has a <code data-anolis-xref="attr-embed-name"><a href="obsolete.html#attr-embed-name">name</a></code>
         attribute, set the <a href="browsers.html#browsing-context-name">browsing context name</a> of the element's <a href="browsers.html#nested-browsing-context">nested
         browsing context</a> to the value of this attribute.</p><!-- http://software.hixie.ch/utilities/js/live-dom-viewer/?saved=2291 - dynamic changes to 'name' don't do anything -->
         

         </li><li><p><a href="browsers.html#navigate">Navigate</a><!--DONAV embed-->  the <a href="browsers.html#nested-browsing-context">nested browsing context</a> to
         the fetched resource, with <a href="browsers.html#replacement-enabled">replacement enabled</a>, and with the
         <code><a href="#the-embed-element">embed</a></code> element's document's <a href="browsers.html#browsing-context">browsing context</a> as the <a href="browsers.html#source-browsing-context">source
         browsing context</a>. (The <code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> attribute of the
         <code><a href="#the-embed-element">embed</a></code> element doesn't get updated if the browsing context gets further
         navigated to other locations.)</li>

         <li><p>The <code><a href="#the-embed-element">embed</a></code> element now <a href="dom.html#represents">represents</a> its associated
         <a href="browsers.html#nested-browsing-context">nested browsing context</a>.</li>

        </ol></li>

       <li>

        <p>Otherwise, find and instantiate an appropriate <a href="infrastructure.html#plugin">plugin</a> based on the <a data-anolis-xref="concept-embed-type" href="#concept-embed-type">content's type</a>, and hand that <a href="infrastructure.html#plugin">plugin</a> the
        content of the resource, replacing any previously instantiated plugin for the element. The
        <code><a href="#the-embed-element">embed</a></code> element now represents this <a href="infrastructure.html#plugin">plugin</a> instance.</p>

       </li>

       <li><p>Once the resource or plugin has completely loaded, <a href="webappapis.html#queue-a-task">queue a task</a> to
       <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the
       element.</li>

      </ol><p>Whether the resource is fetched successfully or not (e.g. whether the response code was a
      2xx code <a data-anolis-xref="concept-http-equivalent-codes" href="infrastructure.html#concept-http-equivalent-codes">or equivalent</a>) must be ignored
      when determining the <a data-anolis-xref="concept-embed-type" href="#concept-embed-type">content's type</a> and when handing
      the resource to the plugin.</p>

      <p class="note">This allows servers to return data for plugins even with error responses (e.g.
      HTTP 500 Internal Server Error codes can still contain plugin data).</p>

      <p>Fetching the resource must <a href="syntax.html#delay-the-load-event">delay the load event</a> of the element's document.</p><!-- if we add load/error events, then replace the previous paragraph with the text one: --><!-- similar text in various places --><!--<p>Fetching the resource must <span>delay the load event</span> of the element's document
      until the final <span data-x="concept-task">task</span> that is <span data-x="queue a
      task">queued</span> by the <span>networking task source</span> once the resource has been
      <span data-x="fetch">fetched</span> has been run.</p>-->
      
      
      

     </dd>

     <dt>If the element has no <code data-anolis-xref="attr-embed-src"><a href="#attr-embed-src">src</a></code> attribute set</dt>

     <dd>

      <p>The user agent should find and instantiate an appropriate <a href="infrastructure.html#plugin">plugin</a> based on the
      value of the <code data-anolis-xref="attr-embed-type"><a href="#attr-embed-type">type</a></code> attribute. The <code><a href="#the-embed-element">embed</a></code>
      element now represents this <a href="infrastructure.html#plugin">plugin</a> instance.</p>

      <p>Once the plugin is completely loaded, <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
      event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the element.</p>

     </dd>

    </dl></li>

  </ol><p>The <code><a href="#the-embed-element">embed</a></code> element has no <a href="dom.html#fallback-content">fallback content</a>. If the user agent can't
  find a suitable plugin when attempting to find and instantiate one for the algorithm above, then
  the user agent must use a default plugin. This default could be as simple as saying "Unsupported
  Format".</p>

  <p>Whenever an <code><a href="#the-embed-element">embed</a></code> element that was <a data-anolis-xref="concept-embed-active" href="#concept-embed-active">potentially
  active</a> stops being <a data-anolis-xref="concept-embed-active" href="#concept-embed-active">potentially active</a>, any
  <a href="infrastructure.html#plugin">plugin</a> that had been instantiated for that element must be unloaded.</p>

  <p id="sandboxPluginEmbed">When a <a href="infrastructure.html#plugin">plugin</a> is to be instantiated but it cannot be <a data-anolis-xref="concept-plugin-secure" href="infrastructure.html#concept-plugin-secure">secured</a> and the <a href="browsers.html#sandboxed-plugins-browsing-context-flag">sandboxed plugins browsing context
  flag</a> is set on the <code><a href="#the-embed-element">embed</a></code> element's <code><a href="dom.html#document">Document</a></code>'s <a href="browsers.html#active-sandboxing-flag-set">active
  sandboxing flag set</a>, then the user agent must not instantiate the <a href="infrastructure.html#plugin">plugin</a>, and
  must instead render the <code><a href="#the-embed-element">embed</a></code> element in a manner that conveys that the
  <a href="infrastructure.html#plugin">plugin</a> was disabled. The user agent may offer the user the option to override the
  sandbox and instantiate the <a href="infrastructure.html#plugin">plugin</a> anyway; if the user invokes such an option, the
  user agent must act as if the conditions above did not apply for the purposes of this element.</p>

  <p class="warning">Plugins that cannot be <a data-anolis-xref="concept-plugin-secure" href="infrastructure.html#concept-plugin-secure">secured</a> are
  disabled in sandboxed browsing contexts because they might not honor the restrictions imposed by
  the sandbox (e.g. they might allow scripting even when scripting in the sandbox is disabled). User
  agents should convey the danger of overriding the sandbox to the user if an option to do so is
  provided.</p>

  <p>When an <code><a href="#the-embed-element">embed</a></code> element represents a <a href="browsers.html#nested-browsing-context">nested browsing context</a>: if the
  <code><a href="#the-embed-element">embed</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>'s <a href="browsers.html#active-document">active document</a>
  is not <a href="syntax.html#ready-for-post-load-tasks">ready for post-load tasks</a>, and when anything is <a data-anolis-xref="delay the load
  event" href="syntax.html#delay-the-load-event">delaying the load event</a> of the <code><a href="#the-embed-element">embed</a></code> element's <a href="browsers.html#browsing-context">browsing
  context</a>'s <a href="browsers.html#active-document">active document</a>, and when the <code><a href="#the-embed-element">embed</a></code> element's
  <a href="browsers.html#browsing-context">browsing context</a> is in the <a href="browsers.html#delaying-load-events-mode">delaying <code data-anolis-xref="event-load">load</code>
  events mode</a>, the <code><a href="#the-embed-element">embed</a></code> must <a href="syntax.html#delay-the-load-event">delay the load event</a> of its
  document.</p>

  <p>The <a href="webappapis.html#task-source">task source</a> for the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> mentioned in this
  section is the <a href="webappapis.html#dom-manipulation-task-source">DOM manipulation task source</a>.</p>

  </div>

  <p><code data-anolis-xref="attr-embed-name"><a href="obsolete.html#attr-embed-name">name</a></code>、<code data-anolis-xref="attr-embed-align"><a href="obsolete.html#attr-embed-align">align</a></code>、<code data-anolis-xref="attr-embed-hspace"><a href="obsolete.html#attr-embed-hspace">hspace</a></code>、および<code data-anolis-xref="attr-embed-vspace"><a href="obsolete.html#attr-embed-vspace">vspace</a></code>以外の名前空間なしの属性は、その名前が<a href="infrastructure.html#xml-compatible">XML互換性</a>があり、<a href="infrastructure.html#uppercase-ascii-letters">ASCII大文字</a>を一切含まない限り、<code><a href="#the-embed-element">embed</a></code>要素で指定されてもよい。これらの属性は、<a href="infrastructure.html#plugin">プラグイン</a>にパラメータとして渡される。</p>

  <p class="note">大文字の制限がそのような文書に影響しないので、<a href="infrastructure.html#html-documents">HTML文書</a>内のすべての属性は自動的に小文字を取得する。</p>

  <p class="note">4つの例外は、<a href="infrastructure.html#plugin">プラグイン</a>に送信するパラメータを超えた副作用を持つ従来の属性を除外するのに適当である。</p>

  <div class="impl">

  <p>The user agent should pass the names and values of all the attributes of the <code><a href="#the-embed-element">embed</a></code>
  element that have no namespace to the <a href="infrastructure.html#plugin">plugin</a> used, when one is instantiated.</p>

  <p>The <code><a href="#htmlembedelement">HTMLEmbedElement</a></code> object representing the element must expose the scriptable
  interface of the <a href="infrastructure.html#plugin">plugin</a> instantiated for the <code><a href="#the-embed-element">embed</a></code> element, if any. At a
  minimum, this interface must implement the <dfn data-anolis-xref="dom-embed-caller" id="dom-embed-caller">legacy caller
  operation</dfn>. (It is suggested that the default behavior of this legacy caller operation, e.g.
  the behavior of the default plugin's legacy caller operation, be to throw a
  <code><a href="infrastructure.html#notsupportederror">NotSupportedError</a></code> exception.)</p>

  </div>

  <p><code><a href="#the-embed-element">embed</a></code>要素は、<a href="#dimension-attributes">寸法属性</a>をサポートする。</p>

  <div class="impl">

  <p>The IDL attributes <dfn data-anolis-xref="dom-embed-src" id="dom-embed-src"><code>src</code></dfn> and <dfn data-anolis-xref="dom-embed-type" id="dom-embed-type"><code>type</code></dfn> each must <a href="infrastructure.html#reflect">reflect</a> the respective
  content attributes of the same name.</p>

  </div>

  <div class="example">

   <p>これはFlashのような、独自のプラグインを必要とするリソースを埋め込むための方法である：</p>

   <pre>&lt;embed src="catgame.swf"&gt;</pre>

   <p>ユーザーがプラグインを持たない場合（たとえばプラグインベンダーがユーザーのプラットフォームをサポートしない場合）、ユーザーはリソースを使用できない。</p>

   <p>"high"値をもつパラメータ"quality"をプラグインに渡すために、属性を指定できる：</p>

   <pre>&lt;embed src="catgame.swf" quality="high"&gt;</pre>

   <p>代わりに<code><a href="#the-object-element">object</a></code>要素を使用する場合、次のものと等価になる：</p>

   <pre>&lt;object data="catgame.swf"&gt;
 &lt;param name="quality" value="high"&gt;
&lt;/object&gt;</pre>

  </div>




  <h4 id="the-object-element"><span class="secno">4.7.8</span> <dfn><code>object</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>。</dd>
   <dd>要素が<code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code>属性をもつ場合：<a href="dom.html#interactive-content-0">インタラクティブコンテンツ</a>。</dd><!-- also when showing a plugin or a nested browsing context, but checking that statically is hard...) --> 
   <dd><a data-anolis-xref="category-listed" href="forms.html#category-listed">リスト</a>、<a data-anolis-xref="category-submit" href="forms.html#category-submit">送信可能</a>、<a data-anolis-xref="category-form-attr" href="forms.html#category-form-attr">再関連付け可能</a> <a href="forms.html#form-associated-element">フォーム関連要素</a>。</dd>
   <dd><a href="dom.html#palpable-content-0">パルパブルコンテンツ</a>。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>が期待される場所。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>0個以上の<code><a href="#the-param-element">param</a></code>要素、それから<a href="dom.html#transparent">透過的</a>。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> — 埋め込みリソースタイプ</dd>
   <dd><code data-anolis-xref="attr-object-typemustmatch"><a href="#attr-object-typemustmatch">typemustmatch</a></code> - <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code>属性および<a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">Content-Type</a>値が使用されるリソースにマッチする必要があるかどうか</dd>
   <dd><code data-anolis-xref="attr-object-name"><a href="#attr-object-name">name</a></code> - <a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>名</dd>
   <dd><code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code> - 使用する<a href="#image-map">イメージマップ</a>の名前 </dd>
   <dd><code data-anolis-xref="attr-fae-form"><a href="forms.html#attr-fae-form">form</a></code> - <code><a href="forms.html#the-form-element">form</a></code>要素とコントロールを関連付ける</dd>
   <dd><code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code> - 横の次元</dd>
   <dd><code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code> - 縦の次元</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd>どちらのタグも省略不可。</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd><a href="dom.html#index-aria-application"><code title="">application</code></a>、<a href="dom.html#index-aria-document"><code title="">document</code></a>、<a href="dom.html#index-aria-img"><code title="">img</code></a>または<a href="dom.html#index-aria-presentation"><code title="">presentation</code></a>。</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dd><a href="dom.html#allowed-aria-roles,-states-and-properties">許可されるロールで受け入れ可能な</a>任意の<code title="">aria-*</code>属性。</dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmlobjectelement">HTMLObjectElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-object-data" href="#dom-object-data">data</a>;
           attribute DOMString <a data-anolis-xref="dom-object-type" href="#dom-object-type">type</a>;
           attribute boolean <a data-anolis-xref="dom-object-typeMustMatch" href="#dom-object-typemustmatch">typeMustMatch</a>;
           attribute DOMString <a data-anolis-xref="dom-object-name" href="#dom-object-name">name</a>;
           attribute DOMString <a data-anolis-xref="dom-object-useMap" href="#dom-object-usemap">useMap</a>;
  readonly attribute <a href="forms.html#htmlformelement">HTMLFormElement</a>? <a data-anolis-xref="dom-fae-form" href="forms.html#dom-fae-form">form</a>;
           attribute DOMString <a data-anolis-xref="dom-dim-width" href="#dom-dim-width">width</a>;
           attribute DOMString <a data-anolis-xref="dom-dim-height" href="#dom-dim-height">height</a>;
  readonly attribute <a href="dom.html#document">Document</a>? <a data-anolis-xref="dom-object-contentDocument" href="#dom-object-contentdocument">contentDocument</a>;
  readonly attribute <a href="browsers.html#windowproxy">WindowProxy</a>? <a data-anolis-xref="dom-object-contentWindow" href="#dom-object-contentwindow">contentWindow</a>;

  readonly attribute boolean <a data-anolis-xref="dom-cva-willValidate" href="forms.html#dom-cva-willvalidate">willValidate</a>;
  readonly attribute <a href="forms.html#validitystate">ValidityState</a> <a data-anolis-xref="dom-cva-validity" href="forms.html#dom-cva-validity">validity</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-cva-validationMessage" href="forms.html#dom-cva-validationmessage">validationMessage</a>;
  boolean <a data-anolis-xref="dom-cva-checkValidity" href="forms.html#dom-cva-checkvalidity">checkValidity</a>();
  boolean <a data-anolis-xref="dom-cva-reportValidity" href="forms.html#dom-cva-reportvalidity">reportValidity</a>();
  void <a data-anolis-xref="dom-cva-setCustomValidity" href="forms.html#dom-cva-setcustomvalidity">setCustomValidity</a>(DOMString error);

  <a data-anolis-xref="dom-object-caller" href="#dom-object-caller">legacycaller</a> any (any... arguments);
};</pre>
    <div class="impl">
    <p>Depending on the type of content instantiated by the
    <code><a href="#the-object-element">object</a></code> element, the node also supports other
    interfaces.</p>
    </div>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-object-element">object</a></code>要素は、リソースの型に応じて、画像として、<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>として、または<a href="infrastructure.html#plugin">プラグイン</a>によって処理される外部リソースとしてのいずれかで扱われる、外部リソースを表すことができる。</p>

  <p><dfn data-anolis-xref="attr-object-data" id="attr-object-data"><code>data</code></dfn>属性は存在する場合、リソースのアドレスを指定する。存在する場合、属性は、<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>でなければならない。</p>

  <p class="warning">信頼しない他の<a data-anolis-xref="origin" href="browsers.html#origin-0">生成元</a>からリソースを参照する著者は、下記に定義される<code data-anolis-xref="attr-object-typemustmatch"><a href="#attr-object-typemustmatch">typemustmatch</a></code>属性を使用するよう促す。その属性がなければ、著者がFlashの"allowScriptAccess"パラメータなどの機能を使用した場合であっても、任意のスクリプトを実行するためにプラグイン機構を使用することは、リモートホスト上の攻撃に対して特定の場合に可能である。</p><!-- for example, if the user doesn't have flash installed but
  does have java installed, and the remote site unexpectedly returns java instead of flash, then
  java will run, and it will ignore the allowScriptAccess thing --> 

  <p><dfn data-anolis-xref="attr-object-type" id="attr-object-type"><code>type</code></dfn>属性が存在する場合、リソースのタイプを指定する。存在する場合、属性は<a href="infrastructure.html#valid-mime-type">妥当なMIMEタイプ</a>でなければならない。</p>

  <p><code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code>属性または<code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code>属性のいずれか一方が少なくとも存在しなければならない。</p>

  <p><code><a href="#the-object-element">object</a></code>要素で<code data-anolis-xref="attr-itemprop">itemprop</code>が指定される場合、<code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code>属性も指定されなければならない。</p>

  <p><dfn data-anolis-xref="attr-object-typemustmatch" id="attr-object-typemustmatch"><code>typemustmatch</code></dfn>属性は、<code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code>属性の値と、前述のリソースの<a href="infrastructure.html#content-type">Content-Type</a>が一致する場合、その存在が<code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code>属性で指定されたリソースにのみ使用されることを示す<a href="infrastructure.html#boolean-attribute">真偽属性</a>である。</p>

  <p><code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code>属性と<code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code>属性の両方が存在する場合を除き、<code data-anolis-xref="attr-object-typemustmatch"><a href="#attr-object-typemustmatch">typemustmatch</a></code>属性を指定してはならない。</p>

  <p><dfn data-anolis-xref="attr-object-name" id="attr-object-name"><code>name</code></dfn>属性が存在する場合、<a href="browsers.html#valid-browsing-context-name">妥当なブラウジングコンテキスト名</a>でなければならない。該当する場合、与えられた値は、<a href="browsers.html#nested-browsing-context">ネストされたブラウジングコンテキスト</a>に名前を付けるために使用される。</p>

  <div class="impl">

  <p>Whenever one of the following conditions occur:</p>

  <ul><li>the element is created,

   

   </li><li>the element is popped off the <a href="syntax.html#stack-of-open-elements">stack of open elements</a> of an <a href="syntax.html#html-parser">HTML
   parser</a> or <a href="the-xhtml-syntax.html#xml-parser">XML parser</a>,

   

   </li><li>the element is not on the <a href="syntax.html#stack-of-open-elements">stack of open elements</a> of an <a href="syntax.html#html-parser">HTML parser</a>
   or <a href="the-xhtml-syntax.html#xml-parser">XML parser</a>, and it is either <a data-anolis-xref="insert an element into a
   document" href="infrastructure.html#insert-an-element-into-a-document">inserted into a document</a> or <a data-anolis-xref="remove an element from a
   document" href="infrastructure.html#remove-an-element-from-a-document">removed from a document</a>,

   

   </li><li>the element's <code><a href="dom.html#document">Document</a></code> changes whether it is <a href="browsers.html#fully-active">fully active</a>,

   

   </li><li>one of the element's ancestor <code><a href="#the-object-element">object</a></code> elements changes to or from showing its
   <a href="dom.html#fallback-content">fallback content</a>,

   

   </li><li>the element's <code data-anolis-xref="attr-object-classid"><a href="obsolete.html#attr-object-classid">classid</a></code> attribute is set, changed, or
   removed,

   

   </li><li>the element's <code data-anolis-xref="attr-object-classid"><a href="obsolete.html#attr-object-classid">classid</a></code> attribute is not present, and
   its <code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> attribute is set, changed, or removed,

   

   </li><li>neither the element's <code data-anolis-xref="attr-object-classid"><a href="obsolete.html#attr-object-classid">classid</a></code> attribute nor its
   <code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> attribute are present, and its <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute is set, changed, or removed,

   

   </li><li>the element changes from <a href="rendering.html#being-rendered">being rendered</a> to not being rendered, or vice versa,

  

  </li></ul><!-- Changing the base URL doesn't trigger this. --><p>...the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to run the following steps to (re)determine
  what the <code><a href="#the-object-element">object</a></code> element represents. This <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a>
  being <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> or actively running must <a href="syntax.html#delay-the-load-event">delay the load
  event</a> of the element's document.  <!--As described in the algorithm, once the algorithm
  starts fetching a resource, the fetch is what starts delaying the load event. But to tide us over
  from when the parser finds the <object> element and the fetching begins, we have to block the load
  event like this, lest the parse end before this task gets run.--></p>

  <ol><li>

    <p>If the user has indicated a preference that this <code><a href="#the-object-element">object</a></code> element's <a href="dom.html#fallback-content">fallback
    content</a> be shown instead of the element's usual behavior, then jump to the step below
    labeled <i>fallback</i>.</p>

    <p class="note">For example, a user could ask for the element's <a href="dom.html#fallback-content">fallback content</a> to
    be shown because that content uses a format that the user finds more accessible.</p>

   </li>

   <li>

    <p>If the element has an ancestor <a href="#media-element">media element</a>, or has an ancestor
    <code><a href="#the-object-element">object</a></code> element that is <em>not</em> showing its <a href="dom.html#fallback-content">fallback content</a>, or
    if the element is not <a data-anolis-xref="in a document" href="infrastructure.html#in-a-document">in a <code>Document</code></a> with a
    <a href="browsers.html#browsing-context">browsing context</a>, or if the element's <code><a href="dom.html#document">Document</a></code> is not <a href="browsers.html#fully-active">fully
    active</a>, or if the element is still in the <a href="syntax.html#stack-of-open-elements">stack of open elements</a> of an
    <a href="syntax.html#html-parser">HTML parser</a> or <a href="the-xhtml-syntax.html#xml-parser">XML parser</a>, or if the element is not <a href="rendering.html#being-rendered">being
    rendered</a>, then jump to the step below labeled <i>fallback</i>.</p>

   </li>

   <li><!-- what if it's not in the document? if that should prevent plugin instantiation, then here
    just skip to the last step -->

    

    <p>If the <code data-anolis-xref="attr-object-classid"><a href="obsolete.html#attr-object-classid">classid</a></code> attribute is present, and has a
    value that isn't the empty string, then: if the user agent can find a <a href="infrastructure.html#plugin">plugin</a>
    suitable according to the value of the <code data-anolis-xref="attr-object-classid"><a href="obsolete.html#attr-object-classid">classid</a></code>
    attribute, and either <a href="#sandboxPluginObject">plugins aren't being sandboxed</a> or that
    <a href="infrastructure.html#plugin">plugin</a> can be <a data-anolis-xref="concept-plugin-secure" href="infrastructure.html#concept-plugin-secure">secured</a>, then that
    <a href="infrastructure.html#plugin">plugin</a> <a href="#object-plugin">should be used</a>, and the value of the <code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> attribute, if any, should be passed to the
    <a href="infrastructure.html#plugin">plugin</a>. If no suitable <a href="infrastructure.html#plugin">plugin</a> can be found, or if the
    <a href="infrastructure.html#plugin">plugin</a> reports an error, jump to the step below labeled <i>fallback</i>.</p><!--
     case insensitive:
      is "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" -> application/x-shockwave-flash
      is "clsid:cfcdaa03-8be4-11cf-b84b-0020afbbccfa" -> audio/x-pn-realaudio-plugin
      is "clsid:02bf25d5-8c17-4b23-bc80-d3488abddc6b" -> video/quicktime
      is "clsid:166b1bca-3f9c-11cf-8075-444553540000" -> application/x-director
      is "clsid:6bf52a52-394a-11d3-b153-00c04f79faa6" -> application/x-mplayer2
      starts with "java:"                             -> application/x-java-vm
      starts with "clsid:"                            -> application/x-oleobject
    -->

    

   </li><!-- (v2?)
   we may have to define magic fallback to <param> if it turns out to
   be needed in testing:
   <hyatt> apparently your url can come from <param>
   <hyatt> not just the data attribute
   <hyatt> our code looks for params with "src", "movie", "code" and "url"
   <hyatt> and also tries to find the type on a param
   <Hixie> oh that's you trying to have hacky activex support
   <Hixie> opera does that too
   <hyatt> yeah we support activex versions of plugins that are common
   <hyatt> like flash and quicktime and realaudio
   <Hixie> that would be a step 1b. if no data attribute, then look for a <param> to get you a URL instead.
   <Hixie> and if you find one, carry on as if that was your data="".
   -->

   

   <li><p>If the <code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> attribute is present and its value is
   not the empty string, then:</p>

    <ol><li><p>If the <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute is present and its value is
     not a type that the user agent supports, and is not a type that the user agent can find a
     <a href="infrastructure.html#plugin">plugin</a> for, then the user agent may jump to the step below labeled <i>fallback</i>
     without fetching the content to examine its real type.</li>

     <li><p><a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">Resolve</a> the <a href="infrastructure.html#url">URL</a> specified by the <code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> attribute, relative to the element.</li>

     <li><p>If that failed, <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the element, then jump to the step below labeled
     <i>fallback</i>.</li>

     <li>

      <p><a href="infrastructure.html#fetch">Fetch</a><!--FETCH-->  the resulting <a href="infrastructure.html#absolute-url">absolute URL</a>, from the element's
      <a href="browsers.html#browsing-context-scope-origin">browsing context scope origin</a> if it has one<!-- potentially http-origin privacy
      sensitive --></p><!-- similar text in various places -->

      
      <p>Fetching the resource must <a href="syntax.html#delay-the-load-event">delay the load event</a> of the element's document
      until the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a
      task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> once the resource has been
      <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> (defined next) has been run.</p>

      <p>For the purposes of the <a href="browsers.html#application-cache">application cache</a> networking model, this
      <a href="infrastructure.html#fetch">fetch</a> operation is not for a <a href="browsers.html#child-browsing-context">child browsing context</a> (though it might
      end up being used for one after all, as defined below).</p>

     </li>

     <li><p>If the resource is not yet available (e.g. because the resource was not available in the
     cache, so that loading the resource required making a request over the network), then jump to
     the step below labeled <i>fallback</i>. The <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is
     <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a> once the
     resource is available must restart this algorithm from this step. Resources can load
     incrementally; user agents may opt to consider a resource "available" whenever enough data has
     been obtained to begin processing the resource.</li>

     <li><p>If the load failed (e.g. there was an HTTP 404 error, there was a DNS error), <a href="webappapis.html#fire-a-simple-event">fire
     a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the element, then jump to
     the step below labeled <i>fallback</i>.</li>

     <li id="object-type-detection">

      <p>Determine the <var data-anolis-xref="">resource type</var>, as follows:</p><!-- Hopefully this step is exactly equivalent to the following:

 START
   |
   V
 Is there a Content-Type and is the UA going to obey it blindly?
   |                   |
   | YES               | NO
   |                   V                                                          YES
   |                 Is there a type="" attribute whose value is a plugin type? ============================================-.
   |                   |                                                                                                     |
   |                   | NO                                                                                                  |
   |                   V                        NO                                       YES                                 |
   |                 Is there a Content type? ========-> Is there a type="" attribute? ==========> Let TYPE be type=""       |
   |                   |                                                           |               attribute value           |
   |                   | YES                                                       | NO                    |                 |
   V            NO     V                                                           |                       V                 |
   +-<============== Is it text/plain or application/octet-stream?                 `==> Let TYPE be  =====>+                 |
   |                   |                                     |                          Sniffed type       |                 |
   |                   | text/plain                          | octet-stream                                V                 |
   |                   V                              YES    V                                          Is TYPE              |
   |                 Does the page sniff as binary? ======> Is there a type="" attribute?       application/octet-stream?    |
   |                   |                                     |              |                      |                |        |
   |                   | NO                                  | YES          | NO                   | YES            | NO     |
   |                   |                                     |       YES    V                      V                |        |
   |                   |                  application/octet-stream? =====> Extension that is plugin type?           |        |
   |                   |                                     |                          |          |                |        |
   |                   |                                     | NO                       | NO       | YES            |        |
   |                   |                                     V                          |          |                |        |
   |                   |                           Type attribute is XML or     YES     V          |                |        |
   |                   |                           doesn't start with image/* ======> FALLBACK     |                |        |
   |                   |                           and is not a plugin type?                       |                |        |
   |                   |                                          |                                |                |        |
   |                   |                                          | NO                             |                |        V
   V                   V                                          V                                V                V       Use
  Use                 Use                                        Use it (will be                  Use              Use      type=""
  Content-Type        text/plain                                 bitmap or plugin)                extension        TYPE     attribute
   |                   |                                          |                                |                |        |
   |                   V                                          V                                V                V        |
   `================->-+========================================>-+==============>-+-<============-+-<==============+-<======'
                                                                                   |
                                                                                   V
                                                                  Continue following rules in the spec, which might
                                                                  result in a plugin, a browsing context, an image,
                                                                  or using fallback, depending on the UA and the type.


   "Extension that is plugin type?" means "Is there an extension that matches one that a plugin supports?".
   Plugins are not allowed to register text/plain or application/octet-stream.

-->



      <ol><li>

        <p>Let the <var data-anolis-xref="">resource type</var> be unknown.</p>

       </li>

       <li>

        <p>If the <code><a href="#the-object-element">object</a></code> element has a <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code>
        attribute and a <code data-anolis-xref="attr-object-typemustmatch"><a href="#attr-object-typemustmatch">typemustmatch</a></code> attribute, and
        the resource has <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">associated Content-Type metadata</a>, and the
        type specified in <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">the resource's Content-Type metadata</a> is
        an <a href="infrastructure.html#ascii-case-insensitive">ASCII case-insensitive</a> match for the value of the element's <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute, then let <var data-anolis-xref="">resource type</var>
        be that type and jump to the step below labeled <i>handler</i>.</p><!-- do we need to <span>strip leading and trailing whitespace</span> from anything here?
        collapse sequences of spaces? drop parameters? -->

        

       </li>

       <li>

        <p>If the <code><a href="#the-object-element">object</a></code> element has a <code data-anolis-xref="attr-object-typemustmatch"><a href="#attr-object-typemustmatch">typemustmatch</a></code> attribute, jump to the step below
        labeled <i>handler</i>.</p>

       </li>

       <li><!-- by request: http://www.w3.org/Bugs/Public/show_bug.cgi?id=8479 -->

        

        <p>If the user agent is configured to strictly obey Content-Type headers for this resource,
        and the resource has <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">associated Content-Type metadata</a>,
        then let the <var data-anolis-xref="">resource type</var> be the type specified in <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">the resource's Content-Type metadata</a>, and jump to the step below
        labeled <i>handler</i>.</p>

        <p class="warning">This can introduce a vulnerability, wherein a site is trying to embed a
        resource that uses a particular plugin, but the remote site overrides that and instead
        furnishes the user agent with a resource that triggers a different plugin with different
        security characteristics.  <!-- e.g. the example given above, where the site is expecting
        Flash with allowScriptAccess=never, and instead gets back Java with its unrestricted DOM
        access --></p>

       </li>

       <li>

        <p>If there is a <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute present on the
        <code><a href="#the-object-element">object</a></code> element, and that attribute's value is not a type that the user agent
        supports, but it <em>is</em> a type that a <a href="infrastructure.html#plugin">plugin</a> supports, then let the <var data-anolis-xref="">resource type</var> be the type specified in that <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute, and jump to the step below labeled
        <i>handler</i>.</p>

       </li>

       <li>

        <p>Run the appropriate set of steps from the following
        list:</p>

        <dl class="switch"><dt>If the resource has <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">associated Content-Type
         metadata</a></dt>

         <dd>

          <ol><li>

            <p>Let <var data-anolis-xref="">binary</var> be false.</p>

           </li>

           <li>

            <p>If the type specified in <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">the resource's Content-Type
            metadata</a> is "<code>text/plain</code>", and the result of applying the <a data-anolis-xref="Content-Type sniffing: text or binary" href="infrastructure.html#content-type-sniffing:-text-or-binary">rules for distinguishing if a resource is
            text or binary</a> to the resource is that the resource is not
            <code>text/plain</code>, then set <var data-anolis-xref="">binary</var> to true.</p>

           </li>

           <li>

            <p>If the type specified in <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">the resource's Content-Type
            metadata</a> is "<code>application/octet-stream</code>", then set <var data-anolis-xref="">binary</var> to true.</p>

           </li>

           <li>

            <p>If <var data-anolis-xref="">binary</var> is false, then let the <var data-anolis-xref="">resource
            type</var> be the type specified in <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">the resource's
            Content-Type metadata</a>, and jump to the step below labeled <i>handler</i>.</p>

           </li>

           <li>

            <p>If there is a <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute present on the
            <code><a href="#the-object-element">object</a></code> element, and its value is not <code>application/octet-stream</code>,
            then run the following steps:</p>

            <ol><li>

              <p>If the attribute's value is a type that a <a href="infrastructure.html#plugin">plugin</a> supports, or the
              attribute's value is a type that starts with "<code>image/</code>" that is not also an
              <a href="infrastructure.html#xml-mime-type">XML MIME type</a>, then let the <var data-anolis-xref="">resource type</var> be the type
              specified in that <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute.</p>

             </li>

             <li>

              <p>Jump to the step below labeled <i>handler</i>.</p>

             </li>

            </ol></li>

          </ol></dd>

         <dt>Otherwise, if the resource does not have <a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">associated
         Content-Type metadata</a></dt>

         <dd>

          <ol><li>

            <p>If there is a <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute present on the
            <code><a href="#the-object-element">object</a></code> element, then let the <var data-anolis-xref="">tentative type</var> be the type
            specified in that <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute.</p>

            <p>Otherwise, let <var data-anolis-xref="">tentative type</var> be the <a data-anolis-xref="content-type
            sniffing" href="infrastructure.html#content-type-sniffing-0">sniffed type of the resource</a>.</p>

           </li>

           <li>

            <p>If <var data-anolis-xref="">tentative type</var> is <em>not</em>
            <code>application/octet-stream</code>, then let <var data-anolis-xref="">resource type</var> be
            <var data-anolis-xref="">tentative type</var> and jump to the step below labeled
            <i>handler</i>.</p>

           </li>

          </ol></dd>

        </dl></li>

       <li><!-- if we get to this point we know we can successfully parsed the URL, since this
        algorithm is only used after fetching the resource in the steps above -->

        

        <p>If applying the <a href="infrastructure.html#url-parser">URL parser</a> algorithm to the <a href="infrastructure.html#url">URL</a> of the
        specified resource (after any redirects) results in a <a href="infrastructure.html#parsed-url">parsed URL</a> whose <a data-anolis-xref="concept-url-path" href="infrastructure.html#concept-url-path">path</a> component matches a pattern that a <a href="infrastructure.html#plugin">plugin</a>
        supports, then let <var data-anolis-xref="">resource type</var> be the type that that plugin can
        handle.</p>

        <p class="example">For example, a plugin might say that it can handle resources with <a data-anolis-xref="concept-url-path" href="infrastructure.html#concept-url-path">path</a> components that end with the four character string
        "<code data-anolis-xref="">.swf</code>".</p><!-- it's sad that we have to do extension sniffing. sigh. --><!-- see also <embed> which has a similar step -->

        
        

       </li>

      </ol><p class="note">It is possible for this step to finish, or for one of the substeps above to
      jump straight to the next step, with <var data-anolis-xref="">resource type</var> still being unknown. In
      both cases, the next step will trigger fallback.</p>

     </li>

     <li><p><i>Handler</i>: Handle the content as given by the first of the following cases that
     matches:</p>

      <dl class="switch"><dt>If the <var data-anolis-xref="">resource type</var> is not a type that the user agent supports, but
       it <em>is</em> a type that a <a href="infrastructure.html#plugin">plugin</a> supports</dt>

       <dd>

        <p>If <a href="#sandboxPluginObject">plugins are being sandboxed</a> and the plugin that
        supports <var data-anolis-xref="">resource type</var> cannot be <a data-anolis-xref="concept-plugin-secure" href="infrastructure.html#concept-plugin-secure">secured</a>, jump to the step below labeled <i>fallback</i>.</p>

        <p>Otherwise, the user agent should <a href="#object-plugin">use the plugin that supports
        <var data-anolis-xref="">resource type</var></a> and pass the content of the resource to that
        <a href="infrastructure.html#plugin">plugin</a>. If the <a href="infrastructure.html#plugin">plugin</a> reports an error, then jump to the step
        below labeled <i>fallback</i>.</p>

       </dd>


       <dt>If the <var data-anolis-xref="">resource type</var> is an <a href="infrastructure.html#xml-mime-type">XML MIME type</a>, or
       
       <!-- (redundant with the next one) if the <var data-x="">resource type</var> is HTML, or -->
       
       if the <var data-anolis-xref="">resource type</var> does not start with "<code>image/</code>"</dt>

       <dd>

        <p>The <code><a href="#the-object-element">object</a></code> element must be associated with a newly created <a href="browsers.html#nested-browsing-context">nested
        browsing context</a>, if it does not already have one.</p>

        <p>If the <a href="infrastructure.html#url">URL</a> of the given resource is not <code><a href="infrastructure.html#about:blank">about:blank</a></code>, the
        element's <a href="browsers.html#nested-browsing-context">nested browsing context</a> must then be <a data-anolis-xref="navigate" href="browsers.html#navigate">navigated</a><!--DONAV object-->  to that resource, with
        <a href="browsers.html#replacement-enabled">replacement enabled</a>, and with the <code><a href="#the-object-element">object</a></code> element's document's
        <a href="browsers.html#browsing-context">browsing context</a> as the <a href="browsers.html#source-browsing-context">source browsing context</a>. (The <code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> attribute of the <code><a href="#the-object-element">object</a></code> element doesn't
        get updated if the browsing context gets further navigated to other locations.)</p>

        <p>If the <a href="infrastructure.html#url">URL</a> of the given resource <em>is</em> <code><a href="infrastructure.html#about:blank">about:blank</a></code>, then,
        instead, the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a>
        named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the <code><a href="#the-object-element">object</a></code> element. <span class="note">No <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> event is fired at the
        <code><a href="infrastructure.html#about:blank">about:blank</a></code> document itself.</span></p>

        <p>The <code><a href="#the-object-element">object</a></code> element <a href="dom.html#represents">represents</a> the <a href="browsers.html#nested-browsing-context">nested browsing
        context</a>.</p>

        <p>If the <code data-anolis-xref="attr-object-name"><a href="#attr-object-name">name</a></code> attribute is present, the
        <a href="browsers.html#browsing-context-name">browsing context name</a> must be set to the value of this attribute; otherwise,
        the <a href="browsers.html#browsing-context-name">browsing context name</a> must be set to the empty string.</p>

        <p class="note">In certain situations, e.g. if the resource was <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a> from an <a href="browsers.html#application-cache">application cache</a> but it is an HTML file
        with a <code data-anolis-xref="attr-html-manifest"><a href="semantics.html#attr-html-manifest">manifest</a></code> attribute that points to a different
        <a data-anolis-xref="concept-appcache-manifest" href="browsers.html#concept-appcache-manifest">application cache manifest</a>, the <a data-anolis-xref="navigate" href="browsers.html#navigate">navigation</a> of the <a href="browsers.html#browsing-context">browsing context</a> will be restarted so
        as to load the resource afresh from the network or a different <a href="browsers.html#application-cache">application
        cache</a>. Even if the resource is then found to have a different type, it is still used
        as part of a <a href="browsers.html#nested-browsing-context">nested browsing context</a>: only the <a href="browsers.html#navigate">navigate</a> algorithm
        is restarted, not this <code><a href="#the-object-element">object</a></code> algorithm.</p><!-- note that malformed XML files don't cause fallback -->

        

       </dd>


       <dt>If the <var data-anolis-xref="">resource type</var> starts with "<code>image/</code>", and support
       for images has not been disabled</dt>

       <dd>

        <p>Apply the <a data-anolis-xref="content-type sniffing: image" href="infrastructure.html#content-type-sniffing:-image">image sniffing</a> rules to
        determine the type of the image.</p>

        <p>The <code><a href="#the-object-element">object</a></code> element <a href="dom.html#represents">represents</a> the specified image. The image is
        not a <a href="browsers.html#nested-browsing-context">nested browsing context</a>.</p>

        <p>If the image cannot be rendered, e.g. because it is malformed or in an unsupported
        format, jump to the step below labeled <i>fallback</i>.</p>

       </dd>


       <dt>そうでなければ</dt>

       <dd>

        <p>The given <var data-anolis-xref="">resource type</var> is not supported. Jump to the step below
        labeled <i>fallback</i>.</p>

        <p class="note">If the previous step ended with the <var data-anolis-xref="">resource type</var> being
        unknown, this is the case that is triggered.</p>

       </dd>

      </dl></li>

     <li><p>The element's contents are not part of what the <code><a href="#the-object-element">object</a></code> element
     represents.</p>

     </li><li>

      <p>Abort these steps. Once the resource is completely loaded, <a href="webappapis.html#queue-a-task">queue a task</a> to
      <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the
      element.</p>

     </li>

    </ol></li>

   <li><p>If the <code data-anolis-xref="attr-object-data"><a href="#attr-object-data">data</a></code> attribute is absent but the <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute is present, and the user agent can find a
   <a href="infrastructure.html#plugin">plugin</a> suitable according to the value of the <code data-anolis-xref="attr-object-type"><a href="#attr-object-type">type</a></code> attribute, and either <a href="#sandboxPluginObject">plugins aren't being sandboxed</a> or the <a href="infrastructure.html#plugin">plugin</a> can be
   <a data-anolis-xref="concept-plugin-secure" href="infrastructure.html#concept-plugin-secure">secured</a>, then that <a href="infrastructure.html#plugin">plugin</a> <a href="#object-plugin">should be used</a>. If these conditions cannot be met, or if the
   <a href="infrastructure.html#plugin">plugin</a> reports an error, jump to the step below labeled <i>fallback</i>. Otherwise
   abort these steps; once the plugin is completely loaded, <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire
   a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the element.</li>

   <li><p><i>Fallback</i>: The <code><a href="#the-object-element">object</a></code> element <a href="dom.html#represents">represents</a> the element's
   children, ignoring any leading <code><a href="#the-param-element">param</a></code> element children. This is the element's
   <a href="dom.html#fallback-content">fallback content</a>. If the element has an instantiated <a href="infrastructure.html#plugin">plugin</a>, then
   unload it.</li>

  </ol><p id="object-plugin">When the algorithm above instantiates a <a href="infrastructure.html#plugin">plugin</a>, the user agent
  should pass to the <a href="infrastructure.html#plugin">plugin</a> used the names and values of all the attributes on the
  element, in the order they were added to the element, with the attributes added by the parser
  being ordered in source order, followed by a parameter named "PARAM" whose value is null, followed
  by all the names and values of <a data-anolis-xref="concept-param-parameter" href="#concept-param-parameter">parameters</a> given by
  <code><a href="#the-param-element">param</a></code> elements that are children of the <code><a href="#the-object-element">object</a></code> element, in <a href="infrastructure.html#tree-order">tree
  order</a>. If the <a href="infrastructure.html#plugin">plugin</a> supports a scriptable interface, the
  <code><a href="#htmlobjectelement">HTMLObjectElement</a></code> object representing the element should expose that interface. The
  <code><a href="#the-object-element">object</a></code> element <a href="dom.html#represents">represents</a> the <a href="infrastructure.html#plugin">plugin</a>. The
  <a href="infrastructure.html#plugin">plugin</a> is not a nested <a href="browsers.html#browsing-context">browsing context</a>.</p>

  <p id="sandboxPluginObject">Plugins are considered sandboxed for the purpose of an
  <code><a href="#the-object-element">object</a></code> element if the <a href="browsers.html#sandboxed-plugins-browsing-context-flag">sandboxed plugins browsing context flag</a> is set on
  the <code><a href="#the-object-element">object</a></code> element's <code><a href="dom.html#document">Document</a></code>'s <a href="browsers.html#active-sandboxing-flag-set">active sandboxing flag
  set</a>.</p>

  <p>Due to the algorithm above, the contents of <code><a href="#the-object-element">object</a></code> elements act as <a href="dom.html#fallback-content">fallback
  content</a>, used only when referenced resources can't be shown (e.g. because it returned a 404
  error). This allows multiple <code><a href="#the-object-element">object</a></code> elements to be nested inside each other,
  targeting multiple user agents with different capabilities, with the user agent picking the first
  one it supports.</p>

  <p>When an <code><a href="#the-object-element">object</a></code> element represents a <a href="browsers.html#nested-browsing-context">nested browsing context</a>: if the
  <code><a href="#the-object-element">object</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>'s <a href="browsers.html#active-document">active document</a>
  is not <a href="syntax.html#ready-for-post-load-tasks">ready for post-load tasks</a>, and when anything is <a data-anolis-xref="delay the load
  event" href="syntax.html#delay-the-load-event">delaying the load event</a> of the <code><a href="#the-object-element">object</a></code> element's <a href="browsers.html#browsing-context">browsing
  context</a>'s <a href="browsers.html#active-document">active document</a>, and when the <code><a href="#the-object-element">object</a></code> element's
  <a href="browsers.html#browsing-context">browsing context</a> is in the <a href="browsers.html#delaying-load-events-mode">delaying <code data-anolis-xref="event-load">load</code>
  events mode</a>, the <code><a href="#the-object-element">object</a></code> must <a href="syntax.html#delay-the-load-event">delay the load event</a> of its
  document.</p>

  <p>The <a href="webappapis.html#task-source">task source</a> for the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> mentioned in this
  section is the <a href="webappapis.html#dom-manipulation-task-source">DOM manipulation task source</a>.</p>

  <p>Whenever the <code data-anolis-xref="attr-object-name"><a href="#attr-object-name">name</a></code> attribute is set, if the
  <code><a href="#the-object-element">object</a></code> element has a nested <a href="browsers.html#browsing-context">browsing context</a>, its <a data-anolis-xref="browsing
  context name" href="browsers.html#browsing-context-name">name</a> must be changed to the new value. If the attribute is removed, if the
  <code><a href="#the-object-element">object</a></code> element has a <a href="browsers.html#browsing-context">browsing context</a>, the <a href="browsers.html#browsing-context-name">browsing context
  name</a> must be set to the empty string.</p>

  </div>

  <p><code><a href="#the-object-element">object</a></code>要素が画像を表すと同時に存在する場合、<code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code>属性は、<a href="#image-map">イメージマップ</a>に関連付けられるオブジェクトを持つことを示すことができる。<span class="impl">The attribute must be ignored if the <code><a href="#the-object-element">object</a></code> element doesn't represent an image.</span></p>

  <p><code data-anolis-xref="attr-fae-form"><a href="forms.html#attr-fae-form">form</a></code>属性は、明示的にその<a href="forms.html#form-owner">フォームの所有者</a>と<code><a href="#the-object-element">object</a></code>要素を関連付けるために使用される。</p>

  <div class="impl">

  <p><strong>Constraint validation</strong>: <code><a href="#the-object-element">object</a></code> elements are always <a href="forms.html#barred-from-constraint-validation">barred
  from constraint validation</a>.</p>

  </div>

  <p><code><a href="#the-object-element">object</a></code>要素は<a href="#dimension-attributes">寸法属性</a>をサポートする。</p>

  <div class="impl">

  <p>The IDL attributes <dfn data-anolis-xref="dom-object-data" id="dom-object-data"><code>data</code></dfn>, <dfn data-anolis-xref="dom-object-type" id="dom-object-type"><code>type</code></dfn> and <dfn data-anolis-xref="dom-object-name" id="dom-object-name"><code>name</code></dfn> each must <a href="infrastructure.html#reflect">reflect</a> the respective
  content attributes of the same name. The <dfn data-anolis-xref="dom-object-typeMustMatch" id="dom-object-typemustmatch"><code>typeMustMatch</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-object-typemustmatch"><a href="#attr-object-typemustmatch">typemustmatch</a></code> content
  attribute. The <dfn data-anolis-xref="dom-object-useMap" id="dom-object-usemap"><code>useMap</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code> content attribute.</p>

  <p>The <dfn data-anolis-xref="dom-object-contentDocument" id="dom-object-contentdocument"><code>contentDocument</code></dfn> IDL attribute
  must return the <code><a href="dom.html#document">Document</a></code> object of the <a href="browsers.html#active-document">active document</a> of the
  <code><a href="#the-object-element">object</a></code> element's <a href="browsers.html#nested-browsing-context">nested browsing context</a>, if any and if its
  <a href="browsers.html#effective-script-origin">effective script origin</a> is the <a href="browsers.html#same-origin">same origin</a> as the <a href="browsers.html#effective-script-origin">effective script
  origin</a> specified by the <a href="webappapis.html#incumbent-settings-object">incumbent settings object</a>, or null otherwise.</p>

  <p>The <dfn data-anolis-xref="dom-object-contentWindow" id="dom-object-contentwindow"><code>contentWindow</code></dfn> IDL attribute must
  return the <code><a href="browsers.html#windowproxy">WindowProxy</a></code> object of the <code><a href="#the-object-element">object</a></code> element's <a href="browsers.html#nested-browsing-context">nested
  browsing context</a>, if it has one; otherwise, it must return null.</p>

  <p>The <code data-anolis-xref="dom-cva-willValidate"><a href="forms.html#dom-cva-willvalidate">willValidate</a></code>, <code data-anolis-xref="dom-cva-validity"><a href="forms.html#dom-cva-validity">validity</a></code>, and <code data-anolis-xref="dom-cva-validationMessage"><a href="forms.html#dom-cva-validationmessage">validationMessage</a></code> attributes, and the <code data-anolis-xref="dom-cva-checkValidity"><a href="forms.html#dom-cva-checkvalidity">checkValidity()</a></code>, <code data-anolis-xref="dom-cva-reportValidity"><a href="forms.html#dom-cva-reportvalidity">reportValidity()</a></code>, and <code data-anolis-xref="dom-cva-setCustomValidity"><a href="forms.html#dom-cva-setcustomvalidity">setCustomValidity()</a></code> methods, are part of the
  <a href="forms.html#the-constraint-validation-api">constraint validation API</a>. The <code data-anolis-xref="dom-fae-form"><a href="forms.html#dom-fae-form">form</a></code> IDL attribute
  is part of the element's forms API.</p>

  <p>All <code><a href="#the-object-element">object</a></code> elements have a <dfn data-anolis-xref="dom-object-caller" id="dom-object-caller">legacy caller
  operation</dfn>. If the <code><a href="#the-object-element">object</a></code> element has an instantiated <a href="infrastructure.html#plugin">plugin</a> that
  supports a scriptable interface that defines a legacy caller operation, then that must be the
  behavior of the object's legacy caller operation. Otherwise, the object's legacy caller operation
  must be to throw a <code><a href="infrastructure.html#notsupportederror">NotSupportedError</a></code> exception.</p>

  </div>

  <div class="example">

   <p>次の例においてJavaアプレットは、<code><a href="#the-object-element">object</a></code>要素を使用してページに埋め込まれている。（一般的に言って、アプリケーションが、サードパーティー製のプラグインを必要とすることなくすべてのウェブブラウザ上で動作するので、機能を提供するためにネイティヴのJavaScriptとHTMLを代わりに使用することで、このようなアプレットの使用を避けることがよりよい。特に組み込み機器は、多くのデバイスでJavaのようなサードパーティのテクノロジーをサポートしない。）</p>

   <pre>&lt;figure&gt;
 &lt;object type="application/x-java-applet"&gt;
  &lt;param name="code" value="MyJavaClass"&gt;
  &lt;p&gt;You do not have Java available, or it is disabled.&lt;/p&gt;
 &lt;/object&gt;
 &lt;figcaption&gt;My Java Clock&lt;/figcaption&gt;
&lt;/figure&gt;</pre>

  </div>

  <div class="example">

   <p>この例において、HTMLページは<code><a href="#the-object-element">object</a></code>要素を使用して埋め込まれている。</p>

   <pre>&lt;figure&gt;
 &lt;object data="clock.html"&gt;&lt;/object&gt;
 &lt;figcaption&gt;My HTML Clock&lt;/figcaption&gt;
&lt;/figure&gt;</pre>

  </div>

  <div class="example">

   <p>次の例は、プラグインが（この場合においてFlashプラグインは、ビデオファイルを表示するために）HTMLで使用できる様子を示す。フォールバックは、Flashが有効でないユーザーに提供される。この場合、<code><a href="#the-video-element">video</a></code>要素の使用は、<code><a href="#the-video-element">video</a></code>をサポートするユーザーエージェントを使用するものに対して動画を表示し、最終的にFlashも<code><a href="#the-video-element">video</a></code>をサポートしないブラウザのどちらも持たない人に対するビデオへのリンクを提供する。</p>

   <pre>&lt;p&gt;Look at my video:
 &lt;object type="application/x-shockwave-flash"&gt;
  &lt;param name=movie value="http://video.example.com/library/watch.swf"&gt;
  &lt;param name=allowfullscreen value=true&gt;
  &lt;param name=flashvars value="http://video.example.com/vids/315981"&gt;
  &lt;video controls src="http://video.example.com/vids/315981"&gt;
   &lt;a href="http://video.example.com/vids/315981"&gt;View video&lt;/a&gt;.
  &lt;/video&gt;
 &lt;/object&gt;
&lt;/p&gt;</pre>

  </div>



  <h4 id="the-param-element"><span class="secno">4.7.9</span> <dfn><code>param</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd>なし。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd>任意の<a href="dom.html#flow-content-1">フローコンテンツ</a>の前の、<code><a href="#the-object-element">object</a></code>要素の子として。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>空。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-param-name"><a href="#attr-param-name">name</a></code> - パラメータ名</dd>
   <dd><code data-anolis-xref="attr-param-value"><a href="#attr-param-value">value</a></code> - パラメータ値</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd><a data-anolis-xref="syntax-end-tag" href="syntax.html#syntax-end-tag">終了タグ</a>なし</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd>なし</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmlparamelement">HTMLParamElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-param-name" href="#dom-param-name">name</a>;
           attribute DOMString <a data-anolis-xref="dom-param-value" href="#dom-param-value">value</a>;
};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-param-element">param</a></code>要素は、<code><a href="#the-object-element">object</a></code>要素によって呼び出されるプラグインのパラメータを定義する。この要素は、自分自身で何かを<a data-anolis-xref="represents" href="dom.html#represents">表す</a>ものではない。</p>

  <p><dfn data-anolis-xref="attr-param-name" id="attr-param-name"><code>name</code></dfn>属性は、パラメータの名前を与える。</p>

  <p><dfn data-anolis-xref="attr-param-value" id="attr-param-value"><code>value</code></dfn>属性は、パラメータの値を与える。</p>

  <p>両方の属性が存在しなければならない。これらは、任意の値を持ってもよい。</p>

  <div class="impl">

  <p>If both attributes are present, and if the parent element of the <code><a href="#the-param-element">param</a></code> is an
  <code><a href="#the-object-element">object</a></code> element, then the element defines a <dfn data-anolis-xref="concept-param-parameter" id="concept-param-parameter">parameter</dfn> with the given name-value pair.</p>

  <p>If either the name or value of a <a data-anolis-xref="concept-param-parameter" href="#concept-param-parameter">parameter</a> defined
  by a <code><a href="#the-param-element">param</a></code> element that is the child of an <code><a href="#the-object-element">object</a></code> element that
  <a href="dom.html#represents">represents</a> an instantiated <a href="infrastructure.html#plugin">plugin</a> changes, and if that
  <a href="infrastructure.html#plugin">plugin</a> is communicating with the user agent using an API that features the ability to
  update the <a href="infrastructure.html#plugin">plugin</a> when the name or value of a <a data-anolis-xref="concept-param-parameter" href="#concept-param-parameter">parameter</a> so changes, then the user agent must
  appropriately exercise that ability to notify the <a href="infrastructure.html#plugin">plugin</a> of the change.</p>

  <p>The IDL attributes <dfn data-anolis-xref="dom-param-name" id="dom-param-name"><code>name</code></dfn> and <dfn data-anolis-xref="dom-param-value" id="dom-param-value"><code>value</code></dfn> must both <a href="infrastructure.html#reflect">reflect</a> the respective
  content attributes of the same name.</p>

  </div>

  <div class="example">

   <p>この場合O3Dプラグインにおいて、<code><a href="#the-param-element">param</a></code>要素が、プラグインにパラメータを渡すために使用する様子を次に示す。</p>

   <pre>&lt;!DOCTYPE HTML&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
   &lt;title&gt;O3D Utah Teapot&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
   &lt;p&gt;
    &lt;object type="application/vnd.o3d.auto"&gt;
     <strong>&lt;param name="o3d_features" value="FloatingPointTextures"&gt;</strong>
     &lt;img src="o3d-teapot.png"
          title="3D Utah Teapot illustration rendered using O3D."
          alt="When O3D renders the Utah Teapot, it appears as a squat
          teapot with a shiny metallic finish on which the
          surroundings are reflected, with a faint shadow caused by
          the lighting."&gt;
     &lt;p&gt;To see the teapot actually rendered by O3D on your
     computer, please download and install the &lt;a
     href="http://code.google.com/apis/o3d/docs/gettingstarted.html#install"&gt;O3D plugin&lt;/a&gt;.&lt;/p&gt;
    &lt;/object&gt;
    &lt;script src="o3d-teapot.js"&gt;&lt;/script&gt;
   &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

  </div><!--TOPIC:Video and Audio-->


  <h4 id="the-video-element"><span class="secno">4.7.10</span> <dfn id="video"><code>video</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>。</dd>
   <dd>要素が<code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code>属性を持つ場合：<a href="dom.html#interactive-content-0">インタラクティブコンテンツ</a>。</dd>
   <dd><a href="dom.html#palpable-content-0">パルパブルコンテンツ</a>。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>が期待される場所。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>要素が<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性を持つ場合：0個以上の<code><a href="#the-track-element">track</a></code>要素で、次に<a href="dom.html#transparent">透過的</a>だが、<a href="#media-element">media要素</a>子孫をもたない。</dd>
   <dd>要素が<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性を持たない場合：0個以上の<code><a href="#the-source-element">source</a></code>要素で、次に0個以上の<code><a href="#the-track-element">track</a></code>で、次に<a href="dom.html#transparent">透過的</a>だが、<a href="#media-element">media要素</a>子孫をもたない。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-media-crossorigin"><a href="#attr-media-crossorigin">crossorigin</a></code> — 要素がcrossorigin要求を処理する方法</dd>
   <dd><code data-anolis-xref="attr-video-poster"><a href="#attr-video-poster">poster</a></code> - 先にビデオプレイバックを見せるポスターフレーム</dd>
   <dd><code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code> - <a href="#media-resource">メディアリソース</a>がどの程度バッファリングに必要になるかのヒント</dd>
   <dd><code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code> - ページが読み込まれる際に<a href="#media-resource">メディアリソース</a>が自動的に開始可能というヒント</dd>
   <dd><code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> - 暗黙の<code><a href="#mediacontroller">MediaController</a></code>をもつ<a data-anolis-xref="media element" href="#media-element">メディア要素</a>グループ</dd>
   <dd><code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code> - <a href="#media-resource">メディアリソース</a>をループするかどうか</dd>
   <dd><code data-anolis-xref="attr-media-muted"><a href="#attr-media-muted">muted</a></code> - デフォルトで<a href="#media-resource">メディアリソース</a>をミュートするかどうか</dd>
   <dd><code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code> - ユーザーエージェントのコントロールを表示する</dd>
   <dd><code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code> - 横の次元</dd>
   <dd><code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code> - 縦の次元</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a></dt>
   <dd>どちらのタグも省略不可</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd><a href="dom.html#index-aria-application"><code title="">application</code></a>.</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dd><a href="dom.html#allowed-aria-roles,-states-and-properties">許可されるロールで受け入れ可能な</a>任意の<code title="">aria-*</code>属性。</dd>
   
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
    <pre class="idl">interface <dfn id="htmlvideoelement">HTMLVideoElement</dfn> : <a href="#htmlmediaelement">HTMLMediaElement</a> {
           attribute unsigned long <a data-anolis-xref="dom-dim-width" href="#dom-dim-width">width</a>;
           attribute unsigned long <a data-anolis-xref="dom-dim-height" href="#dom-dim-height">height</a>;
  readonly attribute unsigned long <a data-anolis-xref="dom-video-videoWidth" href="#dom-video-videowidth">videoWidth</a>;
  readonly attribute unsigned long <a data-anolis-xref="dom-video-videoHeight" href="#dom-video-videoheight">videoHeight</a>;
           attribute DOMString <a data-anolis-xref="dom-video-poster" href="#dom-video-poster">poster</a>;
};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-video-element">video</a></code>要素は字幕付きのビデオやムービー、オーディオファイルを再生するために使用される。</p>

  <p>Content may be provided inside the <code><a href="#the-video-element">video</a></code> element<span class="impl">. User agents
  should not show this content to the user</span>; it is intended for older Web browsers which do
  not support <code><a href="#the-video-element">video</a></code>, so that legacy video plugins can be tried, or to show text to the
  users of these older browsers informing them of how to access the video contents.</p>

  <p class="note">特に、このコンテンツはアクセシビリティーの懸念に対処するためのものではない。弱視、目の見えない、難聴、耳が聞こえない、および他の身体または認知障害を持つ人々へのビデオコンテンツにアクセシブルにするための、さまざまな機能が利用可能である。字幕は、ビデオストリームの埋め込みまたは<code><a href="#the-track-element">track</a></code>要素を使用する外部ファイルとしてのいずれかを提供できる。手話トラックは、ビデオストリームの埋め込みまたは<code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code>属性または<code><a href="#mediacontroller">MediaController</a></code>オブジェクトを使用する、複数の<code><a href="#the-video-element">video</a></code>要素を同期させることのいずれかで提供できる。オーディオの説明は、ビデオストリームに埋め込まれた個別のトラックとして、<code><a href="#the-video-element">video</a></code>要素として同じコントローラに<a data-anolis-xref="slaved media
  elements" href="#slaved-media-elements">スレーブ</a><code><a href="#the-audio-element">audio</a></code>要素での個別のオーディオトラックとして、または<code><a href="#the-track-element">track</a></code>要素を使用して参照され、かつユーザーエージェントによって音声に合成された<a href="infrastructure.html#webvtt-file">WebVTTファイル</a>を使用するテキスト形式でのいずれかとして提供できる。WebVTTはまた、章のタイトルを提供するために使用できる。むしろ一切のメディア要素を使用しないだろうユーザーの場合、複写物またはその他のテキストの選択肢は単に<code><a href="#the-video-element">video</a></code>要素の近くに文でそれらにリンクすることによって提供されうる。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

  <p><code><a href="#the-video-element">video</a></code>要素は<a href="#media-element">media要素</a>であり、その<a href="#media-data">メディアデータ</a>がおそらく関連する音声データをもつ、表面上は映像データである。</p>

  <p><code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>、<code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code>、<code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code>、<code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code>、<code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code>、<code data-anolis-xref="attr-media-muted"><a href="#attr-media-muted">muted</a></code>、および<code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code>属性は、<a data-anolis-xref="media element attributes" href="#media-element-attributes">すべてのメディア要素に共通の属性</a>である。</p>

  <p><dfn data-anolis-xref="attr-video-poster" id="attr-video-poster"><code>poster</code></dfn>属性はビデオデータが利用可能でない間に、ユーザーエージェントが表示できる画像ファイルのアドレスを与える。属性が存在する場合、<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>を含まなければならない。</p>

  <div class="impl">

  <p>If the specified resource is to be used, then, when the element is created or when the <code data-anolis-xref="attr-video-poster"><a href="#attr-video-poster">poster</a></code> attribute is set, changed, or removed, the user agent must
  run the following steps to determine the element's <dfn id="poster-frame">poster frame</dfn> (regardless of the
  value of the element's <a href="#show-poster-flag">show poster flag</a>):</p><!-- thus it is unaffected by changes
  to the base URL. --> 

  <ol><li><p>If there is an existing instance of this algorithm running for this <code><a href="#the-video-element">video</a></code>
   element, abort that instance of this algorithm without changing the <a href="#poster-frame">poster
   frame</a>.</li>

   <li><p>If the <code data-anolis-xref="attr-video-poster"><a href="#attr-video-poster">poster</a></code> attribute's value is the empty string
   or if the attribute is absent, then there is no <a href="#poster-frame">poster frame</a>; abort these
   steps.</li>

   <li><p><a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">Resolve</a> the <code data-anolis-xref="attr-video-poster"><a href="#attr-video-poster">poster</a></code> attribute's value relative to the element. If this fails,
   then there is no <a href="#poster-frame">poster frame</a>; abort these steps.</li>

   <li><p><a href="infrastructure.html#fetch">Fetch</a><!--FETCH-->  the resulting <a href="infrastructure.html#absolute-url">absolute URL</a>, from the element's
   <code><a href="dom.html#document">Document</a></code>'s <a href="browsers.html#origin-0">origin</a>. This must <a href="syntax.html#delay-the-load-event">delay the load event</a> of the
   element's document.</li><!-- could define how to sniff for an image here -->

   

   <li><p>If an image is thus obtained, the <a href="#poster-frame">poster frame</a> is that image. Otherwise,
   there is no <a href="#poster-frame">poster frame</a>.</li>

  </ol></div>

  <p class="note"><code data-anolis-xref="attr-video-poster"><a href="#attr-video-poster">poster</a></code>属性によって与えられた画像、<i><a href="#poster-frame">poster frame</a></i>は、ユーザーに映像がどのようなものであるかのテーマを与える映像の代表フレーム（通常は最初の空白でないフレームの1つ）であることを意図する。</p>

  <div class="impl">

  <hr><p>A <code><a href="#the-video-element">video</a></code> element represents what is given for the first matching condition in the
  list below:</p>

  <dl class="switch"><dt>When no video data is available (the element's <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is either <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, or <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code> but no video data has yet been obtained at
   all, or the element's <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is any
   subsequent value but the <a href="#media-resource">media resource</a> does not have a video channel)</dt>

   <dd>The <code><a href="#the-video-element">video</a></code> element <a href="dom.html#represents">represents</a> its <a href="#poster-frame">poster frame</a>, if any,
   or else transparent black with no intrinsic dimensions.</dd>

   <dt>When the <code><a href="#the-video-element">video</a></code> element is <a data-anolis-xref="dom-media-paused" href="#dom-media-paused">paused</a>, the <a data-anolis-xref="current playback position" href="#current-playback-position">current playback position</a> is the first frame of video,
   and the element's <a href="#show-poster-flag">show poster flag</a> is set</dt>

   <dd>The <code><a href="#the-video-element">video</a></code> element <a href="dom.html#represents">represents</a> its <a href="#poster-frame">poster frame</a>, if any,
   or else the first frame of the video.</dd>

   <dt>When the <code><a href="#the-video-element">video</a></code> element is <a data-anolis-xref="dom-media-paused" href="#dom-media-paused">paused</a>, and the
   frame of video corresponding to the <a data-anolis-xref="current playback position" href="#current-playback-position">current playback
   position</a> is not available (e.g. because the video is seeking or buffering)</dt>

   <dt>When the <code><a href="#the-video-element">video</a></code> element is neither <a href="#potentially-playing">potentially playing</a> nor <a data-anolis-xref="dom-media-paused" href="#dom-media-paused">paused</a> (e.g. when seeking or stalled)</dt>

   <dd>The <code><a href="#the-video-element">video</a></code> element <a href="dom.html#represents">represents</a> the last frame of the video to have
   been rendered.</dd>

   <dt>When the <code><a href="#the-video-element">video</a></code> element is <a data-anolis-xref="dom-media-paused" href="#dom-media-paused">paused</a></dt>

   <dd>The <code><a href="#the-video-element">video</a></code> element <a href="dom.html#represents">represents</a> the frame of video corresponding to
   the <a data-anolis-xref="current playback position" href="#current-playback-position">current playback position</a>.</dd>

   <dt>Otherwise (the <code><a href="#the-video-element">video</a></code> element has a video channel and is <a href="#potentially-playing">potentially
   playing</a>)</dt>

   <dd>The <code><a href="#the-video-element">video</a></code> element <a href="dom.html#represents">represents</a> the frame of video at the continuously
   increasing <a data-anolis-xref="current playback position" href="#current-playback-position">"current" position</a>. When the
   <a href="#current-playback-position">current playback position</a> changes such that the last frame rendered is no longer the
   frame corresponding to the <a href="#current-playback-position">current playback position</a> in the video, the new frame
   must be rendered.</dd>

  </dl><p>Frames of video must be obtained from the video track that was <a data-anolis-xref="dom-VideoTrack-selected" href="#dom-videotrack-selected">selected</a> when the <a href="webappapis.html#event-loop">event loop</a> last reached
  step 1.</p>

  <p class="note">Which frame in a video stream corresponds to a particular playback position is
  defined by the video stream's format.</p>

  <p>The <code><a href="#the-video-element">video</a></code> element also <a href="dom.html#represents">represents</a> any <a data-anolis-xref="text track
  cue" href="#text-track-cue">text track cues</a> whose <a href="#text-track-cue-active-flag">text track cue active flag</a> is set and whose
  <a href="#text-track">text track</a> is in the <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a> mode, and any
  audio from the <a href="#media-resource">media resource</a>, at the <a href="#current-playback-position">current playback position</a>.</p><!--CLEANUP-->


  <p>Any audio associated with the <a href="#media-resource">media resource</a> must, if played, be played
  synchronised with the <a href="#current-playback-position">current playback position</a>, at the element's <a href="#effective-media-volume">effective
  media volume</a>. The user agent must play the audio from audio tracks that were <a data-anolis-xref="dom-AudioTrack-enabled" href="#dom-audiotrack-enabled">enabled</a> when
  the <a href="webappapis.html#event-loop">event loop</a> last reached step 1.</p>

  <p>In addition to the above, the user agent may provide messages to the user (such as "buffering",
  "no video loaded", "error", or more detailed information) by overlaying text or icons on the video
  or other areas of the element's playback area, or in another appropriate manner.</p>

  <p>User agents that cannot render the video may instead make the element <a data-anolis-xref="represents" href="dom.html#represents">represent</a> a link to an external video playback utility or to the video
  data itself.</p>

  <p>When a <code><a href="#the-video-element">video</a></code> element's <a href="#media-resource">media resource</a> has a video channel, the
  element <a href="infrastructure.html#provides-a-paint-source">provides a paint source</a> whose width is the <a href="#media-resource">media resource</a>'s
  <a data-anolis-xref="concept-video-intrinsic-width" href="#concept-video-intrinsic-width">intrinsic width</a>, whose height is the
  <a href="#media-resource">media resource</a>'s <a data-anolis-xref="concept-video-intrinsic-height" href="#concept-video-intrinsic-height">intrinsic
  height</a>, and whose appearance is the frame of video corresponding to the <a data-anolis-xref="current playback position" href="#current-playback-position">current playback position</a>, if that is available, or else
  (e.g. when the video is seeking or buffering) its previous appearance, if any, or else (e.g.
  because the video is still loading the first frame) blackness.</p>

  <hr></div>

  <dl class="domintro"><dt><var data-anolis-xref="">video</var> . <code data-anolis-xref="dom-video-videoWidth"><a href="#dom-video-videowidth">videoWidth</a></code></dt>
   <dt><var data-anolis-xref="">video</var> . <code data-anolis-xref="dom-video-videoHeight"><a href="#dom-video-videoheight">videoHeight</a></code></dt>

   <dd>

    <p>これらの属性はビデオの内在寸法を返し、寸法が未知の場合に0を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="concept-video-intrinsic-width" id="concept-video-intrinsic-width">intrinsic width</dfn> and <dfn data-anolis-xref="concept-video-intrinsic-height" id="concept-video-intrinsic-height">intrinsic height</dfn> of the <a href="#media-resource">media resource</a>
  are the dimensions of the resource in CSS pixels after taking into account the resource's
  dimensions, aspect ratio, clean aperture, resolution, and so forth, as defined for the format used
  by the resource. If an anamorphic format does not define how to apply the aspect ratio to the
  video data's dimensions to obtain the "correct" dimensions, then the user agent must apply the
  ratio by increasing one dimension and leaving the other unchanged.</p>

  <p>The <dfn data-anolis-xref="dom-video-videoWidth" id="dom-video-videowidth"><code>videoWidth</code></dfn> IDL attribute must return
  the <a data-anolis-xref="concept-video-intrinsic-width" href="#concept-video-intrinsic-width">intrinsic width</a> of the video in CSS pixels.
  The <dfn data-anolis-xref="dom-video-videoHeight" id="dom-video-videoheight"><code>videoHeight</code></dfn> IDL attribute must return
  the <a data-anolis-xref="concept-video-intrinsic-height" href="#concept-video-intrinsic-height">intrinsic height</a> of the video in CSS
  pixels. If the element's <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, then the attributes must return 0.</p>

  <p id="dimUpdate">Whenever the <a data-anolis-xref="concept-video-intrinsic-width" href="#concept-video-intrinsic-width">intrinsic width</a>
  or <a data-anolis-xref="concept-video-intrinsic-height" href="#concept-video-intrinsic-height">intrinsic height</a> of the video changes
  (including, for example, because the <a data-anolis-xref="dom-VideoTrack-selected" href="#dom-videotrack-selected">selected video
  track</a> was changed), if the element's <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>
  attribute is not <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, the user agent must
  <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-resize"><a href="#event-media-resize">resize</a></code> at the <a href="#media-element">media element</a>.</p>

  </div>

  <p><code><a href="#the-video-element">video</a></code>要素は、<a href="#dimension-attributes">寸法属性</a>をサポートする。</p>

  <div class="impl">

  <p>In the absence of style rules to the contrary, video content should be rendered inside the
  element's playback area such that the video content is shown centered in the playback area at the
  largest possible size that fits completely within it, with the video content's aspect ratio being
  preserved. Thus, if the aspect ratio of the playback area does not match the aspect ratio of the
  video, the video will be shown letterboxed or pillarboxed. Areas of the element's playback area
  that do not contain the video represent nothing.</p>

  <p class="note">In user agents that implement CSS, the above requirement can be implemented by
  using the <a href="rendering.html#video-object-fit">style rule suggested in the rendering section</a>.</p>

  <p>The intrinsic width of a <code><a href="#the-video-element">video</a></code> element's playback area is the intrinsic width of
  the <a href="#poster-frame">poster frame</a>, if that is available and the element currently
  <a href="dom.html#represents">represents</a> its poster frame; otherwise, it is the <a data-anolis-xref="concept-video-intrinsic-width" href="#concept-video-intrinsic-width">intrinsic width</a> of the video resource, if that is
  available; otherwise the intrinsic width is missing.</p>

  <p>The intrinsic height of a <code><a href="#the-video-element">video</a></code> element's playback area is the intrinsic height of
  the <a href="#poster-frame">poster frame</a>, if that is available and the element currently
  <a href="dom.html#represents">represents</a> its poster frame; otherwise it is the <a data-anolis-xref="concept-video-intrinsic-height" href="#concept-video-intrinsic-height">intrinsic height</a> of the video resource, if that is
  available; otherwise the intrinsic height is missing.</p>

  <p>The <a href="infrastructure.html#default-object-size">default object size</a> is a width of 300 CSS pixels and a height of 150 CSS
  pixels. <a href="references.html#refsCSSIMAGES">[CSSIMAGES]</a></p>

  <hr><p>User agents should provide controls to enable or disable the display of closed captions, audio
  description tracks, and other additional data associated with the video stream, though such
  features should, again, not interfere with the page's normal rendering.</p>

  <p>User agents may allow users to view the video content in manners more suitable to the user
  (e.g. full-screen or in an independent resizable window). As for the other user interface
  features, controls to enable this should not interfere with the page's normal rendering unless the
  user agent is <a data-anolis-xref="expose a user interface to the user" href="#expose-a-user-interface-to-the-user">exposing a user interface</a>.
  In such an independent context, however, user agents may make full user interfaces visible, with,
  e.g., play, pause, seeking, and volume controls, even if the <code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code> attribute is absent.</p>

  <p>User agents may allow video playback to affect system features that could interfere with the
  user's experience; for example, user agents could disable screensavers while video playback is in
  progress.</p>

  <hr><p>The <dfn data-anolis-xref="dom-video-poster" id="dom-video-poster"><code>poster</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-video-poster"><a href="#attr-video-poster">poster</a></code> content attribute.</p>

  </div>

  <div class="example">

   <p>この例は、ビデオを正常に再生するために障害が発生したことを検出する様子を示す：</p>

   <pre>&lt;script&gt;
 function failed(e) {
   // video playback failed - show a message saying why
   switch (e.target.error.code) {
     case e.target.error.MEDIA_ERR_ABORTED:
       alert('You aborted the video playback.');
       break;
     case e.target.error.MEDIA_ERR_NETWORK:
       alert('A network error caused the video download to fail part-way.');
       break;
     case e.target.error.MEDIA_ERR_DECODE:
       alert('The video playback was aborted due to a corruption problem or because the video used features your browser did not support.');
       break;
     case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
       alert('The video could not be loaded, either because the server or network failed or because the format is not supported.');
       break;
     default:
       alert('An unknown error occurred.');
       break;
   }
 }
&lt;/script&gt;
&lt;p&gt;&lt;video src="tgif.vid" autoplay controls onerror="failed(event)"&gt;&lt;/video&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="tgif.vid"&gt;Download the video file&lt;/a&gt;.&lt;/p&gt;</pre>

  </div><!--CODECS

  <div class="impl">

  <h5>Video and audio codecs for <code>video</code> elements</h5>

  <p>User agents may support any video and audio codecs and container formats.</p>

  <p class="note">Certain user agents might support no codecs at all, e.g. text browsers running
  over SSH connections.</p>

  <!- - similar note in audio codecs section - ->
  <p class="note">Implementations are free to implement support for video codecs either natively, or
  using platform-specific APIs, or using plugins: this specification does not specify how codecs are
  to be implemented.</p>

  </div>

  (when replacing this text, also fix "- -" nested comments)-->




  





  <h4 id="the-audio-element"><span class="secno">4.7.11</span> <dfn id="audio"><code>audio</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>。</dd>
   <dd>要素が<code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code>属性を持つ場合：<a href="dom.html#interactive-content-0">インタラクティブコンテンツ</a>。</dd>
   <dd>要素が<code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code>属性を持つ場合：<a href="dom.html#palpable-content-0">パルパブルコンテンツ</a>。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd><a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>が期待される場所。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>要素が<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性を持つ場合：0個以上の<code><a href="#the-track-element">track</a></code>要素で、次に<a href="dom.html#transparent">透過的</a>だが、<a href="#media-element">media要素</a>子孫をもたない。</dd>
   <dd>要素が<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性を持たない場合：0個以上の<code><a href="#the-source-element">source</a></code>要素で、次に0個以上の<code><a href="#the-track-element">track</a></code>で、次に<a href="dom.html#transparent">透過的</a>だが、<a href="#media-element">media要素</a>子孫をもたない。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-media-crossorigin"><a href="#attr-media-crossorigin">crossorigin</a></code> — 要素がcrossorigin要求を処理する方法</dd>
   <dd><code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code> - <a href="#media-resource">メディアリソース</a>がどの程度バッファリングに必要になるかのヒント</dd>
   <dd><code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code> - ページが読み込まれる際に<a href="#media-resource">メディアリソース</a>が自動的に開始可能というヒント</dd>
   <dd><code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> - 暗黙の<code><a href="#mediacontroller">MediaController</a></code>をもつ<a data-anolis-xref="media element" href="#media-element">メディア要素</a>グループ</dd>
   <dd><code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code> - <a href="#media-resource">メディアリソース</a>をループするかどうか</dd>
   <dd><code data-anolis-xref="attr-media-muted"><a href="#attr-media-muted">muted</a></code> - デフォルトで<a href="#media-resource">メディアリソース</a>をミュートするかどうか</dd>
   <dd><code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code> - ユーザーエージェントのコントロールを表示する</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a></dt>
   <dd>どちらのタグも省略不可</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd><a href="dom.html#index-aria-application"><code title="">application</code></a>.</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dd><a href="dom.html#allowed-aria-roles,-states-and-properties">許可されるロールで受け入れ可能な</a>任意の<code title="">aria-*</code>属性。</dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
    <pre class="idl">[NamedConstructor=<a data-anolis-xref="dom-Audio" href="#dom-audio">Audio</a>(optional DOMString src)]
interface <dfn id="htmlaudioelement">HTMLAudioElement</dfn> : <a href="#htmlmediaelement">HTMLMediaElement</a> {};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-audio-element">audio</a></code>要素は、音やオーディオのストリームを<a href="dom.html#represents">表す</a>。</p><!-- v2 (actually v3) suggestions:
    * Audio syntesis. Use cases from Charles Pritchard:
      > Use a sound of varying pitch to hint to a user the location of their
      > mouse (is it hovering over a button, is it x/y pixels away from the edge
      > of the screen, how close is it to the center).
      >
      > Alter the pitch of a sound to make a very cheap midi instrument.
      >
      > Pre-mix a few generated sounds, because the client processor is slow.
      >
      > Alter the pitch of an actual audio recording, and pre-mix it, to give
      > different sounding voices to pre-recorded readings of a single text. As
      > has been tried for "male" "female" sound fonts.
      >
      > Support very simple audio codecs, and programmable synthesizers.
  -->

  

  <p>Content may be provided inside the <code><a href="#the-audio-element">audio</a></code> element<span class="impl">. User agents
  should not show this content to the user</span>; it is intended for older Web browsers which do
  not support <code><a href="#the-audio-element">audio</a></code>, so that legacy audio plugins can be tried, or to show text to the
  users of these older browsers informing them of how to access the audio contents.</p>

  <p class="note">特に、このコンテンツはアクセシビリティーの懸念に対処するためのものではない。聴覚障害、または他の身体または認知障害を持つ人々へのオーディオコンテンツにアクセシブルにするための、さまざまな機能が利用可能である。字幕や手話の映像が使用可能な場合、<code><a href="#the-video-element">video</a></code>要素は、ユーザーが視覚的な選択肢を有効にすることができ、オーディオを再生する<code><a href="#the-audio-element">audio</a></code>要素の代わりに使用できる。章タイトルは、<code><a href="#the-track-element">track</a></code>要素と<a href="infrastructure.html#webvtt-file">WebVTTファイル</a>を使用して、ナビゲーションを補助するために提供できる。そして当然のことながら、複写物またはその他のテキストの選択肢は単に<code><a href="#the-audio-element">audio</a></code>要素の近くに文でそれらにリンクすることによって提供されうる。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

  <p><code><a href="#the-audio-element">audio</a></code>要素は、<a href="#media-data">メディアデータ</a>が表面上は音声データである<a href="#media-element">media要素</a>である。</p>

  <p><code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>、<code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code>、<code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code>、<code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code>、<code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code>、<code data-anolis-xref="attr-media-muted"><a href="#attr-media-muted">muted</a></code>、および<code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code>属性は、<a data-anolis-xref="media element attributes" href="#media-element-attributes">すべてのメディア要素に共通の属性</a>である。</p>

  <div class="impl">

  <p>When an <code><a href="#the-audio-element">audio</a></code> element is <a href="#potentially-playing">potentially playing</a>, it must have its audio
  data played synchronised with the <a href="#current-playback-position">current playback position</a>, at the element's
  <a href="#effective-media-volume">effective media volume</a>. The user agent must play the audio from audio tracks that
  were enabled when the <a href="webappapis.html#event-loop">event loop</a> last reached step 1.</p>

  <p>When an <code><a href="#the-audio-element">audio</a></code> element is not <a href="#potentially-playing">potentially playing</a>, audio must not play
  for the element.</p>

  </div>

  <dl class="domintro"><dt><var data-anolis-xref="">audio</var> = new <code data-anolis-xref="dom-Audio"><a href="#dom-audio">Audio</a></code>( [ <var data-anolis-xref="">url</var> ] )</dt>

   <dd>

    <p>該当する場合、引数で渡された値に設定する<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性とともに、新しい<code><a href="#the-audio-element">audio</a></code>要素を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>A constructor is provided for creating <code><a href="#htmlaudioelement">HTMLAudioElement</a></code> objects (in addition to
  the factory methods from DOM such as <code data-anolis-xref="">createElement()</code>): <dfn data-anolis-xref="dom-Audio" id="dom-audio"><code>Audio(<var data-anolis-xref="">src</var>)</code></dfn>. When invoked as a
  constructor, it must return a new <code><a href="#htmlaudioelement">HTMLAudioElement</a></code> object (a new <code><a href="#the-audio-element">audio</a></code>
  element). The element must be created with its <code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code>
  attribute set to the literal value "<code data-anolis-xref="attr-media-preload-auto"><a href="#attr-media-preload-auto">auto</a></code>". If the
  <var data-anolis-xref="">src</var> argument is present, the object created must be created with its <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> content attribute set to the provided value (this will <a href="#concept-media-load-algorithm-at-creation">cause the user agent to invoke</a> the object's
  <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a> before returning).
  The element's document must be the <a href="browsers.html#active-document">active document</a> of the <a href="browsers.html#browsing-context">browsing
  context</a> of the <code><a href="browsers.html#window">Window</a></code> object on which the interface object of the invoked
  constructor is found.</p>

  </div><!--CODECS

  <div class="impl">

  <h5>Audio codecs for <code>audio</code> elements</h5>

  <p>User agents may support any audio codecs and container formats.</p>

  <p>User agents must support the WAVE container format with audio encoded using the 16 bit PCM (LE)
  codec, at sampling frequencies of 11.025kHz, 22.050kHz, and 44.100kHz, and for both mono and
  stereo. <a href="#- -refsWAVE">[WAVE]</a></p>

  <!- -
   <dt id="- -refsWAVE">WAVE</dt>
   <dd>http://en.wikipedia.org/wiki/WAV? </dd>
  - ->

  <!- - similar note in video codecs section - ->
  <p class="note">Implementations are free to implement support for audio codecs either natively, or
  using platform-specific APIs, or using plugins: this specification does not specify how codecs are
  to be implemented.</p>

  </div>

  (when replacing this text, also fix "- -" nested comments)-->



  



  <h4 id="the-source-element"><span class="secno">4.7.12</span> <dfn><code>source</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd>なし。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd>任意の<a href="dom.html#flow-content-1">フローコンテンツ</a>または<code><a href="#the-track-element">track</a></code>要素の前で、<a href="#media-element">メディア要素</a>の子として。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>空。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-source-src"><a href="#attr-source-src">src</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-source-type"><a href="#attr-source-type">type</a></code> — 埋め込みリソースタイプ</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd><a data-anolis-xref="syntax-end-tag" href="syntax.html#syntax-end-tag">終了タグ</a>なし</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd>なし</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmlsourceelement">HTMLSourceElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-source-src" href="#dom-source-src">src</a>;
           attribute DOMString <a data-anolis-xref="dom-source-type" href="#dom-source-type">type</a>;
};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-source-element">source</a></code>要素は、著者が<a data-anolis-xref="media element" href="#media-element">メディア要素</a>に対する複数の代替<a data-anolis-xref="media resource" href="#media-resource">メディアリソース</a>を指定できる。この要素は、自分自身で何かを<a data-anolis-xref="represents" href="dom.html#represents">表す</a>ものではない。</p>

  <p><dfn data-anolis-xref="attr-source-src" id="attr-source-src"><code>src</code></dfn>属性は、<a href="#media-resource">メディアリソース</a>のアドレスを与える。値は、<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>でなければならない。この属性は存在しなければならない。</p>

  <p class="note">要素が<code><a href="#the-video-element">video</a></code>や<code><a href="#the-audio-element">audio</a></code>要素にすでに挿入されている場合、<code><a href="#the-source-element">source</a></code>要素とその属性を動的に変更しても効果はない。再生している内容を変更するためには、使用可能なリソースの中から選択する<code data-anolis-xref="dom-navigator-canPlayType"><a href="#dom-navigator-canplaytype">canPlayType()</a></code>メソッドをおそらく利用して、直接<a href="#media-element">メディア要素</a>の<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性を単に使用する。一般に、文書が解析された後に手動で<code><a href="#the-source-element">source</a></code>要素を操作することは、不必要に複雑なアプローチとなる。</p>

  <p><dfn data-anolis-xref="attr-source-type" id="attr-source-type"><code>type</code></dfn>属性は、この属性をフェッチする前に、この<a href="#media-resource">メディアリソース</a>を再生できるかどうかをユーザーエージェントが判断するために、<a href="#media-resource">メディアリソース</a>の型を示す。指定された場合、その値は<a href="infrastructure.html#valid-mime-type">妥当なMIMEタイプ</a>でなければならない。特定のMIMEタイプが定義する<code data-anolis-xref="">コーデック</code>パラメータは、リソースがエンコードされる方法を正確に指定する必要があるかもしれない。<a href="references.html#refsRFC4281">[RFC4281]</a></p>

  <div class="example">

   <p>次のリストは、<code data-anolis-xref="attr-source-type"><a href="#attr-source-type">type</a></code>属性で<code data-anolis-xref="">codecs=</code>MIMEパラメータを使用する方法の例を示す。</p>

   <dl><dt>H.264制約ベースラインプロファイルビデオ（メインおよび拡張ビデオ互換性のある）レベル3とMP4コンテナでのLow-Complexity AACオーディオ</dt>
    <dd><pre>&lt;source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'&gt;</pre></dd>

    <dt>H.264拡張プロファイルビデオ（ベースライン対応）レベル3とMP4コンテナでのLow-Complexity AACオーディオ</dt>
    <dd><pre>&lt;source src='video.mp4' type='video/mp4; codecs="avc1.58A01E, mp4a.40.2"'&gt;</pre></dd>

    <dt>H.264メインプロファイルビデオレベル3とMP4コンテナのLow-Complexity AACオーディオ</dt>
    <dd><pre>&lt;source src='video.mp4' type='video/mp4; codecs="avc1.4D401E, mp4a.40.2"'&gt;</pre></dd>

    <dt>H.264 'High'プロフィールビデオ（メイン、ベースライン、または拡張プロファイルと互換性がない）レベル3とMP4コンテナでのLow-Complexity AACオーディオ</dt>
    <dd><pre>&lt;source src='video.mp4' type='video/mp4; codecs="avc1.64001E, mp4a.40.2"'&gt;</pre></dd>


    <dt>MPEG-4ビジュアルのシンプルプロファイルレベル0ビデオとMP4コンテナのLow-Complexity AACオーディオ</dt>
    <dd><pre>&lt;source src='video.mp4' type='video/mp4; codecs="mp4v.20.8, mp4a.40.2"'&gt;</pre></dd>

    <dt>MPEG-4アドバンストシンプルプロファイルレベル0ビデオとMP4コンテナのLow-Complexity AACオーディオ</dt>
    <dd><pre>&lt;source src='video.mp4' type='video/mp4; codecs="mp4v.20.240, mp4a.40.2"'&gt;</pre></dd>

    <dt>MPEG-4映像シンプルプロファイルレベル0ビデオおよび3GPPコンテナ内AMRオーディオ</dt>
    <dd><pre>&lt;source src='video.3gp' type='video/3gpp; codecs="mp4v.20.8, samr"'&gt;</pre></dd>


    <dt>TheoraビデオとOggコンテナでのVorbisオーディオ</dt>
    <dd><pre>&lt;source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'&gt;</pre></dd>

    <dt>TheoraビデオとOggコンテナ内のSpeexオーディオ</dt>
    <dd><pre>&lt;source src='video.ogv' type='video/ogg; codecs="theora, speex"'&gt;</pre></dd>

    <dt>OggコンテナでVorbisオーディオ単独</dt>
    <dd><pre>&lt;source src='audio.ogg' type='audio/ogg; codecs=vorbis'&gt;</pre></dd>

    <dt>Oggコンテナ内のSpeexオーディオ単独</dt>
    <dd><pre>&lt;source src='audio.spx' type='audio/ogg; codecs=speex'&gt;</pre></dd>

    <dt>Oggコンテナ内のFLACオーディオ単独</dt>
    <dd><pre>&lt;source src='audio.oga' type='audio/ogg; codecs=flac'&gt;</pre></dd>

    <dt>DiracビデオとOggコンテナでのVorbisオーディオ</dt>
    <dd><pre>&lt;source src='video.ogv' type='video/ogg; codecs="dirac, vorbis"'&gt;</pre></dd><!-- awaiting definition by the Matroska guys:
    <dt>Theora video and Vorbis audio in Matroska container</dt>
    <dd><pre>&lt;source src='video.mkv' type='video/x-matroska; codecs="theora, vorbis"'></pre></dd>
--><!-- awaiting definition by the Ogg or BBC guys:
    <dt>Dirac video and Vorbis audio in Matroska container</dt>
    <dd><pre>&lt;source src='video.mkv' type='video/x-matroska; codecs='></pre></dd>
--><!-- awaiting definition by the Microsoft guys:
    <dt>WMV9 video and WMA 2 audio in ASF container</dt>
    <dd><pre>&lt;source src='video.wmv' type='video/x-ms-wmv; codecs='></pre></dd>

    <dt>WMV8 video and WMA 2 audio in ASF container</dt>
    <dd><pre>&lt;source src='video.wmv' type='video/x-ms-wmv; codecs='></pre></dd>

    <dt>VC-1 video and WMA 10 Pro audio in ASF container</dt>
    <dd><pre>&lt;source src='video.wmv' type='video/x-ms-wmv; codecs='></pre></dd>

    <dt>XviD video and MP3 audio in AVI container</dt>
    <dd><pre>&lt;source src='video.avi' type='video/x-msvideo; codecs='></pre></dd>

    <dt>Motion-JPEG video and uncompressed PCM audio in AVI container</dt>
    <dd><pre>&lt;source src='video.avi' type='video/x-msvideo; codecs='></pre></dd>
--><!-- awaiting definition by Real:
    <dt>Real Video 10 video and High-Efficiency AAC audio in Real Media container</dt>
    <dd><pre>&lt;source src='video.rm' type='application/vnd.rn-realmedia; codecs='></pre></dd>
--><!--  undefined:
    <dt>MPEG-1 video and MPEG-1 Audio Layer II audio in MPEG-1 program stream</dt>
    <dd><pre>&lt;source src='video.mpg' type='video/mpeg; codecs='></pre></dd>
-->











   </dl></div>

  <div class="impl">

  <p>If a <code><a href="#the-source-element">source</a></code> element is inserted as a child of a <a href="#media-element">media element</a> that
  has no <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute and whose <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> has the value <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>, the user agent must invoke the <a href="#media-element">media
  element</a>'s <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection
  algorithm</a>.</p>

  <p>The IDL attributes <dfn data-anolis-xref="dom-source-src" id="dom-source-src"><code>src</code></dfn> and <dfn data-anolis-xref="dom-source-type" id="dom-source-type"><code>type</code></dfn> must <a href="infrastructure.html#reflect">reflect</a> the respective content
  attributes of the same name.</p>

  </div>

  <div class="example">

   <p>ユーザーエージェントがすべて提供されたメディアリソースをレンダリングすることができるかどうか、著者が確信できない場合、著者は最後の<code><a href="#the-source-element">source</a></code>要素のフォールバック動作に<code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code>イベントをリッスンできる：</p>

   <pre>&lt;script&gt;
 function fallback(video) {
   // replace &lt;video&gt; with its contents
   while (video.hasChildNodes()) {
     if (video.firstChild instanceof HTMLSourceElement)
       video.removeChild(video.firstChild);
     else
       video.parentNode.insertBefore(video.firstChild, video);
   }
   video.parentNode.removeChild(video);
 }
&lt;/script&gt;
&lt;video controls autoplay&gt;
 &lt;source src='video.mp4' type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'&gt;
 &lt;source src='video.ogv' type='video/ogg; codecs="theora, vorbis"'
         onerror="fallback(parentNode)"&gt;
 ...
&lt;/video&gt;</pre>

  </div><!--TOPIC:Video Text Tracks-->



  <h4 id="the-track-element"><span class="secno">4.7.13</span> <dfn><code>track</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd>なし。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd>任意の<a href="dom.html#flow-content-1">フローコンテンツ</a>の前の、<a href="#media-element">メディア要素</a>要素の子として。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>空。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code> - テキストトラックの種類</dd>
   <dd><code data-anolis-xref="attr-track-src"><a href="#attr-track-src">src</a></code> - リソースのアドレス</dd>
   <dd><code data-anolis-xref="attr-track-srclang"><a href="#attr-track-srclang">srclang</a></code> - テキストトラックの言語</dd>
   <dd><code data-anolis-xref="attr-track-label"><a href="#attr-track-label">label</a></code> - ユーザー可視ラベル</dd>
   <dd><code data-anolis-xref="attr-track-default"><a href="#attr-track-default">default</a></code> - 他の<a href="#text-track">テキストトラック</a>がより適切でない場合にトラックを作動させる</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd><a data-anolis-xref="syntax-end-tag" href="syntax.html#syntax-end-tag">終了タグ</a>なし</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd>なし</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmltrackelement">HTMLTrackElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-track-kind" href="#dom-track-kind">kind</a>;
           attribute DOMString <a data-anolis-xref="dom-track-src" href="#dom-track-src">src</a>;
           attribute DOMString <a data-anolis-xref="dom-track-srclang" href="#dom-track-srclang">srclang</a>;
           attribute DOMString <a data-anolis-xref="dom-track-label" href="#dom-track-label">label</a>;
           attribute boolean <a data-anolis-xref="dom-track-default" href="#dom-track-default">default</a>;

  const unsigned short <a data-anolis-xref="dom-track-NONE" href="#dom-track-none">NONE</a> = 0;
  const unsigned short <a data-anolis-xref="dom-track-LOADING" href="#dom-track-loading">LOADING</a> = 1;
  const unsigned short <a data-anolis-xref="dom-track-LOADED" href="#dom-track-loaded">LOADED</a> = 2;
  const unsigned short <a data-anolis-xref="dom-track-ERROR" href="#dom-track-error">ERROR</a> = 3;
  readonly attribute unsigned short <a data-anolis-xref="dom-track-readyState" href="#dom-track-readystate">readyState</a>;

  readonly attribute <a href="#texttrack">TextTrack</a> <a data-anolis-xref="dom-track-track" href="#dom-track-track">track</a>;
};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-track-element">track</a></code>要素は、著者が<a data-anolis-xref="media element" href="#media-element">メディア要素</a>に対して明示的に外部調節された<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>を指定できる。この要素は、自分自身で何かを<a data-anolis-xref="represents" href="dom.html#represents">表す</a>ものではない。</p>

  <p><dfn data-anolis-xref="attr-track-kind" id="attr-track-kind"><code>kind</code></dfn>属性は、<a href="infrastructure.html#enumerated-attribute">列挙属性</a>である。以下の表は、この属性に対して定義されたキーワードを列挙する。各行の最初のセルに与えられるキーワードは、2番目のセルで与えられる状態に対応する。</p>

  <table><thead><tr><th>キーワード
     </th><th>状態
     </th><th>概要
   <tbody></th></tr><tr><td><dfn data-anolis-xref="attr-track-kind-keyword-subtitles" id="attr-track-kind-keyword-subtitles"><code>subtitles</code></dfn>
     </td><td><dfn data-anolis-xref="attr-track-kind-subtitles" id="attr-track-kind-subtitles">Subtitles</dfn>
     </td><td>
      音声が利用可能な場合に適するが、理解できない（ユーザーが<a href="#media-resource">メディアリソース</a>のオーディオトラックの言語を理解していないためなど）対話の翻字または翻訳。ビデオにオーバーレイする。
    </td></tr><tr><td><dfn data-anolis-xref="attr-track-kind-keyword-captions" id="attr-track-kind-keyword-captions"><code>captions</code></dfn>
     </td><td><dfn data-anolis-xref="attr-track-kind-captions" id="attr-track-kind-captions">Captions</dfn>
     </td><td>
      音声が利用できないか、はっきりと聞こえない場合適した（たとえば、無言である、周囲の騒音によってかき消される、またはユーザーが聴覚障害者であるので）、対話の翻字または翻訳、音響効果、関連する音楽の合図、およびその他の関連オーディオ情報。ビデオにオーバーレイし、難聴者に対して適切に表示される。
    </td></tr><tr><td><dfn data-anolis-xref="attr-track-kind-keyword-descriptions" id="attr-track-kind-keyword-descriptions"><code>descriptions</code></dfn>
     </td><td><dfn data-anolis-xref="attr-track-kind-descriptions" id="attr-track-kind-descriptions">概要</dfn>
     </td><td>
      映像コンポーネントが不明瞭、利用できない、または使用可能でない（たとえばユーザーが運転中に画面なしでアプリケーションと情報をやりとりするため、またはユーザーが盲目であるため）際の音声合成に対して意図される、<a href="#media-resource">メディアリソース</a>のビデオコンポーネントのテキスト記述。オーディオとして合成される。
    </td></tr><tr><td><dfn data-anolis-xref="attr-track-kind-keyword-chapters" id="attr-track-kind-keyword-chapters"><code>chapters</code></dfn>
     </td><td><dfn data-anolis-xref="attr-track-kind-chapters" id="attr-track-kind-chapters">Chapters</dfn>
     </td><td>
      <a href="#media-resource">メディアリソース</a>のナビゲートに使用されることを意図した、章のタイトル。ユーザーエージェントのインターフェース内のインタラクティブな（潜在的に入れ子な）リストとして表示される。
    </td></tr><tr><td><dfn data-anolis-xref="attr-track-kind-keyword-metadata" id="attr-track-kind-keyword-metadata"><code>metadata</code></dfn>
     </td><td><dfn data-anolis-xref="attr-track-kind-metadata" id="attr-track-kind-metadata">Metadata</dfn>
     </td><td>
      トラックは、スクリプトから使用するためのものである。ユーザーエージェントによって表示されない。
  </td></tr></table><p>属性は省略してもよい。<i>欠損値のデフォルト</i>は、<a data-anolis-xref="attr-track-kind-subtitles" href="#attr-track-kind-subtitles">subtitles</a>状態である。</p>

  <p><dfn data-anolis-xref="attr-track-src" id="attr-track-src"><code>src</code></dfn>属性はテキストトラックデータのアドレスを与える。値は、<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>でなければならない。この属性は存在しなければならない。</p>

  <div class="impl">

  <p>If the element has a <code data-anolis-xref="attr-track-src"><a href="#attr-track-src">src</a></code> attribute whose value is not the
  empty string and whose value, when the attribute was set, could be successfully <a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">resolved</a> relative to the element, then the element's <dfn id="track-url">track
  URL</dfn> is the resulting <a href="infrastructure.html#absolute-url">absolute URL</a>. Otherwise, the element's <a href="#track-url">track
  URL</a> is the empty string.</p>

  </div>

  <p>要素の<a href="#track-url">トラックURL</a>が<a href="infrastructure.html#webvtt">WebVTT</a>リソースを識別し、その要素の<code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性が<a data-anolis-xref="attr-track-kind-metadata" href="#attr-track-kind-metadata">メタデータ</a>状態でない場合、<a href="infrastructure.html#webvtt">WebVTT</a>ファイルは<a href="infrastructure.html#webvtt-file-using-cue-text">キューテキストを使用したWebVTTファイル</a>でなければならない。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

  <p>さらに、要素の<a href="#track-url">トラックURL</a>が<a href="infrastructure.html#webvtt">WebVTT</a>リソースを識別し、その要素の<code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性が<a data-anolis-xref="attr-track-kind-chapters" href="#attr-track-kind-chapters">chapters</a>状態である場合、<a href="infrastructure.html#webvtt">WebVTT</a>ファイルは<a href="infrastructure.html#webvtt-file-using-chapter-title-text">キューテキストを使用したWebVTTファイル</a>と<a href="infrastructure.html#webvtt-file-using-only-nested-cues">ネストのみされたキューを使用したWebVTTファイル</a>の両方でなければならない。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

  <p><dfn data-anolis-xref="attr-track-srclang" id="attr-track-srclang"><code>srclang</code></dfn>属性は、テキストトラックデータの言語を提供する。値は、妥当なBCP 47言語タグでなければならない。要素の<code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性が<a data-anolis-xref="attr-track-kind-subtitles" href="#attr-track-kind-subtitles">字幕</a>状態である場合、この属性は存在しなければならない。<a href="references.html#refsBCP47">[BCP47]</a></p>

  <div class="impl">

  <p>If the element has a <code data-anolis-xref="attr-track-srclang"><a href="#attr-track-srclang">srclang</a></code> attribute whose value is
  not the empty string, then the element's <dfn id="track-language">track language</dfn> is the value of the attribute.
  Otherwise, the element has no <a href="#track-language">track language</a>.</p>

  </div>

  <p><dfn data-anolis-xref="attr-track-label" id="attr-track-label"><code>label</code></dfn>属性は、トラックのユーザーが読めるタイトルを与える。それらのユーザーインターフェースで<a data-anolis-xref="attr-track-kind-subtitles" href="#attr-track-kind-subtitles">字幕</a>、<a data-anolis-xref="attr-track-kind-captions" href="#attr-track-kind-captions">キャプション</a>、および<a data-anolis-xref="attr-track-kind-descriptions" href="#attr-track-kind-descriptions">音声解説トラック</a>を一覧表示する際に、このタイトルはユーザーエージェントによって使用される。</p>

  <p><code data-anolis-xref="attr-track-label"><a href="#attr-track-label">label</a></code>属性の値は属性が存在する場合、空文字列であってはならない。また、同じ状態にある<code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性の同じ<a href="#media-element">メディア要素</a>に属する2つの<code><a href="#the-track-element">track</a></code>要素の子があってはならず、その<code data-anolis-xref="attr-track-srclang"><a href="#attr-track-srclang">srclang</a></code>は属性が欠落しているか、同じ言語を表す値を持つ、およびその<code data-anolis-xref="attr-track-label"><a href="#attr-track-label">label</a></code>属性が再び両方欠落するか、または両方同じ値を持つかの両方である。</p>

  <div class="impl">

  <p>If the element has a <code data-anolis-xref="attr-track-label"><a href="#attr-track-label">label</a></code> attribute whose value is not
  the empty string, then the element's <dfn id="track-label">track label</dfn> is the value of the attribute.
  Otherwise, the element's <a href="#track-label">track label</a> is an empty string.</p>

  </div>

  <p><dfn data-anolis-xref="attr-track-default" id="attr-track-default"><code>default</code></dfn>属性は<a href="infrastructure.html#boolean-attribute">真偽属性</a>であり、指定された場合に、ユーザーの嗜好が別のトラックがより適切であることを示さない場合、トラックが有効にされることを示す。</p>

  <p>各<a href="#media-element">メディア要素</a>は、<code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性が<a data-anolis-xref="attr-track-kind-subtitles" href="#attr-track-kind-subtitles">subtitles</a>または<a data-anolis-xref="attr-track-kind-captions" href="#attr-track-kind-captions">captions</a>状態かつ<code data-anolis-xref="attr-track-default"><a href="#attr-track-default">default</a></code>属性が指定される<code><a href="#the-track-element">track</a></code>要素の子を複数個持ってはならない。</p>

  <p>各<a href="#media-element">メディア要素</a>は、<code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性が<a data-anolis-xref="attr-track-kind-descriptions" href="#attr-track-kind-descriptions">description</a>状態かつ<code data-anolis-xref="attr-track-default"><a href="#attr-track-default">default</a></code>属性が指定される<code><a href="#the-track-element">track</a></code>要素の子を複数個持ってはならない。</p>

  <p>各<a href="#media-element">メディア要素</a>は、<code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性が<a data-anolis-xref="attr-track-kind-chapters" href="#attr-track-kind-chapters">chapters</a>状態かつ<code data-anolis-xref="attr-track-default"><a href="#attr-track-default">default</a></code>属性が指定される<code><a href="#the-track-element">track</a></code>要素の子を複数個持ってはならない。</p>

  <p class="note"><code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>属性が<a data-anolis-xref="attr-track-kind-metadata" href="#attr-track-kind-metadata">metadata</a>状態かつ<code data-anolis-xref="attr-track-default"><a href="#attr-track-default">default</a></code>属性が指定される<code><a href="#the-track-element">track</a></code>の数に制限は存在しない。</p>

  <dl class="domintro"><dt><var data-anolis-xref="">track</var> . <code data-anolis-xref="dom-track-readyState"><a href="#dom-track-readystate">readyState</a></code></dt>
   <dd>
    <p>以下のリストから番号で表される<a href="#text-track-readiness-state">テキストトラック準備状態</a>を返す：</p>
    <dl><dt><var data-anolis-xref="">track</var> . <code data-anolis-xref="dom-track-NONE"><a href="#dom-track-none">NONE</a></code> (0)</dt>
     <dd>
      <p><a href="#text-track-not-loaded">テキストトラックがロードされない</a>状態。</p>
     </dd>
     <dt><var data-anolis-xref="">track</var> . <code data-anolis-xref="dom-track-LOADING"><a href="#dom-track-loading">LOADING</a></code> (1)</dt>
     <dd>
      <p><a href="#text-track-loading">テキストトラックがロードしている</a>状態。</p>
     </dd>
     <dt><var data-anolis-xref="">track</var> . <code data-anolis-xref="dom-track-LOADED"><a href="#dom-track-loaded">LOADED</a></code> (2)</dt>
     <dd>
      <p><a href="#text-track-loaded">テキストトラックがロードされた</a>状態。</p>
     </dd>
     <dt><var data-anolis-xref="">track</var> . <code data-anolis-xref="dom-track-ERROR"><a href="#dom-track-error">ERROR</a></code> (3)</dt>
     <dd>
      <p><a href="#text-track-failed-to-load">テキストトラックがロードに失敗した</a>状態。</p>
     </dd>
    </dl></dd>

   <dt><var data-anolis-xref="">track</var> . <code data-anolis-xref="dom-track-track"><a href="#dom-track-track">track</a></code></dt>

   <dd>

    <p><code><a href="#the-track-element">track</a></code>要素の<a href="#text-track">テキストトラック</a>に対応する<code><a href="#texttrack">TextTrack</a></code>オブジェクトを返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-track-readyState" id="dom-track-readystate"><code>readyState</code></dfn> attribute must return the
  numeric value corresponding to the <a href="#text-track-readiness-state">text track readiness state</a> of the
  <code><a href="#the-track-element">track</a></code> element's <a href="#text-track">text track</a>, as defined by the following list:</p>

  <dl><dt><dfn data-anolis-xref="dom-track-NONE" id="dom-track-none"><code>NONE</code></dfn> (numeric value 0)</dt>
   <dd><a href="#text-track-not-loaded">テキストトラックがロードされない</a>状態。</dd>
   <dt><dfn data-anolis-xref="dom-track-LOADING" id="dom-track-loading"><code>LOADING</code></dfn> (numeric value 1)</dt>
   <dd><a href="#text-track-loading">テキストトラックがロードしている</a>状態。</dd>
   <dt><dfn data-anolis-xref="dom-track-LOADED" id="dom-track-loaded"><code>LOADED</code></dfn> (numeric value 2)</dt>
   <dd><a href="#text-track-loaded">テキストトラックがロードされた</a>状態。</dd>
   <dt><dfn data-anolis-xref="dom-track-ERROR" id="dom-track-error"><code>ERROR</code></dfn> (numeric value 3)</dt>
   <dd><a href="#text-track-failed-to-load">テキストトラックがロードに失敗した</a>状態。</dd>
  </dl><p>The <dfn data-anolis-xref="dom-track-track" id="dom-track-track"><code>track</code></dfn> IDL attribute must, on getting,
  return the <code><a href="#the-track-element">track</a></code> element's <a href="#text-track">text track</a>'s corresponding
  <code><a href="#texttrack">TextTrack</a></code> object.</p>

  <p>The <dfn data-anolis-xref="dom-track-src" id="dom-track-src"><code>src</code></dfn>, <dfn data-anolis-xref="dom-track-srclang" id="dom-track-srclang"><code>srclang</code></dfn>, <dfn data-anolis-xref="dom-track-label" id="dom-track-label"><code>label</code></dfn>, and <dfn data-anolis-xref="dom-track-default" id="dom-track-default"><code>default</code></dfn> IDL attributes must <a href="infrastructure.html#reflect">reflect</a> the
  respective content attributes of the same name. The <dfn data-anolis-xref="dom-track-kind" id="dom-track-kind"><code>kind</code></dfn> IDL attribute must <a href="infrastructure.html#reflect">reflect</a> the content
  attribute of the same name, <a href="infrastructure.html#limited-to-only-known-values">limited to only known values</a>.</p>

  </div>

  <div class="example">

   <p>このビデオは、複数言語の字幕を持つ：</p>

   <pre>&lt;video src="brave.webm"&gt;
 &lt;track kind=subtitles src=brave.en.vtt srclang=en label="English"&gt;
 &lt;track kind=captions src=brave.en.hoh.vtt srclang=en label="English for the Hard of Hearing"&gt;
 &lt;track kind=subtitles src=brave.fr.vtt srclang=fr lang=fr label="Français"&gt;
 &lt;track kind=subtitles src=brave.de.vtt srclang=de lang=de label="Deutsch"&gt;
&lt;/video&gt;</pre>

   <p>（最後の2つの<code data-anolis-xref="attr-lang"><a href="dom.html#attr-lang">lang</a></code>属性は、字幕自体の言語ではなく、<code data-anolis-xref="attr-track-label"><a href="#attr-track-label">label</a></code>属性の言語を記述する。字幕の言語は<code data-anolis-xref="attr-track-srclang"><a href="#attr-track-srclang">srclang</a></code>属性によって与えられる。）</p>

  </div><!--TOPIC:Video and Audio-->


  <h4 id="media-elements"><span class="secno">4.7.14</span> メディア要素</h4>

  <p><dfn data-anolis-xref="media element" id="media-element">メディア要素</dfn>（この仕様では<code><a href="#the-audio-element">audio</a></code>および<code><a href="#the-video-element">video</a></code>）は次のインターフェースを実装する：</p>

  <pre class="idl">enum <dfn id="canplaytyperesult">CanPlayTypeResult</dfn> { "" /* <a data-anolis-xref="dom-CanPlayTypeResult-nil" href="#dom-canplaytyperesult-nil">empty string</a> */, "<a data-anolis-xref="dom-CanPlayTypeResult-maybe" href="#dom-canplaytyperesult-maybe">maybe</a>", "<a data-anolis-xref="dom-CanPlayTypeResult-probably" href="#dom-canplaytyperesult-probably">probably</a>" };
interface <dfn id="htmlmediaelement">HTMLMediaElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {

  // error state
  readonly attribute <a href="#mediaerror">MediaError</a>? <a data-anolis-xref="dom-media-error" href="#dom-media-error">error</a>;

  // network state
           attribute DOMString <a data-anolis-xref="dom-media-src" href="#dom-media-src">src</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-media-currentSrc" href="#dom-media-currentsrc">currentSrc</a>;
           attribute DOMString <a data-anolis-xref="dom-media-crossOrigin" href="#dom-media-crossorigin">crossOrigin</a>;
  const unsigned short <a data-anolis-xref="dom-media-NETWORK_EMPTY" href="#dom-media-network_empty">NETWORK_EMPTY</a> = 0;
  const unsigned short <a data-anolis-xref="dom-media-NETWORK_IDLE" href="#dom-media-network_idle">NETWORK_IDLE</a> = 1;
  const unsigned short <a data-anolis-xref="dom-media-NETWORK_LOADING" href="#dom-media-network_loading">NETWORK_LOADING</a> = 2;
  const unsigned short <a data-anolis-xref="dom-media-NETWORK_NO_SOURCE" href="#dom-media-network_no_source">NETWORK_NO_SOURCE</a> = 3;
  readonly attribute unsigned short <a data-anolis-xref="dom-media-networkState" href="#dom-media-networkstate">networkState</a>;
           attribute DOMString <a data-anolis-xref="dom-media-preload" href="#dom-media-preload">preload</a>;
<!--v3BUF  readonly attribute double <span data-x="dom-media-bufferingRate">bufferingRate</span>;
  readonly attribute boolean <span data-x="dom-media-bufferingThrottled">bufferingThrottled</span>;
-->  readonly attribute <a href="#timeranges">TimeRanges</a> <a data-anolis-xref="dom-media-buffered" href="#dom-media-buffered">buffered</a>;
  void <a data-anolis-xref="dom-media-load" href="#dom-media-load">load</a>();
  <a href="#canplaytyperesult">CanPlayTypeResult</a> <a data-anolis-xref="dom-navigator-canPlayType" href="#dom-navigator-canplaytype">canPlayType</a>(DOMString type);

  // ready state
  const unsigned short <a data-anolis-xref="dom-media-HAVE_NOTHING" href="#dom-media-have_nothing">HAVE_NOTHING</a> = 0;
  const unsigned short <a data-anolis-xref="dom-media-HAVE_METADATA" href="#dom-media-have_metadata">HAVE_METADATA</a> = 1;
  const unsigned short <a data-anolis-xref="dom-media-HAVE_CURRENT_DATA" href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a> = 2;
  const unsigned short <a data-anolis-xref="dom-media-HAVE_FUTURE_DATA" href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a> = 3;
  const unsigned short <a data-anolis-xref="dom-media-HAVE_ENOUGH_DATA" href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a> = 4;
  readonly attribute unsigned short <a data-anolis-xref="dom-media-readyState" href="#dom-media-readystate">readyState</a>;
  readonly attribute boolean <a data-anolis-xref="dom-media-seeking" href="#dom-media-seeking">seeking</a>;

  // playback state
           attribute double <a data-anolis-xref="dom-media-currentTime" href="#dom-media-currenttime">currentTime</a>;
  void <a data-anolis-xref="dom-media-fastSeek" href="#dom-media-fastseek">fastSeek</a>(double time);
  readonly attribute unrestricted double <a data-anolis-xref="dom-media-duration" href="#dom-media-duration">duration</a>;
  <span>Date</span> <a data-anolis-xref="dom-media-getStartDate" href="#dom-media-getstartdate">getStartDate</a>();
  readonly attribute boolean <a data-anolis-xref="dom-media-paused" href="#dom-media-paused">paused</a>;
           attribute double <a data-anolis-xref="dom-media-defaultPlaybackRate" href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a>;
           attribute double <a data-anolis-xref="dom-media-playbackRate" href="#dom-media-playbackrate">playbackRate</a>;
  readonly attribute <a href="#timeranges">TimeRanges</a> <a data-anolis-xref="dom-media-played" href="#dom-media-played">played</a>;
  readonly attribute <a href="#timeranges">TimeRanges</a> <a data-anolis-xref="dom-media-seekable" href="#dom-media-seekable">seekable</a>;
  readonly attribute boolean <a data-anolis-xref="dom-media-ended" href="#dom-media-ended">ended</a>;
           attribute boolean <a data-anolis-xref="dom-media-autoplay" href="#dom-media-autoplay">autoplay</a>;
           attribute boolean <a data-anolis-xref="dom-media-loop" href="#dom-media-loop">loop</a>;
  void <a data-anolis-xref="dom-media-play" href="#dom-media-play">play</a>();
  void <a data-anolis-xref="dom-media-pause" href="#dom-media-pause">pause</a>();

  // media controller
           attribute DOMString <a data-anolis-xref="dom-media-mediaGroup" href="#dom-media-mediagroup">mediaGroup</a>;
           attribute <a href="#mediacontroller">MediaController</a>? <a data-anolis-xref="dom-media-controller" href="#dom-media-controller">controller</a>;

  // controls
           attribute boolean <a data-anolis-xref="dom-media-controls" href="#dom-media-controls">controls</a>;
           attribute double <a data-anolis-xref="dom-media-volume" href="#dom-media-volume">volume</a>;
           attribute boolean <a data-anolis-xref="dom-media-muted" href="#dom-media-muted">muted</a>;
           attribute boolean <a data-anolis-xref="dom-media-defaultMuted" href="#dom-media-defaultmuted">defaultMuted</a>;

  // tracks
  readonly attribute <a href="#audiotracklist">AudioTrackList</a> <a data-anolis-xref="dom-media-audioTracks" href="#dom-media-audiotracks">audioTracks</a>;
  readonly attribute <a href="#videotracklist">VideoTrackList</a> <a data-anolis-xref="dom-media-videoTracks" href="#dom-media-videotracks">videoTracks</a>;
  readonly attribute <a href="#texttracklist">TextTrackList</a> <a data-anolis-xref="dom-media-textTracks" href="#dom-media-texttracks">textTracks</a>;
  <a href="#texttrack">TextTrack</a> <a data-anolis-xref="dom-media-addTextTrack" href="#dom-media-addtexttrack">addTextTrack</a>(<a href="#texttrackkind">TextTrackKind</a> kind, optional DOMString label = "", optional DOMString language = "");
};</pre>

  <p><dfn id="media-element-attributes">メディア要素の属性</dfn>、<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>、<code data-anolis-xref="attr-media-crossorigin"><a href="#attr-media-crossorigin">crossorigin</a></code>、<code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code>、<code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code>、<code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code>、<code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code>、<code data-anolis-xref="attr-media-muted"><a href="#attr-media-muted">muted</a></code>、および<code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code>は、すべての<a data-anolis-xref="media element" href="#media-element">メディア要素</a>に適用する。これらは、この節で定義される。</p><!-- proposed v2 (actually v3!) features:
    * frame forward / backwards / step(n) while paused
    * per-frame control: get current frame; set current frame
    * queue of content
      - pause current stream and insert content at front of queue to play immediately
      - pre-download another stream
      - add stream(s) to play at end of current stream
      - pause playback upon reaching a certain time
      - playlists, with the ability to get metadata out of them (e.g. xspf)
    * general meta data, implemented as getters (don't expose the whole thing)
      - getMetadata(key: string, language: string) => HTMLImageElement or string
      - onmetadatachanged (no context info)
      - general custom metadata store (ratings, etc.)
    * video: applying CSS filters
    * an event to notify people of when the video size changes
      (e.g. for chained Ogg streams of multiple independent videos)
      (or for when the current video track changes)
    * balance and 3D position audio
    * audio filters
    * audio synthesis (see <audio> section for use cases)
    * feedback to the script on how well the video is playing
       - frames per second?
       - skipped frames per second?
       - an event that reports playback difficulties?
       - an arbitrary quality metric?
    * bufferingRate/bufferingThrottled (see v3BUF)
    * events for when the user agent's controls get shown or hidden
      so that the author's controls can get away of the UA's
  --><!-- v2 features that already have experimental implementations:
    * webkitPreservesPitch (for when playbackRate != 1.0)
  -->

  

  

  <p><a data-anolis-xref="media element" href="#media-element">メディア要素</a>は、音声データ、または映像と音声のデータをユーザーに示すために使用される。この節は音声や映像に対する<a data-anolis-xref="media element" href="#media-element">メディア要素</a>にも同様に適用されるので、これは、この節において<dfn id="media-data">メディアデータ</dfn>と見なされる。用語<dfn id="media-resource">メディアリソース</dfn>は、たとえば完全なビデオファイル、または完全なオーディオファイルなど、メディアデータの完全な集合を参照するために使用される。

  </p><!--CLEANUP-->


  <p><a href="#media-resource">メディアリソース</a>は、複数のオーディオおよびビデオトラックを持つことができる。<a href="#media-element">メディア要素</a>の目的に対して、<a href="#media-resource">メディアリソース</a>の映像データは、<a href="webappapis.html#event-loop">イベントループ</a>がステップ1に到達する際に要素の<code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code>属性で（もしあれば）与えられるように現在選択されるトラックのみであり、かつ<a href="#media-resource">メディアリソース</a>の音声データは、<a href="webappapis.html#event-loop">イベントループ</a>がステップ1に到達する際に（もしあれば）要素の<code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code>属性によって与えられるすべての現在の有効なトラックは、混合の結果である。
</p>

  <p class="note"><code><a href="#the-audio-element">audio</a></code>と<code><a href="#the-video-element">video</a></code>の両方の要素は、オーディオとビデオの両方に使用できる。2つの間の主な違いは、<code><a href="#the-video-element">video</a></code>要素が持つのに対して、<code><a href="#the-audio-element">audio</a></code>要素は、視覚コンテンツ（ビデオやキャプションなど）に対する再生領域を持たないことだけである。</p>

  <div class="impl">

  <p>Except where otherwise explicitly specified, the <a href="webappapis.html#task-source">task source</a> for all the tasks
  <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> in this section and its subsections is the <dfn id="media-element-event-task-source">media
  element event task source</dfn> of the <a href="#media-element">media element</a> in question.</p>

  </div>



  <h5 id="error-codes"><span class="secno">4.7.14.1</span> エラーコード</h5>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code></dt>

   <dd>

    <p>要素の現在のエラー状態を表す<code><a href="#mediaerror">MediaError</a></code>オブジェクトを返す。</p>

    <p>エラーが無い場合nullを返す。</p>

   </dd>

  </dl><div class="impl">

  <p>All <a data-anolis-xref="media element" href="#media-element">media elements</a> have an associated error status, which
  records the last error the element encountered since its <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a> was last invoked. The
  <dfn data-anolis-xref="dom-media-error" id="dom-media-error"><code>error</code></dfn> attribute, on getting, must return the
  <code><a href="#mediaerror">MediaError</a></code> object created for this last error, or null if there has not been an
  error.</p>

  </div>

  <pre class="idl">interface <dfn id="mediaerror">MediaError</dfn> {
  const unsigned short <a data-anolis-xref="dom-MediaError-MEDIA_ERR_ABORTED" href="#dom-mediaerror-media_err_aborted">MEDIA_ERR_ABORTED</a> = 1;
  const unsigned short <a data-anolis-xref="dom-MediaError-MEDIA_ERR_NETWORK" href="#dom-mediaerror-media_err_network">MEDIA_ERR_NETWORK</a> = 2;
  const unsigned short <a data-anolis-xref="dom-MediaError-MEDIA_ERR_DECODE" href="#dom-mediaerror-media_err_decode">MEDIA_ERR_DECODE</a> = 3;
  const unsigned short <a data-anolis-xref="dom-MediaError-MEDIA_ERR_SRC_NOT_SUPPORTED" href="#dom-mediaerror-media_err_src_not_supported">MEDIA_ERR_SRC_NOT_SUPPORTED</a> = 4;
  readonly attribute unsigned short <a data-anolis-xref="dom-MediaError-code" href="#dom-mediaerror-code">code</a>;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code> . <code data-anolis-xref="dom-MediaError-code"><a href="#dom-mediaerror-code">code</a></code></dt>

   <dd>

    <p>下記のリストから、現在のエラーのエラーコードを返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-MediaError-code" id="dom-mediaerror-code"><code>code</code></dfn> attribute of a
  <code><a href="#mediaerror">MediaError</a></code> object must return the code for the error, which must be one of the
  following:</p>

  </div>

  <dl><dt><dfn data-anolis-xref="dom-MediaError-MEDIA_ERR_ABORTED" id="dom-mediaerror-media_err_aborted"><code>MEDIA_ERR_ABORTED</code></dfn>（数値1）</dt>

   <dd><a href="#media-resource">メディアリソース</a>に対するフェッチプロセスが、ユーザーの要求でユーザーエージェントによって中止された。</dd>

   <dt><dfn data-anolis-xref="dom-MediaError-MEDIA_ERR_NETWORK" id="dom-mediaerror-media_err_network"><code>MEDIA_ERR_NETWORK</code></dfn>（数値2）</dt>

   <dd>リソースが使用可能であることが確立された後、一部の説明のネットワークエラーは、ユーザーエージェントに<a href="#media-resource">メディアリソース</a>のフェッチを停止させた。</dd>

   <dt><dfn data-anolis-xref="dom-MediaError-MEDIA_ERR_DECODE" id="dom-mediaerror-media_err_decode"><code>MEDIA_ERR_DECODE</code></dfn>（数値3）</dt>

   <dd>リソースが使用可能であることが確立された後に、<a href="#media-resource">メディアリソース</a>をデコードする間に説明のエラーが発生した。</dd>

   <dt><dfn data-anolis-xref="dom-MediaError-MEDIA_ERR_SRC_NOT_SUPPORTED" id="dom-mediaerror-media_err_src_not_supported"><code>MEDIA_ERR_SRC_NOT_SUPPORTED</code></dfn>（数値4）</dt>

   <dd><code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性で示される<a href="#media-resource">メディアリソース</a>は適さなかった。</dd>

  </dl><h5 id="location-of-the-media-resource"><span class="secno">4.7.14.2</span> メディアリソースの場所</h5>

  <p><a data-anolis-xref="media
  element" href="#media-element">メディア要素</a>の<dfn data-anolis-xref="attr-media-src" id="attr-media-src"><code>src</code></dfn>コンテンツ属性は、表示するメディアリソース（ビデオ、オーディオ）のアドレスを与える。属性が存在する場合、<a href="infrastructure.html#valid-non-empty-url-potentially-surrounded-by-spaces">潜在的にスペースで囲まれた妥当な空でないURL</a>を含まなければならない。</p>

  <p><code data-anolis-xref="attr-itemprop">itemprop</code>が<a href="#media-element">メディア要素</a>要素で指定される場合、<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性も指定されなければならない。</p>

  <p><a data-anolis-xref="media element" href="#media-element">メディア要素</a>上の<dfn data-anolis-xref="attr-media-crossorigin" id="attr-media-crossorigin"><code>crossorigin</code></dfn>コンテンツ属性は、<a href="infrastructure.html#cors-settings-attribute">CORS設定属性</a>である。</p>

  <div class="impl">

  <p id="concept-media-load-algorithm-at-creation">If a <a href="#media-element">media element</a> is created with a
  <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute, the user agent must synchronously invoke the
  <a href="#media-element">media element</a>'s <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection
  algorithm</a>.</p>

  <p>If a <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute of a <a href="#media-element">media element</a> is set
  or changed, the user agent must invoke the <a href="#media-element">media element</a>'s <a href="#media-element-load-algorithm">media element load
  algorithm</a>. (<em>Removing</em> the <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute does
  not do this, even if there are <code><a href="#the-source-element">source</a></code> elements present.)</p>

  <p>The <dfn data-anolis-xref="dom-media-src" id="dom-media-src"><code>src</code></dfn> IDL attribute on <a data-anolis-xref="media
  element" href="#media-element">media elements</a> must <a href="infrastructure.html#reflect">reflect</a> the content attribute of the same
  name.</p>

  <p>The <dfn data-anolis-xref="dom-media-crossOrigin" id="dom-media-crossorigin"><code>crossOrigin</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-media-crossorigin"><a href="#attr-media-crossorigin">crossorigin</a></code> content
  attribute, <a href="infrastructure.html#limited-to-only-known-values">limited to only known values</a>.</p>

  </div>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-currentSrc"><a href="#dom-media-currentsrc">currentSrc</a></code></dt>

   <dd>

    <p>現在の<a href="#media-resource">メディアリソース</a>のアドレスを返す。</p>

    <p><a href="#media-resource">メディアリソース</a>が存在しない場合空文字列を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-currentSrc" id="dom-media-currentsrc"><code>currentSrc</code></dfn> IDL attribute is initially
  the empty string. Its value is changed by the <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource
  selection algorithm</a> defined below.</p>

  </div>

  <p class="note"><a href="#media-resource">メディアリソース</a>、<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性、または<code><a href="#the-source-element">source</a></code>要素を指定する2つの方法がある。属性は要素を上書きする。</p>



  <h5 id="mime-types"><span class="secno">4.7.14.3</span> MIMEタイプ</h5>

  <p><a href="#media-resource">メディアリソース</a>は、<code data-anolis-xref="">codec</code>パラメータをもつ一部の場合において、その<em>タイプ</em>、具体的には<a href="infrastructure.html#mime-type">MIMEタイプ</a>の観点から説明できる。（<code data-anolis-xref="">codec</code>パラメータが許可されるまたはMIMEタイプに依存しないかどうかに関わらない）<a href="references.html#refsRFC4281">[RFC4281]</a></p>

  <p>タイプは、通常多少不完全な記述である。たとえば"<code data-anolis-xref="">video/mpeg</code>"は、コンテナタイプが何であるかを除いて何でも言わず、"<code data-anolis-xref="">video/mp4; codecs="avc1.42E01E, mp4a.40.2"</code>"のような型も実際のビットレート（最大ビットレートのみ）のような情報が含まれない。したがって、タイプを指定されるユーザーエージェントは、（信頼のレベルを変化させた）そのタイプのメディアを再生できる<em>かもしれない</em>かどうか、または間違いなくそのタイプのメディアを再生<em>できない</em>かどうかをたびたび知ることができる。</p>

  <p><dfn id="a-type-that-the-user-agent-knows-it-cannot-render">ユーザーエージェントがレンダリングできないことを認識するタイプ</dfn>は、たとえばコンテナの種類を認識しない、または列挙されたコーデックをサポートしないため、ユーザーエージェントは間違いなくサポートしないことにリソースを記述するものである。</p>

  <p>パラメータのない"<code>application/octet-stream</code>" <a href="infrastructure.html#mime-type">MIMEタイプ</a>は、<a href="#a-type-that-the-user-agent-knows-it-cannot-render">ユーザーエージェントがレンダリングできないことを認識するタイプ</a>にならない。潜在的な<a href="#media-resource">メディアリソース</a>にラベルを付けるために使用される際、ユーザーエージェントは、明示的な<a data-anolis-xref="Content-Type" href="infrastructure.html#content-type">Content-Typeメタデータ</a>の欠如と同等としてそのタイプを扱わなければならない。</p>

  <p class="note">ここでパラメータなしの<a href="infrastructure.html#mime-type">MIMEタイプ</a> "<code>application/octet-stream</code>"は特殊な場合である。任意のパラメータが型に出現する場合、その型は他の<a href="infrastructure.html#mime-type">MIMEタイプ</a>と同じように扱われるだろう。これは、未知の<a href="infrastructure.html#mime-type">MIMEタイプ</a>のパラメータは無視されるべきであるという規則からの逸脱である。</p><!-- but not
  really a "willful violation" since it's not that the types are not being ignored, just that before
  the type is handled as a type, there's a special case for a particular set of strings --> 

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-navigator-canPlayType"><a href="#dom-navigator-canplaytype">canPlayType</a></code>(<var data-anolis-xref="">type</var>)</dt>

   <dd>

    <p>ユーザーエージェントはそれが与えられた型のメディアリソースを再生できる"maybe"、または"probably"方法に基づいて空の文字列（否定応答）を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-navigator-canPlayType" id="dom-navigator-canplaytype"><code>canPlayType(<var data-anolis-xref="">type</var>)</code></dfn> method must return <dfn data-anolis-xref="dom-CanPlayTypeResult-nil" id="dom-canplaytyperesult-nil">the
  empty string</dfn> if <var data-anolis-xref="">type</var> is <a href="#a-type-that-the-user-agent-knows-it-cannot-render">a type that the user agent knows it cannot
  render</a> or is the type "<code>application/octet-stream</code>"; it must return "<dfn data-anolis-xref="dom-CanPlayTypeResult-probably" id="dom-canplaytyperesult-probably"><code>probably</code></dfn>" if the user agent is confident
  that the type represents a <a href="#media-resource">media resource</a> that it can render if used in with this
  <code><a href="#the-audio-element">audio</a></code> or <code><a href="#the-video-element">video</a></code> element; and it must return "<dfn data-anolis-xref="dom-CanPlayTypeResult-maybe" id="dom-canplaytyperesult-maybe"><code>maybe</code></dfn>" otherwise. Implementors are encouraged
  to return "<code data-anolis-xref="dom-CanPlayTypeResult-maybe"><a href="#dom-canplaytyperesult-maybe">maybe</a></code>" unless the type can be
  confidently established as being supported or not. Generally, a user agent should never return
  "<code data-anolis-xref="dom-CanPlayTypeResult-probably"><a href="#dom-canplaytyperesult-probably">probably</a></code>" for a type that allows the <code data-anolis-xref="">codecs</code> parameter if that parameter is not present.</p>

  </div>

  <div class="example">

   <p>このスクリプトは、ユーザーエージェントが動的に<code><a href="#the-video-element">video</a></code>要素またはプラグインを使用するかどうかを決定する（架空の）新たなフォーマットをサポートしているかどうかをテストする。</p>

   <pre>&lt;section id="video"&gt;
 &lt;p&gt;&lt;a href="playing-cats.nfv"&gt;Download video&lt;/a&gt;&lt;/p&gt;
&lt;/section&gt;
&lt;script&gt;
 var videoSection = document.getElementById('video');
 var videoElement = document.createElement('video');
 var support = videoElement.canPlayType('video/x-new-fictional-format;codecs="kittens,bunnies"');
 if (support != "probably" &amp;&amp; "New Fictional Video Plugin" in navigator.plugins) {
   // not confident of browser support
   // but we have a plugin
   // so use plugin instead
   videoElement = document.createElement("embed");
 } else if (support == "") {
   // no support from browser and no plugin
   // do nothing
   videoElement = null;
 }
 if (videoElement) {
   while (videoSection.hasChildNodes())
     videoSection.removeChild(videoSection.firstChild);
   videoElement.setAttribute("src", "playing-cats.nfv");
   videoSection.appendChild(videoElement);
 }
&lt;/script&gt;</pre>

  </div>

  <p class="note"><code><a href="#the-source-element">source</a></code>要素の<code data-anolis-xref="attr-source-type"><a href="#attr-source-type">type</a></code>属性は、ユーザーエージェントがレンダリングできないフォーマットを使用するリソースのダウンロードを回避できる。</p>


  <h5 id="network-states"><span class="secno">4.7.14.4</span> ネットワーク状態</h5>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code></dt>

   <dd>

    <p>下記のリストのコードから、要素に対するネットワーク活動の現在の状態を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>As <a data-anolis-xref="media element" href="#media-element">media elements</a> interact with the network, their current
  network activity is represented by the <dfn data-anolis-xref="dom-media-networkState" id="dom-media-networkstate"><code>networkState</code></dfn> attribute. On getting, it must
  return the current network state of the element, which must be one of the following values:</p>

  </div>

  <dl><dt><dfn data-anolis-xref="dom-media-NETWORK_EMPTY" id="dom-media-network_empty"><code>NETWORK_EMPTY</code></dfn>（数値0）</dt>

   <dd>要素はまだ初期化されていない。すべての属性は、初期状態である。</dd>

   <dt><dfn data-anolis-xref="dom-media-NETWORK_IDLE" id="dom-media-network_idle"><code>NETWORK_IDLE</code></dfn>（数値1）</dt>

   <dd>The element<span class="impl">'s <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource
   selection algorithm</a> is active and</span> has selected a <a data-anolis-xref="media
   resource" href="#media-resource">resource</a>, but it is not actually using the network at this time.</dd>

   <dt><dfn data-anolis-xref="dom-media-NETWORK_LOADING" id="dom-media-network_loading"><code>NETWORK_LOADING</code></dfn>（数値2）</dt>

   <dd>ユーザーエージェントは、積極的にデータをダウンロードしようとしている。</dd>

   <dt><dfn data-anolis-xref="dom-media-NETWORK_NO_SOURCE" id="dom-media-network_no_source"><code>NETWORK_NO_SOURCE</code></dfn>（数値3）</dt>

   <dd>The element<span class="impl">'s <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource
   selection algorithm</a> is active, but it</span> has not yet found a <a data-anolis-xref="media
   resource" href="#media-resource">resource</a> to use.</dd>

  </dl><div class="impl">

  <p>The <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a> defined
  below describes exactly when the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>
  attribute changes value and what events fire to indicate changes in this state.</p>

  </div>




  <h5 id="loading-the-media-resource"><span class="secno">4.7.14.5</span> メディアリソースの読み込み</h5>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-load"><a href="#dom-media-load">load</a></code>()</dt>

   <dd>

    <p>要素をリセットさせ、最初から新しい<a href="#media-resource">メディアリソース</a>の選択と読み込みを開始させる。</p>

   </dd>

  </dl><div class="impl">

  <p>All <a data-anolis-xref="media element" href="#media-element">media elements</a> have an <dfn id="autoplaying-flag">autoplaying flag</dfn>,
  which must begin in the true state, and a <dfn id="delaying-the-load-event-flag">delaying-the-load-event flag</dfn>, which must
  begin in the false state. While the <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> is true, the element
  must <a href="syntax.html#delay-the-load-event">delay the load event</a> of its document.</p>

  <p>When the <dfn data-anolis-xref="dom-media-load" id="dom-media-load"><code>load()</code></dfn> method on a <a href="#media-element">media
  element</a> is invoked, the user agent must run the <a href="#media-element-load-algorithm">media element load
  algorithm</a>.</p>

  <p>The <dfn id="media-element-load-algorithm">media element load algorithm</dfn> consists of the following steps.</p>

  <ol><li><p>Abort any already-running instance of the <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a> for this
   element.</li>

   <li>

    <p>If there are any <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> from the <a href="#media-element">media
    element</a>'s <a href="#media-element-event-task-source">media element event task source</a> in one of the <a data-anolis-xref="task
    queue" href="webappapis.html#task-queue">task queues</a>, then remove those tasks.</p><!--
    <p>If there are any <span data-x="concept-task">tasks</span> that were <span data-x="queue a
    task">queued</span> by the <span data-x="concept-media-load-algorithm">resource selection
    algorithm</span> (including the algorithms that it itself invokes) for this same <span>media
    element</span> from the <span>DOM manipulation task source</span> in one of the <span
    data-x="task queue">task queues</span>, then remove those tasks.</p>
-->



    <p class="note">Basically, pending events and callbacks for the media element are discarded when
    the media element starts loading a new resource.</p>

   </li>

   <li><p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> is set to <code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code> or <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code>, <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a
   simple event</a> named <code data-anolis-xref="event-media-abort"><a href="#event-media-abort">abort</a></code> at the <a href="#media-element">media
   element</a>.</li>

   <li>

    <p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>
    is not set to <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>, then run these
    substeps:</p>

    <ol><li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-emptied"><a href="#event-media-emptied">emptied</a></code> at the <a href="#media-element">media element</a>.</li>

     <li><p>If a fetching process is in progress for the <a href="#media-element">media
     element</a>, the user agent should stop it.</li><!--(no point doing this, since we always call the resource selection algorithm synchronously
     at the end of this algorithm, and that switches it to NETWORK_NO_SOURCE and sets the flag)
     <li><p>Set the <code data-x="dom-media-networkState">networkState</code> attribute to <code
     data-x="dom-media-NETWORK_EMPTY">NETWORK_EMPTY</code>.</p></li>
     <li><p>Set the element's <span>show poster flag</span> to true.</p></li>
     -->

     

     <li><p><a href="#forget-the-media-element's-media-resource-specific-tracks">Forget the media element's media-resource-specific tracks</a>.</li>

     <li><p>If <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> is not set to <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, then set it to that state.
     
     <!-- this can do the "report the controller state" thing -->
     </li>

     <li><p>If the <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is false, then set it to
     true.</li>

     <li><p>If <code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code> is true, set it to false.</li>

     <li>

      <p>Set the <a href="#current-playback-position">current playback position</a> to 0.</p>

      <p>Set the <a href="#official-playback-position">official playback position</a> to 0.</p>

      <p>If this changed the <a href="#official-playback-position">official playback position</a>, then <a href="webappapis.html#queue-a-task">queue a task</a>
      to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the <a href="#media-element">media element</a>.</p>

     </li>

     <li><p>Set the <a href="#initial-playback-position">initial playback position</a> to 0.</li>

     <li><p>Set the <a href="#timeline-offset">timeline offset</a> to Not-a-Number (NaN).</li>

     <li>

      <p>Update the <code data-anolis-xref="dom-media-duration"><a href="#dom-media-duration">duration</a></code> attribute to Not-a-Number
      (NaN).</p>

      <p class="note">The user agent <a href="#durationChange">will not</a> fire a <code data-anolis-xref="event-media-durationchange"><a href="#event-media-durationchange">durationchange</a></code> event for this particular change of
      the duration.</p>

     </li>

    </ol></li>

   <li><p>Set the <code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate">playbackRate</a></code> attribute to the value of
   the <code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a></code> attribute.</li>

   <li><p>Set the <code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code> attribute to null and the
   <a href="#autoplaying-flag">autoplaying flag</a> to true.</li>

   <li><p>Invoke the <a href="#media-element">media element</a>'s <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a>.</li>

   <li>

    <p class="note">Playback of any previously playing <a href="#media-resource">media resource</a> for this element
    stops.</p>

   </li>

  </ol><p>The <dfn data-anolis-xref="concept-media-load-algorithm" id="concept-media-load-algorithm">resource selection algorithm</dfn> for a
  <a href="#media-element">media element</a> is as follows. This algorithm is always invoked synchronously, but one
  of the first steps in the algorithm is to return and continue running the remaining steps
  asynchronously, meaning that it runs in the background with scripts and other <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> running in parallel. In addition, this algorithm interacts
  closely with the <a href="webappapis.html#event-loop">event loop</a> mechanism; in particular, it has <a data-anolis-xref="synchronous
  section" href="webappapis.html#synchronous-section">synchronous sections</a> (which are triggered as part of the <a href="webappapis.html#event-loop">event loop</a>
  algorithm). Steps in such sections are marked with ⌛.</p>

  <ol><!-- precondition: networkState == NETWORK_EMPTY or we're coming straight from the algorithm above
                      (where setting it to empty is commented out) --><li><p>Set the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute to
   the <code data-anolis-xref="dom-media-NETWORK_NO_SOURCE"><a href="#dom-media-network_no_source">NETWORK_NO_SOURCE</a></code> value.</li>

   <li><p>Set the element's <a href="#show-poster-flag">show poster flag</a> to true.</li>

   <li><p>Set the <a href="#media-element">media element</a>'s <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> to true
   (this <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delays the load event</a>).</li>

   <li><p>Asynchronously <a href="webappapis.html#await-a-stable-state">await a stable state</a>, allowing the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that invoked this algorithm to continue. The <a href="webappapis.html#synchronous-section">synchronous
   section</a> consists of all the remaining steps of this algorithm until the algorithm says the
   <a href="webappapis.html#synchronous-section">synchronous section</a> has ended. (Steps in <a data-anolis-xref="synchronous
   section" href="webappapis.html#synchronous-section">synchronous sections</a> are marked with ⌛.)</li>

   <li>

    <p>⌛ If the <a href="#media-element">media element</a>'s <a href="#blocked-on-parser">blocked-on-parser</a> flag is false,
    then <a href="#populate-the-list-of-pending-text-tracks">populate the list of pending text tracks</a>.</p>

   </li>

   <li>

    <p>⌛ If the <a href="#media-element">media element</a> has a <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>
    attribute, then let <var data-anolis-xref="">mode</var> be <i data-anolis-xref="">attribute</i>.</p>

    <p>⌛ Otherwise, if the <a href="#media-element">media element</a> does not have a <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute but has a <code><a href="#the-source-element">source</a></code> element child, then
    let <var data-anolis-xref="">mode</var> be <i data-anolis-xref="">children</i> and let <var data-anolis-xref="">candidate</var>
    be the first such <code><a href="#the-source-element">source</a></code> element child in <a href="infrastructure.html#tree-order">tree order</a>.</p>

    <p>⌛ Otherwise the <a href="#media-element">media element</a> has neither a <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute nor a <code><a href="#the-source-element">source</a></code> element child: set the
    <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code><!-- no need to set the <span>show poster
    flag</span> to true since we set it up there already -->, and abort these steps; the
    <a href="webappapis.html#synchronous-section">synchronous section</a> ends.</p>

   </li>

   <li><p>⌛ Set the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>.</li>

   <li><p>⌛ <a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-loadstart"><a href="#event-media-loadstart">loadstart</a></code> at the <a href="#media-element">media element</a>.</li>

   <li>

    <p>If <var data-anolis-xref="">mode</var> is <i data-anolis-xref="">attribute</i>, then run these substeps:</p>

    <ol><li><p>⌛ If the <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>
     attribute's value is the empty string, then end the <a href="webappapis.html#synchronous-section">synchronous section</a>, and jump
     down to the <i data-anolis-xref="">failed with attribute</i> step below.</li>

     <li><p>⌛ Let <var data-anolis-xref="">absolute URL</var> be the <a href="infrastructure.html#absolute-url">absolute URL</a> that
     would have resulted from <a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">resolving</a> the <a href="infrastructure.html#url">URL</a>
     specified by the <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute's value relative to the
     <a href="#media-element">media element</a> when the <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute was last
     changed.</p><!-- i.e. changing xml:base or <base> after src="" has no effect --> 

     </li><li><p>⌛ If <var data-anolis-xref="">absolute URL</var> was obtained successfully, set the <code data-anolis-xref="dom-media-currentSrc"><a href="#dom-media-currentsrc">currentSrc</a></code> attribute to <var data-anolis-xref="">absolute
     URL</var>.</li>

     <li><p>End the <a href="webappapis.html#synchronous-section">synchronous section</a>, continuing the remaining steps
     asynchronously.</li>

     <li><p>If <var data-anolis-xref="">absolute URL</var> was obtained successfully, run the <a data-anolis-xref="concept-media-load-resource" href="#concept-media-load-resource">resource fetch algorithm</a> with <var data-anolis-xref="">absolute
     URL</var>. If that algorithm returns without aborting <em>this</em> one, then the load
     failed.</li>

     <li>

      <p><i data-anolis-xref="">Failed with attribute</i>: Reaching this step indicates that the media resource
      failed to load or that the given <a href="infrastructure.html#url">URL</a> could not be <a data-anolis-xref="resolve a
      url" href="infrastructure.html#resolve-a-url">resolved</a>. <a href="webappapis.html#queue-a-task">Queue a task</a> to run the following steps:</p>

      <ol><li><p>Set the <code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code> attribute to a new
       <code><a href="#mediaerror">MediaError</a></code> object whose <code data-anolis-xref="dom-MediaError-code"><a href="#dom-mediaerror-code">code</a></code> attribute
       is set to <code data-anolis-xref="dom-MediaError-MEDIA_ERR_SRC_NOT_SUPPORTED"><a href="#dom-mediaerror-media_err_src_not_supported">MEDIA_ERR_SRC_NOT_SUPPORTED</a></code>.</li>

       <li><p><a href="#forget-the-media-element's-media-resource-specific-tracks">Forget the media element's media-resource-specific tracks</a>.</li>

       <li><p>Set the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute
       to the <code data-anolis-xref="dom-media-NETWORK_NO_SOURCE"><a href="#dom-media-network_no_source">NETWORK_NO_SOURCE</a></code> value.</li>

       <li><p>Set the element's <a href="#show-poster-flag">show poster flag</a> to true.</li>

       <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> named <code data-anolis-xref="event-media-error"><a href="#event-media-error">error</a></code> at
       the <a href="#media-element">media element</a>.</li>

       <li><p>Set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> to false. This stops <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load event</a>.</li>

      </ol></li>

     <li><p>Wait for the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> queued by the previous step to have
     executed.</li>

     <li><p>Abort these steps. Until the <code data-anolis-xref="dom-media-load"><a href="#dom-media-load">load()</a></code> method is
     invoked or the <code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code> attribute is changed, the element won't
     attempt to load another resource.</li><!-- it took its ball and went home, sulking. -->
     

    </ol><p>Otherwise, the <code><a href="#the-source-element">source</a></code> elements will be used; run these substeps:</p>

    <ol><li>

      <p>⌛ Let <var data-anolis-xref="">pointer</var> be a position defined by two adjacent nodes in the
      <a href="#media-element">media element</a>'s child list, treating the start of the list (before the first
      child in the list, if any) and end of the list (after the last child in the list, if any) as
      nodes in their own right. One node is the node before <var data-anolis-xref="">pointer</var>, and the
      other node is the node after <var data-anolis-xref="">pointer</var>. Initially, let <var data-anolis-xref="">pointer</var> be the position between the <var data-anolis-xref="">candidate</var> node and the
      next node, if there are any, or the end of the list, if it is the last node.</p>

      <p>As nodes are inserted and removed into the <a href="#media-element">media element</a>, <var data-anolis-xref="">pointer</var> must be updated as follows:</p>

      <dl><dt>If a new node is inserted between the two nodes that define <var data-anolis-xref="">pointer</var></dt>

       <dd>Let <var data-anolis-xref="">pointer</var> be the point between the node before <var data-anolis-xref="">pointer</var> and the new node. In other words, insertions at <var data-anolis-xref="">pointer</var> go after <var data-anolis-xref="">pointer</var>.</dd>

       <dt>If the node before <var data-anolis-xref="">pointer</var> is removed</dt>

       <dd>Let <var data-anolis-xref="">pointer</var> be the point between the node after <var data-anolis-xref="">pointer</var> and the node before the node after <var data-anolis-xref="">pointer</var>. In
       other words, <var data-anolis-xref="">pointer</var> doesn't move relative to the remaining nodes.</dd>

       <dt>If the node after <var data-anolis-xref="">pointer</var> is removed</dt>

       <dd>Let <var data-anolis-xref="">pointer</var> be the point between the node before <var data-anolis-xref="">pointer</var> and the node after the node before <var data-anolis-xref="">pointer</var>. Just
       as with the previous case, <var data-anolis-xref="">pointer</var> doesn't move relative to the remaining
       nodes.</dd>

      </dl><p>Other changes don't affect <var data-anolis-xref="">pointer</var>.</p>

     </li>

     <li><p>⌛ <i>Process candidate</i>: If <var data-anolis-xref="">candidate</var> does not have a
     <code data-anolis-xref="attr-source-src"><a href="#attr-source-src">src</a></code> attribute, or if its <code data-anolis-xref="attr-source-src"><a href="#attr-source-src">src</a></code> attribute's value is the empty string, then end the
     <a href="webappapis.html#synchronous-section">synchronous section</a>, and jump down to the <i data-anolis-xref="">failed with elements</i> step
     below.</li>

     <li><p>⌛ Let <var data-anolis-xref="">absolute URL</var> be the <a href="infrastructure.html#absolute-url">absolute URL</a> that
     would have resulted from <a data-anolis-xref="resolve a url" href="infrastructure.html#resolve-a-url">resolving</a> the <a href="infrastructure.html#url">URL</a>
     specified by <var data-anolis-xref="">candidate</var>'s <code data-anolis-xref="attr-source-src"><a href="#attr-source-src">src</a></code>
     attribute's value relative to the <var data-anolis-xref="">candidate</var> when the <code data-anolis-xref="attr-source-src"><a href="#attr-source-src">src</a></code> attribute was last changed.</p><!-- i.e. changing xml:base
     or <base> after src="" has no effect --> 

     </li><li><p>⌛ If <var data-anolis-xref="">absolute URL</var> was not obtained successfully, then end the
     <a href="webappapis.html#synchronous-section">synchronous section</a>, and jump down to the <i data-anolis-xref="">failed with elements</i> step
     below.</li>

     <li><p>⌛ If <var data-anolis-xref="">candidate</var> has a <code data-anolis-xref="attr-source-type"><a href="#attr-source-type">type</a></code> attribute whose value, when parsed as a <a href="infrastructure.html#mime-type">MIME
     type</a> (including any codecs described by the <code data-anolis-xref="">codecs</code> parameter, for
     types that define that parameter), represents <a href="#a-type-that-the-user-agent-knows-it-cannot-render">a type that the user agent knows it cannot
     render</a>, then end the <a href="webappapis.html#synchronous-section">synchronous section</a>, and jump down to the <i data-anolis-xref="">failed with elements</i> step below.</li>

     <li><p>⌛ Set the <code data-anolis-xref="dom-media-currentSrc"><a href="#dom-media-currentsrc">currentSrc</a></code> attribute to <var data-anolis-xref="">absolute URL</var>.</li>

     <li><p>End the <a href="webappapis.html#synchronous-section">synchronous section</a>, continuing the remaining steps
     asynchronously.</li>

     <li><p>Run the <a data-anolis-xref="concept-media-load-resource" href="#concept-media-load-resource">resource fetch algorithm</a> with
     <var data-anolis-xref="">absolute URL</var>. If that algorithm returns without aborting <em>this</em> one,
     then the load failed.</li>

     <li><p><i data-anolis-xref="">Failed with elements</i>: <a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
     event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <var data-anolis-xref="">candidate</var> element.</li>

     <li><p>Asynchronously <a href="webappapis.html#await-a-stable-state">await a stable state</a>. The <a href="webappapis.html#synchronous-section">synchronous section</a>
     consists of all the remaining steps of this algorithm until the algorithm says the
     <a href="webappapis.html#synchronous-section">synchronous section</a> has ended. (Steps in <a data-anolis-xref="synchronous
     section" href="webappapis.html#synchronous-section">synchronous sections</a> are marked with ⌛.)</li>

     <li><p>⌛ <a href="#forget-the-media-element's-media-resource-specific-tracks">Forget the media element's media-resource-specific
     tracks</a>.</li>

     <li><p>⌛ <i data-anolis-xref="">Find next candidate</i>: Let <var data-anolis-xref="">candidate</var> be
     null.</li>

     <li><p>⌛ <i data-anolis-xref="">Search loop</i>: If the node after <var data-anolis-xref="">pointer</var> is
     the end of the list, then jump to the <i data-anolis-xref="">waiting</i> step below.</li>

     <li><p>⌛ If the node after <var data-anolis-xref="">pointer</var> is a <code><a href="#the-source-element">source</a></code> element,
     let <var data-anolis-xref="">candidate</var> be that element.</li>

     <li><p>⌛ Advance <var data-anolis-xref="">pointer</var> so that the node before <var data-anolis-xref="">pointer</var> is now the node that was after <var data-anolis-xref="">pointer</var>, and the node
     after <var data-anolis-xref="">pointer</var> is the node after the node that used to be after <var data-anolis-xref="">pointer</var>, if any.</li>

     <li><p>⌛ If <var data-anolis-xref="">candidate</var> is null, jump back to the <i data-anolis-xref="">search
     loop</i> step. Otherwise, jump back to the <i data-anolis-xref="">process candidate</i> step.</li>

     <li><p>⌛ <i data-anolis-xref="">Waiting</i>: Set the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute to the <code data-anolis-xref="dom-media-NETWORK_NO_SOURCE"><a href="#dom-media-network_no_source">NETWORK_NO_SOURCE</a></code> value.</li>

     <li><p>⌛ Set the element's <a href="#show-poster-flag">show poster flag</a> to true.</li>

     <li><p>⌛ <a href="webappapis.html#queue-a-task">Queue a task</a> to set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event
     flag</a> to false. This stops <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load
     event</a>.</li>

     <li><p>End the <a href="webappapis.html#synchronous-section">synchronous section</a>, continuing the remaining steps
     asynchronously.</li>

     <li><p>Wait until the node after <var data-anolis-xref="">pointer</var> is a node other than the end of
     the list. (This step might wait forever.)</li>

     <li><p>Asynchronously <a href="webappapis.html#await-a-stable-state">await a stable state</a>. The <a href="webappapis.html#synchronous-section">synchronous section</a>
     consists of all the remaining steps of this algorithm until the algorithm says the
     <a href="webappapis.html#synchronous-section">synchronous section</a> has ended. (Steps in <a data-anolis-xref="synchronous
     section" href="webappapis.html#synchronous-section">synchronous sections</a> are marked with ⌛.)</li>

     <li><p>⌛ Set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> back to true (this
     <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delays the load event</a> again, in case it hasn't been
     fired yet).</p>

     </li><li><p>⌛ Set the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> back to <code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>.</li>

     <li><p>⌛ Jump back to the <i data-anolis-xref="">find next candidate</i> step above.</li>

    </ol></li>

  </ol><p>The <dfn data-anolis-xref="concept-media-load-resource" id="concept-media-load-resource">resource fetch algorithm</dfn> for a <a href="#media-element">media
  element</a> and a given <a href="infrastructure.html#absolute-url">absolute URL</a> is as follows:</p>

  <ol><li><p>Let the <var data-anolis-xref="">current media resource</var> be the resource given by the
   <a href="infrastructure.html#absolute-url">absolute URL</a> passed to this algorithm. This is now the element's <a href="#media-resource">media
   resource</a>.</li>

   <li><p>Remove all <a data-anolis-xref="media-resource-specific text track" href="#media-resource-specific-text-track">media-resource-specific text
   tracks</a> from the <a href="#media-element">media element</a>'s <a href="#list-of-pending-text-tracks">list of pending text tracks</a>, if
   any.</p>

   </li><li><p>Optionally, run the following substeps. This is the expected behavior if the user agent
   intends to not attempt to fetch the resource until the user requests it explicitly (e.g. as a way
   to implement the <code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code> attribute's <code data-anolis-xref="attr-media-preload-none"><a href="#attr-media-preload-none">none</a></code> keyword).</p>

    <ol><li><p>Set the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code>.</li>

     <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-suspend"><a href="#event-media-suspend">suspend</a></code> at the element.</li>

     <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a>
     to false. This stops <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load
     event</a>.</li>

     <li><p>Wait for the task to be run.</li>

     <li><p>Wait for an implementation-defined event (e.g. the user requesting that the media
     element begin playback).</li>

     <li><p>Set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> back to true (this <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delays the load event</a> again, in case it hasn't been fired
     yet).</p>

     </li><li><p>Set the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>.</li>

    </ol></li>

   <li>

    <p>Perform a <a href="infrastructure.html#potentially-cors-enabled-fetch">potentially CORS-enabled fetch</a><!--FETCH-->  of the <var data-anolis-xref="">current media resource</var>'s <a href="infrastructure.html#absolute-url">absolute URL</a>, with the <i>mode</i> being
    the state of the <a href="#media-element">media element</a>'s <code data-anolis-xref="attr-media-crossorigin"><a href="#attr-media-crossorigin">crossorigin</a></code> content attribute, the <i data-anolis-xref="">origin</i>
    being the <a href="browsers.html#origin-0">origin</a> of the <a href="#media-element">media element</a>'s <code><a href="dom.html#document">Document</a></code>, and the
    <i>default origin behaviour</i> set to <i>taint</i>.</p>

    <p>The resource obtained in this fashion, if any, contains the <a href="#media-data">media data</a>. It can
    be <a href="infrastructure.html#cors-same-origin">CORS-same-origin</a> or <a href="infrastructure.html#cors-cross-origin">CORS-cross-origin</a>; this affects whether
    subtitles referenced in the <a href="#media-data">media data</a> are exposed in the API and, for
    <code><a href="#the-video-element">video</a></code> elements, whether a <code><a href="scripting-1.html#the-canvas-element">canvas</a></code> gets tainted when the video is drawn
    on it.</p>

    <p>While the load is not suspended (see below), every 350ms (±200ms) or for every byte
    received, whichever is <em>least</em> frequent, <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
    event</a> named <code data-anolis-xref="event-media-progress"><a href="#event-media-progress">progress</a></code> at the element.</p>

    <p>The <dfn id="stall-timeout">stall timeout</dfn> is a user-agent defined length of time, which should be about
    three seconds. When a <a href="#media-element">media element</a> that is actively attempting to obtain
    <a href="#media-data">media data</a> has failed to receive any data for a duration equal to the <a href="#stall-timeout">stall
    timeout</a>, the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
    event</a> named <code data-anolis-xref="event-media-stalled"><a href="#event-media-stalled">stalled</a></code> at the element.</p>

    <p>User agents may allow users to selectively block or slow <a href="#media-data">media data</a> downloads.
    When a <a href="#media-element">media element</a>'s download has been blocked altogether, the user agent must
    act as if it was stalled (as opposed to acting as if the connection was closed). The rate of the
    download may also be throttled automatically by the user agent, e.g. to balance the download
    with other connections sharing the same bandwidth.</p>

    <p id="resourceSuspend">User agents may decide to not download more content at any time, e.g.
    after buffering five minutes of a one hour media resource, while waiting for the user to decide
    whether to play the resource or not, while waiting for user input in an interactive resource, or
    when the user navigates away from the page. When a <a href="#media-element">media element</a>'s download has
    been suspended, the user agent must <a href="webappapis.html#queue-a-task">queue a task</a>, to set the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code> and <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named
    <code data-anolis-xref="event-media-suspend"><a href="#event-media-suspend">suspend</a></code> at the element. If and when downloading of the
    resource resumes, the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to set the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>. Between the queuing of these tasks,
    the load is suspended (so <code data-anolis-xref="event-media-progress"><a href="#event-media-progress">progress</a></code> events don't fire,
    as described above).</p>

    <p class="note">The <code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code> attribute provides a hint
    regarding how much buffering the author thinks is advisable, even in the absence of the <code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code> attribute.</p>

    <p>When a user agent decides to completely stall a download, e.g. if it is waiting until the
    user starts playback before downloading any further content, the user agent must <a href="webappapis.html#queue-a-task">queue a
    task</a> to set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> to false. This stops
    <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load event</a>.</p>

    <p>The user agent may use whatever means necessary to fetch the resource (within the constraints
    put forward by this and other specifications); for example, reconnecting to the server in the
    face of network errors, using HTTP range retrieval requests, or switching to a streaming
    protocol. The user agent must consider a resource erroneous only if it has given up trying to
    fetch it.</p>

    <p class="critical">This specification does not currently say whether or how to check the MIME
    types of the media resources, or whether or how to perform file type sniffing using the actual
    file data. Implementors differ in their intentions on this matter and it is therefore unclear
    what the right solution is. In the absence of any requirement here, the HTTP specification's
    strict requirement to follow the Content-Type header prevails ("Content-Type specifies the media
    type of the underlying data." ... "If and only if the media type is not given by a Content-Type
    field, the recipient MAY attempt to guess the media type via inspection of its content
    and<!---->./<!---->or the name extension(s) of the URI used to identify the resource.").</p>

    <p>The <a href="webappapis.html#networking-task-source">networking task source</a> <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> to process
    the data as it is being fetched must each immediately <a href="webappapis.html#queue-a-task">queue a task</a> to run the first
    appropriate steps from the following list. (A new task is used for this so that the work
    described below occurs relative to the <a href="#media-element-event-task-source">media element event task source</a> rather than
    the <a href="webappapis.html#networking-task-source">networking task source</a>.)</p>

    <dl class="switch"><dt>If the <a href="#media-data">media data</a> cannot be fetched at all, due to network errors, causing the
     user agent to give up trying to fetch the resource</dt>

     <dt>If the <a href="#media-data">media data</a> can be fetched but is found by inspection to be in an
     unsupported format, or can otherwise not be rendered at all</dt>

     <dd>

      <p>DNS errors, HTTP 4xx and 5xx errors (and equivalents in other protocols), and other fatal
      network errors that occur before the user agent has established whether the <var data-anolis-xref="">current media resource</var> is usable, as well as the file using an unsupported
      container format, or using unsupported codecs for all the data, must cause the user agent to
      execute the following steps:</p>

      <ol><li><p>The user agent should cancel the fetching process.</li>

       <li><p>Abort this subalgorithm, returning to the <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a>.</p>

      </li></ol></dd><!-- insert content sniffing here if we want to define that --><!-- (in practice I don't think that's necessary since it's not like you can do anything with
     the resource if you sniff it as the wrong type) -->


     
     


     <dt id="found-another-audio-track">If the <a href="#media-resource">media resource</a> is found to have an audio
     track</dt>

     <dd>

      <ol><li><p>Create an <code><a href="#audiotrack">AudioTrack</a></code> object to represent the audio track.</li>

       <li><p>Update the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code> attribute's <code><a href="#audiotracklist">AudioTrackList</a></code>
       object with the new <code><a href="#audiotrack">AudioTrack</a></code> object.</li>

       <li><p>Let <var data-anolis-xref="">enable</var> be <i>unknown</i>.</li>

       <li>

        <p>If either the <a href="#media-resource">media resource</a> or the address of the <var data-anolis-xref="">current
        media resource</var> indicate a particular set of audio tracks to enable, or if the user
        agent has information that would facilitate the selection of specific audio tracks to
        improve the user's experience, then: if this audio track is one of the ones to enable, then
        set <var data-anolis-xref="">enable</var> to <i>true</i>, otherwise, set <var data-anolis-xref="">enable</var>
        to <i>false</i>.</p>

        <p class="example">This could be triggered by <cite>Media Fragments URI</cite> fragment
        identifier syntax, but it could also be triggered e.g. by the user agent selecting a 5.1
        surround sound audio track over a stereo audio track. <a href="references.html#refsMEDIAFRAG">[MEDIAFRAG]</a></p>

       </li><!--CLEANUP-->


       <li><p>If <var data-anolis-xref="">enable</var> is still <i>unknown</i>, then, if the <a href="#media-element">media
       element</a> does not yet have an <a data-anolis-xref="dom-AudioTrack-enabled" href="#dom-audiotrack-enabled">enabled</a> audio track, then set <var data-anolis-xref="">enable</var>
       to <i>true</i>, otherwise, set <var data-anolis-xref="">enable</var> to <i>false</i>.</li>

       <li><p>If <var data-anolis-xref="">enable</var> is <i>true</i>, then enable this audio track,
       otherwise, do not enable this audio track.</li>

       <li><p><a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">Fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-media-addtrack"><a href="#event-media-addtrack">addtrack</a></code>, that does not bubble and is not cancelable, and
       that uses the <code><a href="#trackevent">TrackEvent</a></code> interface, with the <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code> attribute initialised to the new
       <code><a href="#audiotrack">AudioTrack</a></code> object, at this <code><a href="#audiotracklist">AudioTrackList</a></code> object.</li>

      </ol></dd>


     <dt id="found-another-video-track">If the <a href="#media-resource">media resource</a> is found to have a video
     track</dt>

     <dd>

      <ol><li><p>Create a <code><a href="#videotrack">VideoTrack</a></code> object to represent the video track.</li>

       <li><p>Update the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code> attribute's <code><a href="#videotracklist">VideoTrackList</a></code>
       object with the new <code><a href="#videotrack">VideoTrack</a></code> object.</li>

       <li><p>Let <var data-anolis-xref="">enable</var> be <i>unknown</i>.</li>

       <li>

        <p>If either the <a href="#media-resource">media resource</a> or the address of the <var data-anolis-xref="">current
        media resource</var> indicate a particular set of video tracks to enable, or if the user
        agent has information that would facilitate the selection of specific video tracks to
        improve the user's experience, then: if this video track is the first such video track, then
        set <var data-anolis-xref="">enable</var> to <i>true</i>, otherwise, set <var data-anolis-xref="">enable</var>
        to <i>false</i>.</p>

        <p class="example">This could again be triggered by <cite>Media Fragments URI</cite>
        fragment identifier syntax.</p>

       </li><!--CLEANUP-->


       <li><p>If <var data-anolis-xref="">enable</var> is still <i>unknown</i>, then, if the <a href="#media-element">media
       element</a> does not yet have a <a data-anolis-xref="dom-VideoTrack-selected" href="#dom-videotrack-selected">selected</a> video track, then set <var data-anolis-xref="">enable</var>
       to <i>true</i>, otherwise, set <var data-anolis-xref="">enable</var> to <i>false</i>.</li>

       <li><p>If <var data-anolis-xref="">enable</var> is <i>true</i>, then select this track and unselect any
       previously selected video tracks, otherwise, do not select this video track. If other tracks
       are unselected, then <a href="#toggle-video-track">a <code data-anolis-xref="event-media-change">change</code> event will be fired.</a></li>

       <li><p><a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">Fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-media-addtrack"><a href="#event-media-addtrack">addtrack</a></code>, that does not bubble and is not cancelable, and that
       uses the <code><a href="#trackevent">TrackEvent</a></code> interface, with the <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code> attribute initialised to the new
       <code><a href="#videotrack">VideoTrack</a></code> object, at this <code><a href="#videotracklist">VideoTrackList</a></code> object.</li>

      </ol></dd>


     <dt id="getting-media-metadata">Once enough of the <a href="#media-data">media data</a> has been fetched to
     determine the duration of the <a href="#media-resource">media resource</a>, its dimensions, and other
     metadata</dt>

     <dd>

      <p>This indicates that the resource is usable. The user agent must follow these substeps:</p>

      <ol><li>

        <p><a href="#defineTimeline">Establish the media timeline</a> for the purposes of the <a href="#current-playback-position">current playback
        position</a>, the <a href="#earliest-possible-position">earliest possible position</a>, and the <a href="#initial-playback-position">initial playback
        position</a>, based on the <a href="#media-data">media data</a>.</p>

       </li>

       <li>

        <p>Update the <a href="#timeline-offset">timeline offset</a> to the date and time that corresponds to the zero
        time in the <a href="#media-timeline">media timeline</a> established in the previous step, if any. If no
        explicit time and date is given by the <a href="#media-resource">media resource</a>, the <a href="#timeline-offset">timeline
        offset</a> must be set to Not-a-Number (NaN).</p>

       </li>

       <li><p>Set the <a href="#current-playback-position">current playback position</a> and the <a href="#official-playback-position">official playback
       position</a> to the <a href="#earliest-possible-position">earliest possible position</a>.</li>

       <li>

        <p>Update the <code data-anolis-xref="dom-media-duration"><a href="#dom-media-duration">duration</a></code> attribute with the time of
        the last frame of the resource, if known, on the <a href="#media-timeline">media timeline</a> established
        above. If it is not known (e.g. a stream that is in principle infinite), update the <code data-anolis-xref="dom-media-duration"><a href="#dom-media-duration">duration</a></code> attribute to the value positive Infinity.</p>

        <p class="note">The user agent <a href="#durationChange">will</a> <a href="webappapis.html#queue-a-task">queue a task</a>
        to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-durationchange"><a href="#event-media-durationchange">durationchange</a></code> at the element at this point.</p>

       </li>

       <li>

        <p>For <code><a href="#the-video-element">video</a></code> elements, set the <code data-anolis-xref="dom-video-videoWidth"><a href="#dom-video-videowidth">videoWidth</a></code> and <code data-anolis-xref="dom-video-videoHeight"><a href="#dom-video-videoheight">videoHeight</a></code> attributes, and <a href="webappapis.html#queue-a-task">queue a task</a>
        to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-resize"><a href="#event-media-resize">resize</a></code> at
        the <a href="#media-element">media element</a>.</p>

        <p class="note">Further <code data-anolis-xref="event-media-resize"><a href="#event-media-resize">resize</a></code> events will be fired
        if the dimensions subsequently change.</p>

       </li>

       <li>

        <p>Set the <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute to <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>.</p>

        <p class="note">A <code data-anolis-xref="event-media-loadedmetadata"><a href="#event-media-loadedmetadata">loadedmetadata</a></code> DOM event
        <a href="#fire-loadedmetadata">will be fired</a> as part of setting the <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute to a new value.</p><!-- this can also do the "report the controller state" thing -->

        

       </li>

       <li><p>Let <var data-anolis-xref="">jumped</var> be false.</li>

       <li><p>If the <a href="#media-element">media element</a>'s <a href="#default-playback-start-position">default playback start position</a> is
       greater than zero, then <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to that time, and let <var data-anolis-xref="">jumped</var> be true.</li>

       <li><p>Let the <a href="#media-element">media element</a>'s <a href="#default-playback-start-position">default playback
       start position</a> be zero.</li>

       <li>

        <p>If either the <a href="#media-resource">media resource</a> or the address of the <var data-anolis-xref="">current
        media resource</var> indicate a particular start time, then set the <a href="#initial-playback-position">initial playback
        position</a> to that time and, if <var data-anolis-xref="">jumped</var> is still false, <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to that time and let <var data-anolis-xref="">jumped</var> be
        true.</p>

        <p class="example">For example, with media formats that support the <cite>Media Fragments
        URI</cite> fragment identifier syntax, the fragment identifier can be used to indicate a
        start position. <a href="references.html#refsMEDIAFRAG">[MEDIAFRAG]</a></p>

       </li><!--CLEANUP-->


       <li><p>If there is no <a data-anolis-xref="dom-AudioTrack-enabled" href="#dom-audiotrack-enabled">enabled</a> audio track, then enable an audio track. This <a href="#toggle-audio-track">will cause a <code data-anolis-xref="event-media-change">change</code> event
       to be fired</a>.</li><!--CLEANUP-->


       <li><p>If there is no <a data-anolis-xref="dom-VideoTrack-selected" href="#dom-videotrack-selected">selected</a> video track, then select a video track. This <a href="#toggle-video-track">will cause a <code data-anolis-xref="event-media-change">change</code> event
       to be fired</a>.</li>

       <li><p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, then:
       if <var data-anolis-xref="">jumped</var> is true and the <a href="#initial-playback-position">initial playback position</a>,
       relative to the <a href="#current-media-controller">current media controller</a>'s timeline, is greater than the
       <a href="#current-media-controller">current media controller</a>'s <a href="#media-controller-position">media controller position</a>, then
       <a href="#seek-the-media-controller">seek the media controller</a> to the <a href="#media-element">media element</a>'s <a href="#initial-playback-position">initial
       playback position</a>, relative to the <a href="#current-media-controller">current media controller</a>'s timeline;
       otherwise, <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> the <a href="#media-element">media element</a> to the
       <a href="#media-controller-position">media controller position</a>, relative to the <a href="#media-element">media element</a>'s
       timeline.</li><!-- i.e. "bring the media element up to speed with its new media
       controller" --><!-- we do this because otherwise the fragment identifier initial position is
       lost. Basically this means that if you are attached to a media controller when you load your
       resource, and you have a fragment identifier with a start time, you'll jump the media
       controller to that time if it's not already past it. (So if there are several, you'll jump
       the media controller to the furthest one in the timeline.) --><!-- note that this can also
       trigger "report the controller state" since it can change the element's readyState -->   

      </ol><p>Once the <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute reaches <code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>, <a href="#fire-loadeddata">after
      the <code data-anolis-xref="event-media-loadeddata">loadeddata</code> event has been fired</a>, set the
      element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> to false. This stops <a data-anolis-xref="delay
      the load event" href="syntax.html#delay-the-load-event">delaying the load event</a>.</p>

      <p class="note">A user agent that is attempting to reduce network usage while still fetching
      the metadata for each <a href="#media-resource">media resource</a> would also stop buffering at this point,
      following <a href="#resourceSuspend">the rules described previously</a>, which involve the
      <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute switching to the <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code> value and a <code data-anolis-xref="event-media-suspend"><a href="#event-media-suspend">suspend</a></code> event firing.</p>

      <p class="note">The user agent is <em>required</em> to determine the duration of the
      <a href="#media-resource">media resource</a> and go through this step before playing.</p><!-- actually defined
      in the 'duration' section --> 

     </dd>


     <dt>Once the entire <a href="#media-resource">media resource</a> has been <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetched</a>
     (but potentially before any of it has been decoded)</dt>

     <dd>

      <p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> named <code data-anolis-xref="event-media-progress"><a href="#event-media-progress">progress</a></code>
      at the <a href="#media-element">media element</a>.</p>

      <p>Set the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code> and <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named
      <code data-anolis-xref="event-media-suspend"><a href="#event-media-suspend">suspend</a></code> at the <a href="#media-element">media element</a>.</p>

      <p>If the user agent ever discards any <a href="#media-data">media data</a> and then needs to resume the
      network activity to obtain it again, then it must <a href="webappapis.html#queue-a-task">queue a task</a> to set the <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> to <code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>.</p>

      <p class="note">If the user agent can keep the <a href="#media-resource">media resource</a> loaded, then the
      algorithm will continue to its final step below, which aborts the algorithm.</p><!-- see FINAL
      STEP below -->

     </dd>


     <dt>If the connection is interrupted after some <a href="#media-data">media data</a> has been received,
     causing the user agent to give up trying to fetch the resource</dt>

     <dd>

      <p>Fatal network errors that occur after the user agent has established whether the <var data-anolis-xref="">current media resource</var> is usable (i.e. once the <a href="#media-element">media element</a>'s
      <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is no longer <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>) must cause the user agent to execute the
      following steps:</p>

      <ol><li><p>The user agent should cancel the fetching process.</li>

       <li><p>Set the <code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code> attribute to a new
       <code><a href="#mediaerror">MediaError</a></code> object whose <code data-anolis-xref="dom-MediaError-code"><a href="#dom-mediaerror-code">code</a></code> attribute
       is set to <code data-anolis-xref="dom-MediaError-MEDIA_ERR_NETWORK"><a href="#dom-mediaerror-media_err_network">MEDIA_ERR_NETWORK</a></code>.</li>

       <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> named <code data-anolis-xref="event-media-error"><a href="#event-media-error">error</a></code> at
       the <a href="#media-element">media element</a>.</li>

       <li><p>Set the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute
       to the <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code> value.</li>

       <li><p>Set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> to false. This stops <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load event</a>.</li>

       <li><p>Abort the overall <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection
       algorithm</a>.</li>

      </ol></dd>


     <dt id="fatal-decode-error">If the <a href="#media-data">media data</a> is corrupted</dt>

     <dd>

      <p>Fatal errors in decoding the <a href="#media-data">media data</a> that occur after the user agent has
      established whether the <var data-anolis-xref="">current media resource</var> is usable must cause the
      user agent to execute the following steps:</p>

      <ol><li><p>The user agent should cancel the fetching process.</li>

       <li><p>Set the <code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code> attribute to a new
       <code><a href="#mediaerror">MediaError</a></code> object whose <code data-anolis-xref="dom-MediaError-code"><a href="#dom-mediaerror-code">code</a></code> attribute
       is set to <code data-anolis-xref="dom-MediaError-MEDIA_ERR_DECODE"><a href="#dom-mediaerror-media_err_decode">MEDIA_ERR_DECODE</a></code>.</li>

       <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> named <code data-anolis-xref="event-media-error"><a href="#event-media-error">error</a></code> at
       the <a href="#media-element">media element</a>.</li>

       <li>

        <p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>
        attribute has a value equal to <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, set
        the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute to the
        <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code> value, set the element's
        <a href="#show-poster-flag">show poster flag</a> to true, and <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-emptied"><a href="#event-media-emptied">emptied</a></code> at the element.</p>

        <p>Otherwise, set the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>
        attribute to the <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code> value.</p>

       </li>

       <li><p>Set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> to false. This stops <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load event</a>.</li>

       <li><p>Abort the overall <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection
       algorithm</a>.</li>

      </ol></dd>


     <dt>If the <a href="#media-data">media data</a> fetching process is aborted by the user</dt>

     <dd>

      <p>The fetching process is aborted by the user, e.g. because the user
      pressed a "stop" button, the user agent must execute the following steps. These steps are not
      followed if the <code data-anolis-xref="dom-media-load"><a href="#dom-media-load">load()</a></code> method itself is invoked while
      these steps are running, as the steps above handle that particular kind of abort.</p>

      <ol><li><p>The user agent should cancel the fetching process.</li>

       <li><p>Set the <code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code> attribute to a new
       <code><a href="#mediaerror">MediaError</a></code> object whose <code data-anolis-xref="dom-MediaError-code"><a href="#dom-mediaerror-code">code</a></code> attribute
       is set to <code data-anolis-xref="dom-MediaError-MEDIA_ERR_ABORTED"><a href="#dom-mediaerror-media_err_aborted">MEDIA_ERR_ABORTED</a></code>.</li>

       <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> named <code data-anolis-xref="event-media-abort"><a href="#event-media-abort">abort</a></code> at
       the <a href="#media-element">media element</a>.</li>

       <li>

        <p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>
        attribute has a value equal to <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, set
        the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute to the
        <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code> value, set the element's
        <a href="#show-poster-flag">show poster flag</a> to true, and <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-emptied"><a href="#event-media-emptied">emptied</a></code> at the element.</p>

        <p>Otherwise, set the element's <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>
        attribute to the <code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code> value.</p>

       </li>

       <li><p>Set the element's <a href="#delaying-the-load-event-flag">delaying-the-load-event flag</a> to false. This stops <a data-anolis-xref="delay the load event" href="syntax.html#delay-the-load-event">delaying the load event</a>.</li>

       <li><p>Abort the overall <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection
       algorithm</a>.</li>

      </ol></dd>


     <dt id="non-fatal-media-error">If the <a href="#media-data">media data</a> can be fetched but has non-fatal
     errors or uses, in part, codecs that are unsupported, preventing the user agent from rendering
     the content completely correctly but not preventing playback altogether</dt>

     <dd>

      <p>The server returning data that is partially usable but cannot be optimally rendered must
      cause the user agent to render just the bits it can handle, and ignore the rest.</p><!-- v2: fire a 'warning' event and set the 'error' flag to 'MEDIA_ERR_SUBOPTIMAL' or something -->

      

     </dd>


     <dt id="found-a-media-resource-specific-timed-track">If the <a href="#media-resource">media resource</a> is
     found to declare a <a href="#media-resource-specific-text-track">media-resource-specific text track</a> that the user agent
     supports</dt>

     <dd>

      <p>If the <a href="#media-data">media data</a> is <a href="infrastructure.html#cors-same-origin">CORS-same-origin</a>, run the <a href="#steps-to-expose-a-media-resource-specific-text-track">steps to
      expose a media-resource-specific text track</a> with the relevant data.</p>

      <p class="note">Cross-origin videos do not expose their subtitles, since that would allow
      attacks such as hostile sites reading subtitles from confidential videos on a user's
      intranet.</p>

     </dd>

    </dl><p>When the <a href="webappapis.html#networking-task-source">networking task source</a> has <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> the
    last <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> as part of <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching</a> the
    <a href="#media-resource">media resource</a> (i.e. once the download has completed), if the fetching process
    completes without errors, including decoding the media data, and if all of the data is available
    to the user agent without network access, then, the user agent must move on to the next step.
    This might never happen, e.g. when streaming an infinite resource such as Web radio, or if the
    resource is longer than the user agent's ability to cache data.</p>

    <p>While the user agent might still need network access to obtain parts of the <a href="#media-resource">media
    resource</a>, the user agent must remain on this step.</p>

    <p class="example">For example, if the user agent has discarded the first half of a video, the
    user agent will remain at this step even once the <a data-anolis-xref="ended playback" href="#ended-playback">playback has
    ended</a>, because there is always the chance the user will seek back to the start. In fact,
    in this situation, once <a data-anolis-xref="ended playback" href="#ended-playback">playback has ended</a>, the user agent
    will end up firing a <code data-anolis-xref="event-media-suspend"><a href="#event-media-suspend">suspend</a></code> event, as described
    earlier.</p>

   </li><!-- this step is mentioned above, search for "FINAL STEP" -->

   
   <li><p>If the user agent ever reaches this step (which can only happen if the entire resource
   gets loaded and kept available): abort the overall <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a>.</li>

  </ol><p>When a <a href="#media-element">media element</a> is to <dfn id="forget-the-media-element's-media-resource-specific-tracks">forget the media element's media-resource-specific
  tracks</dfn>, the user agent must remove from the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text
  tracks</a> all the <a data-anolis-xref="media-resource-specific text track" href="#media-resource-specific-text-track">media-resource-specific
  text tracks</a>, then empty the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code> attribute's <code><a href="#audiotracklist">AudioTrackList</a></code> object,
  then empty the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code>
  attribute's <code><a href="#videotracklist">VideoTrackList</a></code> object. No events (in particular, no <code data-anolis-xref="event-media-removetrack"><a href="#event-media-removetrack">removetrack</a></code> events) are fired as part of this; the <code data-anolis-xref="event-media-error"><a href="#event-media-error">error</a></code> and <code data-anolis-xref="event-media-emptied"><a href="#event-media-emptied">emptied</a></code>
  events, fired by the algorithms that invoke this one, can be used instead.</p>

  </div>

  <hr><p><dfn data-anolis-xref="attr-media-preload" id="attr-media-preload"><code>preload</code></dfn>属性は<a href="infrastructure.html#enumerated-attribute">列挙属性</a>である。次の表は、キーワードと属性の状態を示す。1列目のキーワードは、キーワードと同じ行で2列目のセル内の状態に対応づける。<a href="#media-resource">メディアリソース</a>がバッファまたは再生されている場合でも属性を変更できる。下記の表の説明では、この点に留意して解釈されるべきである。</p>

  <table><thead><tr><th> キーワード
     </th><th> 状態
     </th><th> 概要
   <tbody></th></tr><tr><td><dfn data-anolis-xref="attr-media-preload-none" id="attr-media-preload-none"><code>なし</code></dfn>
     </td><td><dfn data-anolis-xref="attr-media-preload-none-state" id="attr-media-preload-none-state">なし</dfn>
     </td><td>著者がメディアリソースを必要とすることをユーザーに期待しない、またはサーバが不要なトラフィックを最小限にしたいのいずれかのユーザーエージェントへのヒント。バッファリングはとにかく開始する（たとえばユーザーが"play"に当たる）場合、この状態は、メディアリソースを実際にダウンロードする方法に関して積極的にヒントを提供しない。
    </td></tr><tr><td><dfn data-anolis-xref="attr-media-preload-metadata" id="attr-media-preload-metadata"><code>metadata</code></dfn>
     </td><td><dfn data-anolis-xref="attr-media-preload-metadata-state" id="attr-media-preload-metadata-state">Metadata</dfn>
     </td><td>著者がメディアリソースを必要とするとユーザーに期待しないが、リソースのメタデータ（寸法、トラックリスト、期間など）フェッチし、そしておそらく最初の数フレームが合理的であるユーザーエージェントへのヒント。ユーザーエージェントが正確にメタデータ以上のものをフェッチしない場合、典型的には、一部のフレームも同様に得られ、おそらく<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>または<code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>になるにもかかわらず、<a href="#media-element">メディア要素</a>は<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>に設定される<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>属性に終わる。メディアリソースが再生する際、たとえばメディアデータが依然として一貫した再生を維持し最も遅い可能性のレートで得られるようにダウンロードを絞ることが示唆するような、帯域幅の不足を考慮すべきであるというユーザーエージェントへのヒント。
    </td></tr><tr><td><dfn data-anolis-xref="attr-media-preload-auto" id="attr-media-preload-auto"><code>auto</code></dfn>
     </td><td><dfn data-anolis-xref="attr-media-preload-auto-state" id="attr-media-preload-auto-state">Automatic</dfn>
     </td><td>ユーザーエージェントが、楽観的に全体のリソースのダウンロードを含め、サーバーへのリスクなしに、最初のユーザーのニーズを置くことができるというユーザーエージェントへのヒント。
  </td></tr></table><p>空文字列もまた妥当なキーワードであり、<a data-anolis-xref="attr-media-preload-auto-state" href="#attr-media-preload-auto-state">自動</a>状態に対応づける。<a data-anolis-xref="attr-media-preload-metadata-state" href="#attr-media-preload-metadata-state">メタデータ</a>状態はサーバーの負荷を軽減し、最適なユーザーエクスペリエンスを提供する妥協点として示唆されるけれども、属性の<i>欠損デフォルト値</i>は、ユーザーエージェント定義である。</p>

  <p class="note">一度ユーザーが再生を始めると、著者は、動的に"<code data-anolis-xref="attr-media-preload-none"><a href="#attr-media-preload-none">none</a></code>"または"<code data-anolis-xref="attr-media-preload-metadata"><a href="#attr-media-preload-metadata">metadata</a></code>"から"<code data-anolis-xref="attr-media-preload-auto"><a href="#attr-media-preload-auto">auto</a></code>"に属性を切り替えるかもしれない。たとえば、多くのビデオをもつページ上で、要求されないが一度に動画<em>が</em>積極的にダウンロードされる限り、これは多くの動画がダウンロードされるべきではないことを示すために使用されるかもしれない。</p>

  <div class="impl">

  <p>The <code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code> attribute is intended to provide a hint to
  the user agent about what the author thinks will lead to the best user experience. The attribute
  may be ignored altogether, for example based on explicit user preferences or based on the
  available connectivity.</p>

  <p>The <dfn data-anolis-xref="dom-media-preload" id="dom-media-preload"><code>preload</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the content attribute of the same name, <a href="infrastructure.html#limited-to-only-known-values">limited to only known
  values</a>.</p>

  </div>

  <p class="note">（メディアを再生する場合、<code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code>属性によって与えられるヒントにかかわらず、自然に最初のバッファを持つので）<code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code>属性は<code data-anolis-xref="attr-media-preload"><a href="#attr-media-preload">preload</a></code>属性を上書きできる。しかし、両方を含めることはエラーではない。</p>

  <hr><!--v3BUF (when readding this, also add a domintro block)
  <p>The <dfn data-x="dom-media-bufferingRate"><code>bufferingRate</code></dfn> attribute must return
  the average number of bits received per second for the current download over the past few seconds.
  If there is no download in progress, the attribute must return 0.</p>

  <p>The <dfn data-x="dom-media-bufferingThrottled"><code>bufferingThrottled</code></dfn> attribute
  must return true if the user agent is intentionally throttling the bandwidth used by the download
  (including when throttling to zero to pause the download altogether), and false otherwise.</p>

  <hr>
--><dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-buffered"><a href="#dom-media-buffered">buffered</a></code></dt>

   <dd>

    <p>ユーザーエージェントがバッファリングした<a href="#media-resource">メディアリソース</a>の範囲を表す<code><a href="#timeranges">TimeRanges</a></code>オブジェクトを返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-buffered" id="dom-media-buffered"><code>buffered</code></dfn> attribute must return a new
  static <a href="#normalised-timeranges-object">normalised <code>TimeRanges</code> object</a> that represents the ranges of the
  <a href="#media-resource">media resource</a>, if any, that the user agent has buffered, at the time the attribute
  is evaluated. Users agents must accurately determine the ranges available, even for media streams
  where this can only be determined by tedious inspection.</p>

  <p class="note">Typically this will be a single range anchored at the zero point, but if, e.g. the
  user agent uses HTTP range requests in response to seeking, then there could be multiple
  ranges.</p>

  <p>User agents may discard previously buffered data.</p>

  <p class="note">Thus, a time position included within a range of the objects return by the <code data-anolis-xref="dom-media-buffered"><a href="#dom-media-buffered">buffered</a></code> attribute at one time can end up being not included in
  the range(s) of objects returned by the same attribute at later times.</p>

  </div>



  <h5 id="offsets-into-the-media-resource"><span class="secno">4.7.14.6</span> メディアリソースからのオフセット</h5>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-duration"><a href="#dom-media-duration">duration</a></code></dt>

   <dd>

    <p><a href="#media-resource">メディアリソース</a>の始点が時間ゼロであると仮定して、秒単位で<a href="#media-resource">メディアリソース</a>の長さを返す。</p>

    <p>期間が利用できない場合はNaNを返す。</p>

    <p>際限のないストリームに対してInfinityを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-currentTime"><a href="#dom-media-currenttime">currentTime</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>秒単位で、<a href="#official-playback-position">公式の再生位置</a>を返す。</p>

    <p>指定時間にシークするために、設定可能である。</p>

    <p>選択した<a href="#media-resource">メディアリソース</a>がない場合、または<a href="#current-media-controller">現在のメディアコントローラ</a>がある場合、<code><a href="infrastructure.html#invalidstateerror">InvalidStateError</a></code>例外を投げる。</p>

   </dd>

  </dl><div class="impl">

  <p>A <a href="#media-resource">media resource</a> has a <dfn id="media-timeline">media timeline</dfn> that maps times (in seconds) to
  positions in the <a href="#media-resource">media resource</a>. The origin of a timeline is its earliest defined
  position. The duration of a timeline is its last defined position.</p>

  <p><dfn data-anolis-xref="establish the media timeline" id="defineTimeline">Establishing the media
  timeline</dfn>: If the <a href="#media-resource">media resource</a> somehow specifies an explicit timeline whose
  origin is not negative (i.e. gives each frame a specific time offset and gives the first frame a
  zero or positive offset), then the <a href="#media-timeline">media timeline</a> should be that timeline. (Whether
  the <a href="#media-resource">media resource</a> can specify a timeline or not depends on the <a data-anolis-xref="media
  resource" href="#media-resource">media resource's</a> format.) If the <a href="#media-resource">media resource</a> specifies an
  explicit start time <em>and date</em>, then that time and date should be considered the zero point
  in the <a href="#media-timeline">media timeline</a>; the <a href="#timeline-offset">timeline offset</a> will be the time and date,
  exposed using the <code data-anolis-xref="dom-media-getStartDate"><a href="#dom-media-getstartdate">getStartDate()</a></code> method.</p>

  <p>If the <a href="#media-resource">media resource</a> has a discontinuous timeline, the user agent must extend the
  timeline used at the start of the resource across the entire resource, so that the <a href="#media-timeline">media
  timeline</a> of the <a href="#media-resource">media resource</a> increases linearly starting from the
  <a href="#earliest-possible-position">earliest possible position</a> (as defined below), even if the underlying <a href="#media-data">media
  data</a> has out-of-order or even overlapping time codes.</p>

  <p class="example">For example, if two clips have been concatenated into one video file, but the
  video format exposes the original times for the two clips, the video data might expose a timeline
  that goes, say, 00:15..00:29 and then 00:05..00:38. However, the user agent would not expose those
  times; it would instead expose the times as 00:15..00:29 and 00:29..01:02, as a single video.</p>

  <p>In the rare case of a <a href="#media-resource">media resource</a> that does not have an explicit timeline, the
  zero time on the <a href="#media-timeline">media timeline</a> should correspond to the first frame of the
  <a href="#media-resource">media resource</a>. In the even rarer case of a <a href="#media-resource">media resource</a> with no
  explicit timings of any kind, not even frame durations, the user agent must itself determine the
  time for each frame in a user-agent-defined manner.
  
  <span class="fingerprint" title="fingerprinting vector"><a href="introduction.html#fingerprinting-vector"><img alt="(This is a fingerprinting vector.)" height="21" src="http://www.w3.org/TR/html5/images/fingerprint.png" width="15"></a></span>
  </p>

  <p class="note">An example of a file format with no explicit timeline but with explicit frame
  durations is the Animated GIF format. An example of a file format with no explicit timings at all
  is the JPEG-push format (<code><a href="iana.html#multipart/x-mixed-replace">multipart/x-mixed-replace</a></code> with JPEG frames, often
  used as the format for MJPEG streams).</p>

  <p>If, in the case of a resource with no timing information, the user agent will nonetheless be
  able to seek to an earlier point than the first frame originally provided by the server, then the
  zero time should correspond to the earliest seekable time of the <a href="#media-resource">media resource</a>;
  otherwise, it should correspond to the first frame received from the server (the point in the
  <a href="#media-resource">media resource</a> at which the user agent began receiving the stream).</p>

  <p class="note">At the time of writing, there is no known format that lacks explicit frame time
  offsets yet still supports seeking to a frame before the first frame sent by the server.</p>

  <div class="example">

   <p>Consider a stream from a TV broadcaster, which begins streaming on a sunny Friday afternoon in
   October, and always sends connecting user agents the media data on the same media timeline, with
   its zero time set to the start of this stream. Months later, user agents connecting to this
   stream will find that the first frame they receive has a time with millions of seconds. The <code data-anolis-xref="dom-media-getStartDate"><a href="#dom-media-getstartdate">getStartDate()</a></code> method would always return the date that the
   broadcast started; this would allow controllers to display real times in their scrubber (e.g.
   "2:30pm") rather than a time relative to when the broadcast began ("8 months, 4 hours, 12
   minutes, and 23 seconds").</p>

   <p>Consider a stream that carries a video with several concatenated fragments, broadcast by a
   server that does not allow user agents to request specific times but instead just streams the
   video data in a predetermined order, with the first frame delivered always being identified as
   the frame with time zero. If a user agent connects to this stream and receives fragments defined
   as covering timestamps 2010-03-20 23:15:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12 14:25:00
   UTC to 2010-02-12 14:35:00 UTC, it would expose this with a <a href="#media-timeline">media timeline</a> starting
   at 0s and extending to 3,600s (one hour). Assuming the streaming server disconnected at the end
   of the second clip, the <code data-anolis-xref="dom-media-duration"><a href="#dom-media-duration">duration</a></code> attribute would then
   return 3,600. The <code data-anolis-xref="dom-media-getStartDate"><a href="#dom-media-getstartdate">getStartDate()</a></code> method would return a
   <code>Date</code> object with a time corresponding to 2010-03-20 23:15:00 UTC. However, if a
   different user agent connected five minutes later, <em>it</em> would (presumably) receive
   fragments covering timestamps 2010-03-20 23:20:00 UTC to 2010-03-21 00:05:00 UTC and 2010-02-12
   14:25:00 UTC to 2010-02-12 14:35:00 UTC, and would expose this with a <a href="#media-timeline">media timeline</a>
   starting at 0s and extending to 3,300s (fifty five minutes). In this case, the <code data-anolis-xref="dom-media-getStartDate"><a href="#dom-media-getstartdate">getStartDate()</a></code> method would return a <code>Date</code> object
   with a time corresponding to 2010-03-20 23:20:00 UTC.</p>

   <p>In both of these examples, the <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code> attribute
   would give the ranges that the controller would want to actually display in its UI; typically, if
   the servers don't support seeking to arbitrary times, this would be the range of time from the
   moment the user agent connected to the stream up to the latest frame that the user agent has
   obtained; however, if the user agent starts discarding earlier information, the actual range
   might be shorter.</p>

  </div>

  <p>In any case, the user agent must ensure that the <a href="#earliest-possible-position">earliest possible position</a> (as
  defined below) using the established <a href="#media-timeline">media timeline</a>, is greater than or equal to
  zero.</p>

  <p>The <a href="#media-timeline">media timeline</a> also has an associated clock. Which clock is used is user-agent
  defined, and may be <a href="#media-resource">media resource</a>-dependent, but it should approximate the user's
  wall clock.</p>

  <p class="note">All the <a data-anolis-xref="media element" href="#media-element">media elements</a> that share <a href="#current-media-controller">current
  media controller</a> use the same clock for their <a href="#media-timeline">media timeline</a>.</p>

  <p><a data-anolis-xref="media element" href="#media-element">Media elements</a> have a <dfn id="current-playback-position">current playback position</dfn>,
  which must initially (i.e. in the absence of <a href="#media-data">media data</a>) be zero seconds. The
  <a href="#current-playback-position">current playback position</a> is a time on the <a href="#media-timeline">media timeline</a>.</p>

  <p><a data-anolis-xref="media element" href="#media-element">Media elements</a> also have an <dfn id="official-playback-position">official playback
  position</dfn>, which must initially be set to zero seconds. The <a href="#official-playback-position">official playback
  position</a> is an approximation of the <a href="#current-playback-position">current playback position</a> that is kept
  stable while scripts are running.</p>

  <p><a data-anolis-xref="media element" href="#media-element">Media elements</a> also have a <dfn id="default-playback-start-position">default playback start
  position</dfn>, which must initially be set to zero seconds. This time is used to allow the
  element to be seeked even before the media is loaded.</p>

  <p>Each <a href="#media-element">media element</a> has a <dfn id="show-poster-flag">show poster flag</dfn>. When a <a href="#media-element">media
  element</a> is created, this flag must be set to true. This flag is used to control when the
  user agent is to show a poster frame for a <code><a href="#the-video-element">video</a></code> element instead of showing the video
  contents.</p>

  <p>The <dfn data-anolis-xref="dom-media-currentTime" id="dom-media-currenttime"><code>currentTime</code></dfn> attribute must, on
  getting, return the <a href="#media-element">media element</a>'s <a href="#default-playback-start-position">default playback start position</a>,
  unless that is zero, in which case it must return the element's <a href="#official-playback-position">official playback
  position</a>. The returned value must be expressed in seconds. On setting, if the <a href="#media-element">media
  element</a> has a <a href="#current-media-controller">current media controller</a>, then the user agent must throw an
  <code><a href="infrastructure.html#invalidstateerror">InvalidStateError</a></code> exception; otherwise, if the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> is <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, then it must set the <a href="#media-element">media
  element</a>'s <a href="#default-playback-start-position">default playback start position</a> to the new value; otherwise, it must
  set the <a href="#official-playback-position">official playback position</a> to the new value and then <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to the new value. The new value must be interpreted as being in
  seconds.</p>

  <p><a data-anolis-xref="media element" href="#media-element">Media elements</a> have an <dfn id="initial-playback-position">initial playback position</dfn>,
  which must initially (i.e. in the absence of <a href="#media-data">media data</a>) be zero seconds. The
  <a href="#initial-playback-position">initial playback position</a> is updated when a <a href="#media-resource">media resource</a> is loaded.
  The <a href="#initial-playback-position">initial playback position</a> is a time on the <a href="#media-timeline">media timeline</a>.</p>

  <p>If the <a href="#media-resource">media resource</a> is a streaming resource, then the user agent might be unable
  to obtain certain parts of the resource after it has expired from its buffer. Similarly, some
  <a data-anolis-xref="media resource" href="#media-resource">media resources</a> might have a <a href="#media-timeline">media timeline</a> that
  doesn't start at zero. The <dfn id="earliest-possible-position">earliest possible position</dfn> is the earliest position in the
  stream or resource that the user agent can ever obtain again. It is also a time on the <a href="#media-timeline">media
  timeline</a>.</p>

  <p class="note">The <a href="#earliest-possible-position">earliest possible position</a> is not explicitly exposed in the API;
  it corresponds to the start time of the first range in the <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code> attribute's <code><a href="#timeranges">TimeRanges</a></code> object, if any, or
  the <a href="#current-playback-position">current playback position</a> otherwise.</p>

  <p>When the <a href="#earliest-possible-position">earliest possible position</a> changes, then: if the <a href="#current-playback-position">current playback
  position</a> is before the <a href="#earliest-possible-position">earliest possible position</a>, the user agent must <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to the <a href="#earliest-possible-position">earliest possible position</a>; otherwise, if
  the user agent has not fired a <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> event at the
  element in the past 15 to 250ms and is not still running event handlers for such an event, then
  the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the element.</p>

  <p class="note">Because of the above requirement and the requirement in the <a data-anolis-xref="concept-media-load-resource" href="#concept-media-load-resource">resource fetch algorithm</a> that kicks in <a href="#getting-media-metadata">when the metadata of the clip becomes known</a>, the <a href="#current-playback-position">current
  playback position</a> can never be less than the <a href="#earliest-possible-position">earliest possible position</a>.</p><!-- see https://www.w3.org/Bugs/Public/show_bug.cgi?id=14492 --><!-- basically this is to handle very-long-running streams that use different video and audio
       tracks per TV show -->

  
  

  <p>If at any time the user agent learns that an audio or video track has ended and all <a href="#media-data">media
  data</a> relating to that track corresponds to parts of the <a href="#media-timeline">media timeline</a> that
  are <em>before</em> the <a href="#earliest-possible-position">earliest possible position</a>, the user agent may <a href="webappapis.html#queue-a-task">queue a
  task</a> to first remove the track from the <code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code>
  attribute's <code><a href="#audiotracklist">AudioTrackList</a></code> object or the <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code> attribute's <code><a href="#videotracklist">VideoTrackList</a></code> object as
  appropriate and then <a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-media-removetrack"><a href="#event-media-removetrack">removetrack</a></code>, that does not bubble and is not cancelable, and that
  uses the <code><a href="#trackevent">TrackEvent</a></code> interface, with the <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code> attribute initialised to the <code><a href="#audiotrack">AudioTrack</a></code> or
  <code><a href="#videotrack">VideoTrack</a></code> object representing the track, at the <a href="#media-element">media element</a>'s
  aforementioned <code><a href="#audiotracklist">AudioTrackList</a></code> or <code><a href="#videotracklist">VideoTrackList</a></code> object.</p>

  <p>The <dfn data-anolis-xref="dom-media-duration" id="dom-media-duration"><code>duration</code></dfn> attribute must return the time
  of the end of the <a href="#media-resource">media resource</a>, in seconds, on the <a href="#media-timeline">media timeline</a>. If
  no <a href="#media-data">media data</a> is available, then the attributes must return the Not-a-Number (NaN)
  value. If the <a href="#media-resource">media resource</a> is not known to be bounded (e.g. streaming radio, or a
  live event with no announced end time), then the attribute must return the positive Infinity
  value.</p>

  <p>The user agent must determine the duration of the <a href="#media-resource">media resource</a> before playing
  any part of the <a href="#media-data">media data</a> and before setting <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> to a value equal to or greater than <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>, even if doing so requires fetching multiple
  parts of the resource.</p>

  <p id="durationChange">When the length of the <a href="#media-resource">media resource</a> changes to a known value
  (e.g. from being unknown to known, or from a previously established length to a new length) the
  user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-durationchange"><a href="#event-media-durationchange">durationchange</a></code> at the <a href="#media-element">media element</a>. (The
  event is not fired when the duration is reset as part of loading a new media resource.) If the
  duration is changed such that the <a href="#current-playback-position">current playback position</a> ends up being greater
  than the time of the end of the <a href="#media-resource">media resource</a>, then the user agent must also <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to the time of the end of the <a href="#media-resource">media resource</a>.</p>

  <p class="example">If an "infinite" stream ends for some reason, then the duration would change
  from positive Infinity to the time of the last frame or sample in the stream, and the <code data-anolis-xref="event-media-durationchange"><a href="#event-media-durationchange">durationchange</a></code> event would be fired. Similarly, if the
  user agent initially estimated the <a href="#media-resource">media resource</a>'s duration instead of determining
  it precisely, and later revises the estimate based on new information, then the duration would
  change and the <code data-anolis-xref="event-media-durationchange"><a href="#event-media-durationchange">durationchange</a></code> event would be
  fired.</p>

  <p>Some video files also have an explicit date and time corresponding to the zero time in the
  <a href="#media-timeline">media timeline</a>, known as the <dfn id="timeline-offset">timeline offset</dfn>. Initially, the
  <a href="#timeline-offset">timeline offset</a> must be set to Not-a-Number (NaN).</p>

  <p>The <dfn data-anolis-xref="dom-media-getStartDate" id="dom-media-getstartdate"><code>getStartDate()</code></dfn> method must return <a data-anolis-xref="create a Date object" href="infrastructure.html#create-a-date-object">a new <code>Date</code> object</a> representing the current
  <a href="#timeline-offset">timeline offset</a>.</p>

  </div>

  <hr><p><dfn data-anolis-xref="attr-media-loop" id="attr-media-loop"><code>loop</code></dfn>属性は<a href="infrastructure.html#boolean-attribute">真偽属性</a>であり、指定される場合、終端に達すると<a href="#media-resource">メディアリソース</a>の先頭に戻ってシークする<a href="#media-element">メディア要素</a>であることを示す。</p>

  <p>要素が<a href="#current-media-controller">現在のメディアコントローラ</a>を持つ一方で、<code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code>属性は効果がない。</p>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-loop" id="dom-media-loop"><code>loop</code></dfn> IDL attribute must <a href="infrastructure.html#reflect">reflect</a>
  the content attribute of the same name.</p>

  </div>



  <h5 id="ready-states"><span class="secno">4.7.14.7</span> 準備状態</h5>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code></dt>

   <dd>

    <p>以下のリストのコードから、<a href="#current-playback-position">現在の再生位置</a>をレンダリングに対する要素の現在の状態を表す値を返す。</p>

   </dd>

  </dl><div class="impl">

  <p><a data-anolis-xref="media element" href="#media-element">Media elements</a> have a <i>ready state</i>, which describes to
  what degree they are ready to be rendered at the <a href="#current-playback-position">current playback position</a>. The
  possible values are as follows; the ready state of a media element at any particular time is the
  greatest value describing the state of the element:</p>

  </div>

  <dl><dt><dfn data-anolis-xref="dom-media-HAVE_NOTHING" id="dom-media-have_nothing"><code>HAVE_NOTHING</code></dfn>（数値0）</dt>

   <dd><p><a href="#media-resource">メディアリソース</a>に関する情報が入手できない。<a href="#current-playback-position">現在の再生位置</a>のデータが入手できない。<code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>属性が<code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>に設定される<a data-anolis-xref="media element" href="#media-element">メディア要素</a>は常に<code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>状態にある。</dd>

   <dt><dfn data-anolis-xref="dom-media-HAVE_METADATA" id="dom-media-have_metadata"><code>HAVE_METADATA</code></dfn>（数値1）</dt>

   <dd><p>リソースの継続時間が使用可能であるような、十分なリソースが得られている。<code><a href="#the-video-element">video</a></code>要素の場合、ビデオの寸法もまた利用可能である。シーク時にAPIはもはや例外を投げない。<a href="#media-data">メディアデータ</a>は、すぐに<a href="#current-playback-position">現在の再生位置</a>に対して利用できない。</dd>

   <dt><dfn data-anolis-xref="dom-media-HAVE_CURRENT_DATA" id="dom-media-have_current_data"><code>HAVE_CURRENT_DATA</code></dfn>（数値2）</dt>

   <dd><p>直接の<a href="#current-playback-position">現在の再生位置</a>に対するデータは使用可能であるが、直ちに<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>状態に戻ることなく、まったく<a href="#direction-of-playback">再生方向</a>にない<a href="#current-playback-position">現在の再生位置</a>を正常に進めることができるユーザーエージェントを利用可能とするのに十分なデータがないか、<a href="#direction-of-playback">再生方向</a>で入手するためのこれ以上データが存在しないかのいずれかである。たとえば、ビデオにおいて<a href="#current-playback-position">現在の再生位置</a>が現在のフレームの端にある、および<a data-anolis-xref="ended playback" href="#ended-playback">再生が終了した</a>場合、これは次のフレームではなく、現在のフレームからデータを持つユーザーエージェントに対応する。</dd>

   <dt><dfn data-anolis-xref="dom-media-HAVE_FUTURE_DATA" id="dom-media-have_future_data"><code>HAVE_FUTURE_DATA</code></dfn>（数値3）</dt>

   <dd><p>直接の<a href="#current-playback-position">現在の再生位置</a>に対するデータが利用可能であり、直ちに<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>の状態に戻ることなく、少なくとも<a href="#direction-of-playback">再生方向</a>での<a href="#current-playback-position">現在の再生位置</a>を進めるためのユーザーエージェントに対する十分なデータが同様にあり、<a href="#the-text-tracks-are-ready">テキストトラックは準備が整う</a>。たとえば、ビデオにおいて、<a href="#current-playback-position">現在の再生位置</a>が2つのフレーム間の瞬間である際に、少なくとも現在のフレームと次のフレームに対するデータを持つユーザーエージェントにこれは対応するか、<a href="#current-playback-position">現在の再生位置</a>がフレームの途中にある際、少なくとも再生を維持するための現在のフレームと音声データに対するビデオデータを持つユーザーエージェントに対応する。この場合において、<a href="#current-playback-position">現在の再生位置</a>は進めることはできないので、<a data-anolis-xref="ended playback" href="#ended-playback">再生が終了した</a>場合にユーザーエージェントはこの状態にはならない。</dd>

   <dt><dfn data-anolis-xref="dom-media-HAVE_ENOUGH_DATA" id="dom-media-have_enough_data"><code>HAVE_ENOUGH_DATA</code></dfn>（数値4）</dt>

   <dd>

   <p><code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>状態について説明されるすべての条件が満たされ、加えて、以下のいずれかの条件が真である：</p>

    <ul><li>ユーザーエージェントが<a href="#current-playback-position">現在の再生位置</a>で速度を取得されているデータを推定し、<a href="#effective-playback-rate">効果的な再生速度</a>で前進する場合、<a href="#media-resource">メディアリソース</a>の最後に到達する前に利用可能なデータに追いつかないだろう。</li>

     <li>ここでより長く待つことは、さらなるデータが得られることにはならないので、ユーザーエージェントは状態を入力し、したがってそれ以上の再生を遅らせることによって、何も得られないであろう。（たとえば、バッファがいっぱいになるかもしれない。）</li>

    </ul></dd>

  </dl><p class="note">実際には、<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>と<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>との違いはごくわずかである。<code><a href="scripting-1.html#the-canvas-element">canvas</a></code>に<code><a href="#the-video-element">video</a></code>要素を描画する際のみ、本当に違いが関連している。ここで、何かが描画される（<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>以上）場合と何も描画されない（<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>以下）場合を区別する。同様に、<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>（現在のフレームのみ）と<code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>（少なくともこのフレームと次）の差は、無視できる（極端には、1フレームだけ）。ページが"フレームごとの"ナビゲーションにインターフェースを提供する際に、方向が本当に重要な単なる時間である。</p>

  <div class="impl">

  <p>When the ready state of a <a href="#media-element">media element</a> whose <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> is not <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code> changes, the user agent must follow the steps
  given below:</p>

  <ol><li>

    <p>Apply the first applicable set of substeps from the following list:</p>


    <dl class="switch"><!-- going up to metadata --><dt>If the previous ready state was <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>,
     and the new ready state is <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code></dt>

     <dd id="fire-loadedmetadata">

      <p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-loadedmetadata"><a href="#event-media-loadedmetadata">loadedmetadata</a></code> at the element.</p>

      <p class="note">Before this task is run, as part of the <a href="webappapis.html#event-loop">event loop</a> mechanism, the
      rendering will have been updated to resize the <code><a href="#the-video-element">video</a></code> element if appropriate.</p>

     </dd><!-- going up to current for the first time -->

     

     <dt id="handling-first-frame-available">If the previous ready state was <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code> and the new ready state is <code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code> or greater</dt>

     <dd>

      <p id="fire-loadeddata">If this is the first time this occurs for this <a href="#media-element">media
      element</a> since the <code data-anolis-xref="dom-media-load"><a href="#dom-media-load">load()</a></code> algorithm was last
      invoked, the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a>
      named <code data-anolis-xref="event-media-loadeddata"><a href="#event-media-loadeddata">loadeddata</a></code> at the element.</p>

      <p>If the new ready state is <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>
      or <code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code>, then the relevant steps
      below must then be run also.</p>

     </dd><!-- going down -->

     
     <dt>If the previous ready state was <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code> or more, and the new ready state is
     <code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code> or less</dt>

     <dd>

      <p id="fire-waiting-when-waiting">If the <a href="#media-element">media element</a> was <a href="#potentially-playing">potentially
      playing</a> before its <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute
      changed to a value lower than <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>, and the element has not
      <a href="#ended-playback">ended playback</a>, and playback has not <a href="#stopped-due-to-errors">stopped due to errors</a>,
      <a href="#paused-for-user-interaction">paused for user interaction</a>, or <a href="#paused-for-in-band-content">paused for in-band content</a>, the user
      agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the element, and <a href="webappapis.html#queue-a-task">queue a task</a>
      to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-waiting"><a href="#event-media-waiting">waiting</a></code> at
      the element.</p>

     </dd><!-- going up to future -->

     
     <dt>If the previous ready state was <code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code> or less, and the new ready state
     is <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code></dt>

     <dd>

      <p>The user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named
      <code data-anolis-xref="event-media-canplay"><a href="#event-media-canplay">canplay</a></code> at the element.</p>

      <p>If the element's <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is false, the user
      agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-playing"><a href="#event-media-playing">playing</a></code> at the element.</p>

     </dd><!-- going up to enough -->

     
     <dt>If the new ready state is <code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code></dt>

     <dd>

      <p>If the previous ready state was <code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code> or less, the user agent must
      <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-canplay"><a href="#event-media-canplay">canplay</a></code> at the element, and, if the element's <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is false, <a href="webappapis.html#queue-a-task">queue a task</a> to
      <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-playing"><a href="#event-media-playing">playing</a></code>
      at the element.</p>

      <p>If the <a href="#autoplaying-flag">autoplaying flag</a> is true, and the <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is true, and the <a href="#media-element">media element</a>
      has an <code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code> attribute specified, and the
      <a href="#media-element">media element</a>'s <code><a href="dom.html#document">Document</a></code>'s <a href="browsers.html#active-sandboxing-flag-set">active sandboxing flag set</a>
      does not have the <a href="browsers.html#sandboxed-automatic-features-browsing-context-flag">sandboxed automatic features browsing context flag</a> set, then
      the user agent may also run the following substeps:</p>

      <ol><li>Set the <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute to false.</li>

       <li>If the element's <a href="#show-poster-flag">show poster flag</a> is true, set it to false and run the
       <i><a href="#time-marches-on">time marches on</a></i> steps.</li>

       <li><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-play"><a href="#event-media-play">play</a></code> at the element.</li>

       <li><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-playing"><a href="#event-media-playing">playing</a></code> at the element.</li>

      </ol><p class="note">User agents do not need to support autoplay, and it is suggested that user
      agents honor user preferences on the matter. Authors are urged to use the <code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code> attribute rather than using script to force the
      video to play, so as to allow the user to override the behavior if so desired.</p>

      <p>In any case, the user agent must finally <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
      event</a> named <code data-anolis-xref="event-media-canplaythrough"><a href="#event-media-canplaythrough">canplaythrough</a></code> at the element.</p>

     </dd>

    </dl></li>

   <li><p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, then
   <a href="#report-the-controller-state">report the controller state</a> for the <a href="#media-element">media element</a>'s <a href="#current-media-controller">current media
   controller</a>.</li>

  </ol></div>

  <p class="note">メディア要素の準備状態は、これらの状態間を不連続にジャンプすることが可能である。たとえば、メディア要素の状態は、<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>と<code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>状態を経由せずに<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>から<code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code>に直接ジャンプできる。</p>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-readyState" id="dom-media-readystate"><code>readyState</code></dfn> IDL attribute must, on
  getting, return the value described above that describes the current ready state of the
  <a href="#media-element">media element</a>.</p>

  </div>

  <p><dfn data-anolis-xref="attr-media-autoplay" id="attr-media-autoplay"><code>autoplay</code></dfn>属性は<a href="infrastructure.html#boolean-attribute">真偽属性</a>である。When present, the user agent <span class="impl">(as described in the algorithm described herein)</span> will automatically begin playback of the <a href="#media-resource">media resource</a> as soon as it can do so without stopping.</p>

  <p class="note">著者は、望まれない場合、たとえばスクリーンリーダーを使用する場合、ユーザーが自動再生を上書きできるよう、自動再生を誘発するためのスクリプトを使用するよりも、<code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code>属性を使用するように促される。著者はまた、一切自動再生の動作を使用することなく、代わりに明示的に再生を開始するためのユーザーに対してユーザーエージェントが待機しないよう考慮することが推奨される。</p>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-autoplay" id="dom-media-autoplay"><code>autoplay</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the content attribute of the same name.</p>

  </div>



  <h5 id="playing-the-media-resource"><span class="secno">4.7.14.8</span> メディアリソースの再生</h5>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code></dt>

   <dd>

    <p>再生が一時停止された場合はtrueを返し、そうでなければfalseを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-ended"><a href="#dom-media-ended">ended</a></code></dt>

   <dd>

    <p>再生が<a href="#media-resource">メディアリソース</a>の終わりに達した場合trueを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p><a href="#media-resource">メディアリソース</a>を介してユーザーが早送りまたは巻き戻ししない場合に対し、再生のデフォルト率を返す。</p>

    <p>再生のデフォルト率を変更する設定が可能である。</p>

    <p>デフォルト率は再生に直接影響を与えないが、ユーザーが早送りモードに切り替えた場合、モードが通常の再生モードに戻った際に、再生速度が再生のデフォルト率に戻されることが期待される。</p>

    <p>要素が<a href="#current-media-controller">現在のメディアコントローラ</a>を持つ場合、<code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a></code>属性は無視され、<a href="#current-media-controller">現在のメディアコントローラ</a>の<code data-anolis-xref="dom-MediaController-defaultPlaybackRate"><a href="#dom-mediacontroller-defaultplaybackrate">defaultPlaybackRate</a></code>が代わりに使用される。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate">playbackRate</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>現在の再生率を返す。ここで1.0が通常の速度である。</p>

    <p>再生速度を変更する設定が可能である。</p>

    <p>要素が<a href="#current-media-controller">現在のメディアコントローラ</a>を持つ場合、<code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate">playbackRate</a></code>属性は無視され、<a href="#current-media-controller">現在のメディアコントローラ</a>の<code data-anolis-xref="dom-MediaController-playbackRate"><a href="#dom-mediacontroller-playbackrate">playbackRate</a></code>が代わりに使用される。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-played"><a href="#dom-media-played">played</a></code></dt>

   <dd>

    <p>ユーザーエージェントが再生した<a href="#media-resource">メディアリソース</a>の範囲を表す<code><a href="#timeranges">TimeRanges</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-play"><a href="#dom-media-play">play</a></code>()</dt>

   <dd>

    <p>必要に応じて<a href="#media-resource">メディアリソース</a>を読み込んで再生を開始し、<code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>属性をfalseに設定する。再生が終了した場合、最初からリソースを再スタートする。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-pause"><a href="#dom-media-pause">pause</a></code>()</dt>

   <dd>

    <p>必要に応じて、<a href="#media-resource">メディアリソース</a>を読み込み、<code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>属性をtrueに設定する。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-paused" id="dom-media-paused"><code>paused</code></dfn> attribute represents whether the
  <a href="#media-element">media element</a> is paused or not. The attribute must initially be true.</p>

  <p>A <a href="#media-element">media element</a> is a <dfn id="blocked-media-element">blocked media element</dfn> if its <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is in the <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code> state, the <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code> state, or the <code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code> state, or if the element has
  <a href="#paused-for-user-interaction">paused for user interaction</a> or <a href="#paused-for-in-band-content">paused for in-band content</a>.</p>

  <p>A <a href="#media-element">media element</a> is said to be <dfn id="potentially-playing">potentially playing</dfn> when its <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is false, the element has not <a href="#ended-playback">ended
  playback</a>, playback has not <a href="#stopped-due-to-errors">stopped due to errors</a>, the element either has no
  <a href="#current-media-controller">current media controller</a> or has a <a href="#current-media-controller">current media controller</a> but is not
  <a href="#blocked-on-its-media-controller">blocked on its media controller</a>, and the element is not a <a href="#blocked-media-element">blocked media
  element</a>.</p>

  <p class="note">A <code data-anolis-xref="event-media-waiting"><a href="#event-media-waiting">waiting</a></code> DOM event <a href="#fire-waiting-when-waiting">can be fired</a> as a result of an element that is
  <a href="#potentially-playing">potentially playing</a> stopping playback due to its <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute changing to a value lower than <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>.</p>

  <p>A <a href="#media-element">media element</a> is said to have <dfn id="ended-playback">ended playback</dfn> when:</p>

  <ul><li>The element's <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code> or greater, and

   

   </li><li>

    <p>Either:

    

    <ul><li>The <a href="#current-playback-position">current playback position</a> is the end of the <a href="#media-resource">media resource</a>,
     and

     

     </li><li>The <a href="#direction-of-playback">direction of playback</a> is forwards, and

     

     </li><li>Either the <a href="#media-element">media element</a> does not have a <code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code> attribute specified, or the <a href="#media-element">media element</a> has
     a <a href="#current-media-controller">current media controller</a>.

    

    </li></ul><p>または：

    <ul><li>The <a href="#current-playback-position">current playback position</a> is the <a href="#earliest-possible-position">earliest possible position</a>,
     and

     

     </li><li>The <a href="#direction-of-playback">direction of playback</a> is backwards.

    

    </li></ul></li>

  </ul><p>The <dfn data-anolis-xref="dom-media-ended" id="dom-media-ended"><code>ended</code></dfn> attribute must return true if, the
  last time the <a href="webappapis.html#event-loop">event loop</a> reached step 1, the <a href="#media-element">media element</a> had
  <a href="#ended-playback">ended playback</a> and the <a href="#direction-of-playback">direction of playback</a> was forwards, and false
  otherwise.</p>

  <p>A <a href="#media-element">media element</a> is said to have <dfn id="stopped-due-to-errors">stopped due to errors</dfn> when the
  element's <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code> or greater, and the user agent <a href="#non-fatal-media-error">encounters a non-fatal error</a> during the processing of the
  <a href="#media-data">media data</a>, and due to that error, is not able to play the content at the
  <a href="#current-playback-position">current playback position</a>.</p>

  <p>A <a href="#media-element">media element</a> is said to have <dfn id="paused-for-user-interaction">paused for user interaction</dfn> when its
  <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is false, the <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is either <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code> or <code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code> and the user agent has reached a point
  in the <a href="#media-resource">media resource</a> where the user has to make a selection for the resource to
  continue. If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a> when this
  happens, then the user agent must <a href="#report-the-controller-state">report the controller state</a> for the <a href="#media-element">media
  element</a>'s <a href="#current-media-controller">current media controller</a>. If the <a href="#media-element">media element</a> has a
  <a href="#current-media-controller">current media controller</a> when the user makes a selection, allowing playback to
  resume, the user agent must similarly <a href="#report-the-controller-state">report the controller state</a> for the <a href="#media-element">media
  element</a>'s <a href="#current-media-controller">current media controller</a>.</p>

  <p>It is possible for a <a href="#media-element">media element</a> to have both <a href="#ended-playback">ended playback</a> and
  <a href="#paused-for-user-interaction">paused for user interaction</a> at the same time.</p>

  <p>When a <a href="#media-element">media element</a> that is <a href="#potentially-playing">potentially playing</a> stops playing
  because it has <a href="#paused-for-user-interaction">paused for user interaction</a>, the user agent must <a href="webappapis.html#queue-a-task">queue a
  task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the element.</p>

  <p>A <a href="#media-element">media element</a> is said to have <dfn id="paused-for-in-band-content">paused for in-band content</dfn> when its
  <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is false, the <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute is either <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code> or <code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code> and the user agent has suspended
  playback of the <a href="#media-resource">media resource</a> in order to play content that is temporally anchored
  to the <a href="#media-resource">media resource</a> and has a non-zero length, or to play content that is
  temporally anchored to a segment of the <a href="#media-resource">media resource</a> but has a length longer than
  that segment. If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a> when
  this happens, then the user agent must <a href="#report-the-controller-state">report the controller state</a> for the
  <a href="#media-element">media element</a>'s <a href="#current-media-controller">current media controller</a>. If the <a href="#media-element">media
  element</a> has a <a href="#current-media-controller">current media controller</a> when the user agent unsuspends
  playback, the user agent must similarly <a href="#report-the-controller-state">report the controller state</a> for the
  <a href="#media-element">media element</a>'s <a href="#current-media-controller">current media controller</a>.</p>

  <p class="example">One example of when a <a href="#media-element">media element</a> would be <a href="#paused-for-in-band-content">paused for
  in-band content</a> is when the user agent is playing <a data-anolis-xref="attr-track-kind-descriptions" href="#attr-track-kind-descriptions">audio descriptions</a> from an external WebVTT file, and
  the synthesized speech generated for a cue is longer than the time between the <a href="#text-track-cue-start-time">text track
  cue start time</a> and the <a href="#text-track-cue-end-time">text track cue end time</a>.</p>

  <hr><p id="reaches-the-end">When the <a href="#current-playback-position">current playback position</a> reaches the end of the
  <a href="#media-resource">media resource</a> when the <a href="#direction-of-playback">direction of playback</a> is forwards, then the user
  agent must follow these steps:</p>

  <ol><li><p>If the <a href="#media-element">media element</a> has a <code data-anolis-xref="attr-media-loop"><a href="#attr-media-loop">loop</a></code>
   attribute specified and does not have a <a href="#current-media-controller">current media controller</a>, then <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to the <a href="#earliest-possible-position">earliest possible position</a> of the
   <a href="#media-resource">media resource</a> and abort these steps.</li><!-- v2/v3: We should fire a
   'looping' event here to explain why this immediately fires a 'playing' event, otherwise the
   'playing' event that fires from the readyState going from HAVE_CURRENT_DATA back to
   HAVE_FUTURE_DATA will seem inexplicable (since the normally matching 'ended' given below event
   doesn't fire in the loop case). --> 

   <li><p>As defined above, the <code data-anolis-xref="dom-media-ended"><a href="#dom-media-ended">ended</a></code> IDL attribute starts
   returning true once the <a href="webappapis.html#event-loop">event loop</a> returns to step 1.</li>

   <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the <a href="#media-element">media element</a>.</li>

   <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> that, if the <a href="#media-element">media element</a> does not have a
   <a href="#current-media-controller">current media controller</a>, and the <a href="#media-element">media element</a> has still <a href="#ended-playback">ended
   playback</a>, and the <a href="#direction-of-playback">direction of playback</a> is still forwards, and <a data-anolis-xref="dom-media-paused" href="#dom-media-paused">paused</a> is false, changes <a data-anolis-xref="dom-media-paused" href="#dom-media-paused">paused</a> to true and <a data-anolis-xref="fire a simple event" href="webappapis.html#fire-a-simple-event">fires a
   simple event</a> named <code data-anolis-xref="event-media-pause"><a href="#event-media-pause">pause</a></code> at the <a href="#media-element">media
   element</a>.</li>

   <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-ended"><a href="#event-media-ended">ended</a></code> at the <a href="#media-element">media element</a>.</li>

   <li><p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, then
   <a href="#report-the-controller-state">report the controller state</a> for the <a href="#media-element">media element</a>'s <a href="#current-media-controller">current media
   controller</a>.</li>

  </ol><p>When the <a href="#current-playback-position">current playback position</a> reaches the <a href="#earliest-possible-position">earliest possible
  position</a> of the <a href="#media-resource">media resource</a> when the <a href="#direction-of-playback">direction of playback</a> is
  backwards, then the user agent must only <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
  event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the element.</p>

  <p class="note">The word "reaches" here does not imply that the <a href="#current-playback-position">current playback
  position</a> needs to have changed during normal playback; it could be via <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seeking</a>, for instance.</p>

  <hr><p>The <dfn data-anolis-xref="dom-media-defaultPlaybackRate" id="dom-media-defaultplaybackrate"><code>defaultPlaybackRate</code></dfn> attribute
  gives the desired speed at which the <a href="#media-resource">media resource</a> is to play, as a multiple of its
  intrinsic speed. The attribute is mutable: on getting it must return the last value it was set to,
  or 1.0 if it hasn't yet been set; on setting the attribute must be set to the new value.</p>

  <p class="note">The <code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a></code> is used
  by the user agent when it <a data-anolis-xref="expose a user interface to the user" href="#expose-a-user-interface-to-the-user">exposes a user
  interface to the user</a>.</p>

  <p>The <dfn data-anolis-xref="dom-media-playbackRate" id="dom-media-playbackrate"><code>playbackRate</code></dfn> attribute gives the
  <a href="#effective-playback-rate">effective playback rate</a> (assuming there is no <a href="#current-media-controller">current media controller</a>
  overriding it), which is the speed at which the <a href="#media-resource">media resource</a> plays, as a multiple
  of its intrinsic speed. If it is not equal to the <code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a></code>, then the implication is that the
  user is using a feature such as fast forward or slow motion playback. The attribute is mutable: on
  getting it must return the last value it was set to, or 1.0 if it hasn't yet been set; on setting
  the attribute must be set to the new value, and the playback will change speed (if the element is
  <a href="#potentially-playing">potentially playing</a> and there is no <a href="#current-media-controller">current media controller</a>).</p>

  <p id="rateUpdate">When the <code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a></code>
  or <code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate">playbackRate</a></code> attributes change value (either by
  being set by script or by being changed directly by the user agent, e.g. in response to user
  control) the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named
  <code data-anolis-xref="event-media-ratechange"><a href="#event-media-ratechange">ratechange</a></code> at the <a href="#media-element">media element</a>.</p>

  <p class="note">The <code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate">defaultPlaybackRate</a></code> and
  <code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate">playbackRate</a></code> attributes have no effect when the
  <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>; the namesake attributes on
  the <code><a href="#mediacontroller">MediaController</a></code> object are used instead in that situation.</p>

  <hr><p>The <dfn data-anolis-xref="dom-media-played" id="dom-media-played"><code>played</code></dfn> attribute must return a new static
  <a href="#normalised-timeranges-object">normalised <code>TimeRanges</code> object</a> that represents the ranges of points on the
  <a href="#media-timeline">media timeline</a> of the <a href="#media-resource">media resource</a> reached through the usual monotonic
  increase of the <a href="#current-playback-position">current playback position</a> during normal playback, if any, at the time
  the attribute is evaluated.</p>

  <hr><p>When the <dfn data-anolis-xref="dom-media-play" id="dom-media-play"><code>play()</code></dfn> method on a <a href="#media-element">media
  element</a> is invoked, the user agent must run the following steps.</p>

  <ol><li><p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute has the value <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>, invoke the <a href="#media-element">media element</a>'s
   <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a>.</li>

   <li>

    <p>If the <a data-anolis-xref="ended playback" href="#ended-playback">playback has ended</a> and the <a href="#direction-of-playback">direction of
    playback</a> is forwards, and the <a href="#media-element">media element</a> does not have a <a href="#current-media-controller">current
    media controller</a>, <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to the <a href="#earliest-possible-position">earliest possible
    position</a> of the <a href="#media-resource">media resource</a>.</p>

    <p class="note">This <a href="#seekUpdate">will cause</a> the user agent to <a href="webappapis.html#queue-a-task">queue a
    task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the <a href="#media-element">media element</a>.</p><!-- if we're already playing at this point, it might also fire 'waiting' -->
    

   </li>

   <li><p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, then
   <a href="#bring-the-media-element-up-to-speed-with-its-new-media-controller">bring the media element up to speed with its new media controller</a>.</p>

   </li><li>

    <p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is
    true, run the following substeps:</p>

    <ol><li><p>Change the value of <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> to false.</li>

     <li><p>If the <a href="#show-poster-flag">show poster flag</a> is true, set the element's <a href="#show-poster-flag">show poster
     flag</a> to false and run the <i><a href="#time-marches-on">time marches on</a></i> steps.</li>

     <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-play"><a href="#event-media-play">play</a></code> at the element.</li>

     <li>

      <p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>
      attribute has the value <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, <code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>, or <code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>, <a href="webappapis.html#queue-a-task">queue a task</a> to
      <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-waiting"><a href="#event-media-waiting">waiting</a></code> at the
      element.</p>

      <p>Otherwise, the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute has the value <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code> or <code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code>: <a href="webappapis.html#queue-a-task">queue a task</a> to
      <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-playing"><a href="#event-media-playing">playing</a></code> at the
      element.</p>

     </li>

    </ol></li>

   <li><p>Set the <a href="#media-element">media element</a>'s <a href="#autoplaying-flag">autoplaying flag</a> to false.</li>

   <li><p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, then
   <a href="#report-the-controller-state">report the controller state</a> for the <a href="#media-element">media element</a>'s <a href="#current-media-controller">current media
   controller</a>.</li>

  </ol><hr><p>When the <dfn data-anolis-xref="dom-media-pause" id="dom-media-pause"><code>pause()</code></dfn> method is invoked, and when
  the user agent is required to pause the <a href="#media-element">media element</a>, the user agent must run the
  following steps:</p>

  <ol><li><p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code> attribute has the value <code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>, invoke the <a href="#media-element">media element</a>'s
   <a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">resource selection algorithm</a>.</li>

   <li><p>Run the <a href="#internal-pause-steps">internal pause steps</a> for the <a href="#media-element">media element</a>.</li>

  </ol><p>The <dfn id="internal-pause-steps">internal pause steps</dfn> for a <a href="#media-element">media element</a> are as follows:</p>

  <ol><li><p>Set the <a href="#media-element">media element</a>'s <a href="#autoplaying-flag">autoplaying flag</a> to false.</li>

   <li><p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute
   is false, run the following steps:</p>

    <ol><li><p>Change the value of <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> to true.</li>

     <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
     event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the
     element.</li>

     <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
     event</a> named <code data-anolis-xref="event-media-pause"><a href="#event-media-pause">pause</a></code>
     at the element.</li>

     <li><p>Set the <a href="#official-playback-position">official playback position</a> to the <a href="#current-playback-position">current playback
     position</a>.</li>

    </ol></li>

   <li><p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, then
   <a href="#report-the-controller-state">report the controller state</a> for the <a href="#media-element">media element</a>'s <a href="#current-media-controller">current media
   controller</a>.</li>

  </ol><hr><p>The <dfn id="effective-playback-rate">effective playback rate</dfn> is not necessarily the element's <code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate">playbackRate</a></code>. When a <a href="#media-element">media element</a> has a
  <a href="#current-media-controller">current media controller</a>, its <a href="#effective-playback-rate">effective playback rate</a> is the
  <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-playback-rate">media controller playback rate</a>. Otherwise, the
  <a href="#effective-playback-rate">effective playback rate</a> is just the element's <code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate">playbackRate</a></code>. Thus, the <a href="#current-media-controller">current media
  controller</a> overrides the <a href="#media-element">media element</a>.</p>

  <p>If the <a href="#effective-playback-rate">effective playback rate</a> is positive or zero, then the <dfn id="direction-of-playback">direction of
  playback</dfn> is forwards. Otherwise, it is backwards.</p>

  <p id="media-playback">When a <a href="#media-element">media element</a> is <a href="#potentially-playing">potentially playing</a> and
  its <code><a href="dom.html#document">Document</a></code> is a <a href="browsers.html#fully-active">fully active</a> <code><a href="dom.html#document">Document</a></code>, its <a href="#current-playback-position">current
  playback position</a> must increase monotonically at <a href="#effective-playback-rate">effective playback rate</a> units
  of media time per unit time of the <a href="#media-timeline">media timeline</a>'s clock. (This specification always
  refers to this as an <i>increase</i>, but that increase could actually be a <em>de</em>crease if
  the <a href="#effective-playback-rate">effective playback rate</a> is negative.)</p>

  <p class="note">The <a href="#effective-playback-rate">effective playback rate</a> can be 0.0, in which case the
  <a href="#current-playback-position">current playback position</a> doesn't move, despite playback not being paused (<code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> doesn't become true, and the <code data-anolis-xref="event-media-pause"><a href="#event-media-pause">pause</a></code> event doesn't fire).</p>

  <p class="note">This specification doesn't define how the user agent achieves the appropriate
  playback rate — depending on the protocol and media available, it is plausible that the user
  agent could negotiate with the server to have the server provide the media data at the appropriate
  rate, so that (except for the period between when the rate is changed and when the server updates
  the stream's playback rate) the client doesn't actually have to drop or interpolate any
  frames.</p>

  <p>Any time the user agent <a data-anolis-xref="await a stable state" href="webappapis.html#await-a-stable-state">provides a stable state</a>,
  the <a href="#official-playback-position">official playback position</a> must be set to the <a href="#current-playback-position">current playback
  position</a>.</p><!-- cross-ref is intentionally to the other term, to help find this --> 

  <p>While the <a href="#direction-of-playback">direction of playback</a> is backwards, any corresponding audio must be
  <a data-anolis-xref="concept-media-muted" href="#concept-media-muted">muted</a>. While the <a href="#effective-playback-rate">effective playback rate</a> is
  so low or so high that the user agent cannot play audio usefully, the corresponding audio must
  also be <a data-anolis-xref="concept-media-muted" href="#concept-media-muted">muted</a>. If the <a href="#effective-playback-rate">effective playback
  rate</a> is not 1.0, the user agent may apply pitch adjustments to the audio as necessary to
  render it faithfully.</p>

  <p><a data-anolis-xref="media element" href="#media-element">Media elements</a> that are <a href="#potentially-playing">potentially playing</a>
  while not <a href="infrastructure.html#in-a-document">in a <code>Document</code></a> must not play any video, but should play any
  audio component. Media elements must not stop playing just because all references to them have
  been removed; only once a media element is in a state where no further audio could ever be played
  by that element may the element be garbage collected.</p>

  <p class="note">It is possible for an element to which no explicit references exist to play audio,
  even if such an element is not still actively playing: for instance, it could have a <a href="#current-media-controller">current
  media controller</a> that still has references and can still be unpaused, or it could be
  unpaused but stalled waiting for content to buffer.</p>

  <hr><p>Each <a href="#media-element">media element</a> has a <dfn id="list-of-newly-introduced-cues">list of newly introduced cues</dfn>, which must be
  initially empty. Whenever a <a href="#text-track-cue">text track cue</a> is added to the <a data-anolis-xref="text track
  list of cues" href="#text-track-list-of-cues">list of cues</a> of a <a href="#text-track">text track</a> that is in the <a href="#list-of-text-tracks">list of text
  tracks</a> for a <a href="#media-element">media element</a>, that <a data-anolis-xref="text track cue" href="#text-track-cue">cue</a> must
  be added to the <a href="#media-element">media element</a>'s <a href="#list-of-newly-introduced-cues">list of newly introduced cues</a>. Whenever
  a <a href="#text-track">text track</a> is added to the <a href="#list-of-text-tracks">list of text tracks</a> for a <a href="#media-element">media
  element</a>, all of the <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in that <a href="#text-track">text
  track</a>'s <a data-anolis-xref="text track list of cues" href="#text-track-list-of-cues">list of cues</a> must be added to the
  <a href="#media-element">media element</a>'s <a href="#list-of-newly-introduced-cues">list of newly introduced cues</a>. When a <a href="#media-element">media
  element</a>'s <a href="#list-of-newly-introduced-cues">list of newly introduced cues</a> has new cues added while the
  <a href="#media-element">media element</a>'s <a href="#show-poster-flag">show poster flag</a> is not set, then the user agent must
  run the <i><a href="#time-marches-on">time marches on</a></i> steps.</p>

  <p>When a <a href="#text-track-cue">text track cue</a> is removed from the <a data-anolis-xref="text track list of
  cues" href="#text-track-list-of-cues">list of cues</a> of a <a href="#text-track">text track</a> that is in the <a href="#list-of-text-tracks">list of text
  tracks</a> for a <a href="#media-element">media element</a>, and whenever a <a href="#text-track">text track</a> is removed
  from the <a href="#list-of-text-tracks">list of text tracks</a> of a <a href="#media-element">media element</a>, if the <a href="#media-element">media
  element</a>'s <a href="#show-poster-flag">show poster flag</a> is not set, then the user agent must run the
  <i><a href="#time-marches-on">time marches on</a></i> steps.</p>

  <p>When the <a href="#current-playback-position">current playback position</a> of a <a href="#media-element">media element</a> changes (e.g.
  due to playback or seeking), the user agent must run the <i><a href="#time-marches-on">time marches on</a></i> steps. If the
  <a href="#current-playback-position">current playback position</a> changes while the steps are running, then the user agent
  must wait for the steps to complete, and then must immediately rerun the steps. (These steps are
  thus run as often as possible or needed — if one iteration takes a long time, this can cause
  certain <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> to be skipped over as the user agent rushes ahead
  to "catch up".)</p>

  <p>The <dfn id="time-marches-on"><i>time marches on</i></dfn> steps are as follows:</p>

  <ol><li><p>Let <var data-anolis-xref="">current cues</var> be a list of <a data-anolis-xref="text track
   cue" href="#text-track-cue">cues</a>, initialised to contain all the <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> of all
   the <a data-anolis-xref="text track hidden" href="#text-track-hidden">hidden</a> or <a data-anolis-xref="text track
   showing" href="#text-track-showing">showing</a> <a data-anolis-xref="text track" href="#text-track">text tracks</a> of the <a href="#media-element">media
   element</a> (not the <a data-anolis-xref="text track disabled" href="#text-track-disabled">disabled</a> ones) whose <a data-anolis-xref="text track cue start time" href="#text-track-cue-start-time">start times</a> are less than or equal to the <a href="#current-playback-position">current
   playback position</a> and whose <a data-anolis-xref="text track cue end time" href="#text-track-cue-end-time">end times</a> are
   greater than the <a href="#current-playback-position">current playback position</a>.</li>

   <li><p>Let <var data-anolis-xref="">other cues</var> be a list of <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a>,
   initialised to contain all the <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> of <a data-anolis-xref="text
   track hidden" href="#text-track-hidden">hidden</a> and <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a> <a data-anolis-xref="text
   track" href="#text-track">text tracks</a> of the <a href="#media-element">media element</a> that are not present in <var data-anolis-xref="">current cues</var>.</li>

   <li><p>Let <var data-anolis-xref="">last time</var> be the <a href="#current-playback-position">current playback position</a> at the
   time this algorithm was last run for this <a href="#media-element">media element</a>, if this is not the first
   time it has run.</li>

   <li><p>If the <a href="#current-playback-position">current playback position</a> has, since the last time this algorithm was
   run, only changed through its usual monotonic increase during normal playback, then let <var data-anolis-xref="">missed cues</var> be the list of <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in <var data-anolis-xref="">other cues</var> whose <a data-anolis-xref="text track cue start time" href="#text-track-cue-start-time">start times</a> are
   greater than or equal to <var data-anolis-xref="">last time</var> and whose <a data-anolis-xref="text track cue end
   time" href="#text-track-cue-end-time">end times</a> are less than or equal to the <a href="#current-playback-position">current playback position</a>.
   Otherwise, let <var data-anolis-xref="">missed cues</var> be an empty list.</li>

   <li><p>Remove all the <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in <var data-anolis-xref="">missed cues</var>
   that are also in the <a href="#media-element">media element</a>'s <a href="#list-of-newly-introduced-cues">list of newly introduced cues</a>, and
   then empty the element's <a href="#list-of-newly-introduced-cues">list of newly introduced cues</a>.</li>

   <li><p>If the time was reached through the usual monotonic increase of the <a href="#current-playback-position">current playback
   position</a> during normal playback, and if the user agent has not fired a <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> event at the element in the past 15 to 250ms and
   is not still running event handlers for such an event, then the user agent must <a href="webappapis.html#queue-a-task">queue a
   task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the element. (In the other cases, such as
   explicit seeks, relevant events get fired as part of the overall process of changing the
   <a href="#current-playback-position">current playback position</a>.)</p>

   <p class="note">The event thus is not to be fired faster than about 66Hz or slower than 4Hz
   (assuming the event handlers don't take longer than 250ms to run). User agents are encouraged to
   vary the frequency of the event based on the system load and the average cost of processing the
   event each time, so that the UI updates are not any more frequent than the user agent can
   comfortably handle while decoding the video.</li>

   <li><p>If all of the <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in <var data-anolis-xref="">current cues</var>
   have their <a href="#text-track-cue-active-flag">text track cue active flag</a> set, none of the <a data-anolis-xref="text track
   cue" href="#text-track-cue">cues</a> in <var data-anolis-xref="">other cues</var> have their <a href="#text-track-cue-active-flag">text track cue active
   flag</a> set, and <var data-anolis-xref="">missed cues</var> is empty, then abort these steps.</li>

   <li>

    <p>If the time was reached through the usual monotonic increase of the <a href="#current-playback-position">current playback
    position</a> during normal playback, and there are <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a>
    in <var data-anolis-xref="">other cues</var> that have their <a href="#text-track-cue-pause-on-exit-flag">text track cue pause-on-exit flag</a>
    set and that either have their <a href="#text-track-cue-active-flag">text track cue active flag</a> set or are also in <var data-anolis-xref="">missed cues</var>, then immediately <a data-anolis-xref="dom-media-pause" href="#dom-media-pause">pause</a> the
    <a href="#media-element">media element</a>.  <!-- "pause" can in theory call load(), but never can it do so as
    part of this invocation, since we wouldn't be in this algorithm if the media element was empty.
    So, no need to couch all this in a task. --></p>

    <p class="note">In the other cases, such as explicit seeks, playback is not paused by going past
    the end time of a <a data-anolis-xref="text track cue" href="#text-track-cue">cue</a>, even if that <a data-anolis-xref="text track
    cue" href="#text-track-cue">cue</a> has its <a href="#text-track-cue-pause-on-exit-flag">text track cue pause-on-exit flag</a> set.</p>

   </li>

   <li>

    <p>Let <var data-anolis-xref="">events</var> be a list of <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a>,
    initially empty. Each <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> in this list will be associated
    with a <a href="#text-track">text track</a>, a <a href="#text-track-cue">text track cue</a>, and a time, which are used to
    sort the list before the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> are queued.</p>

    <p>Let <var data-anolis-xref="">affected tracks</var> be a list of <a data-anolis-xref="text track" href="#text-track">text
    tracks</a>, initially empty.</p>

    <p>When the steps below say to <dfn id="prepare-an-event">prepare an event</dfn> named <var data-anolis-xref="">event</var> for a
    <a href="#text-track-cue">text track cue</a> <var data-anolis-xref="">target</var> with a time <var data-anolis-xref="">time</var>, the
    user agent must run these substeps:</p>

    <ol><li><p>Let <var data-anolis-xref="">track</var> be the <a href="#text-track">text track</a> with which the <a href="#text-track-cue">text
     track cue</a> <var data-anolis-xref="">target</var> is associated.</li>

     <li><p>Create a <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a>
     named <var data-anolis-xref="">event</var> at <var data-anolis-xref="">target</var>.</li>

     <li><p>Add the newly created <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> to <var data-anolis-xref="">events</var>, associated with the time <var data-anolis-xref="">time</var>, the <a href="#text-track">text
     track</a> <var data-anolis-xref="">track</var>, and the <a href="#text-track-cue">text track cue</a> <var data-anolis-xref="">target</var>.</li>

     <li><p>Add <var data-anolis-xref="">track</var> to <var data-anolis-xref="">affected tracks</var>.</li>

    </ol></li>

   <li><p>For each <a data-anolis-xref="text track cue" href="#text-track-cue">text track cue</a> in <var data-anolis-xref="">missed
   cues</var>, <a href="#prepare-an-event">prepare an event</a> named <code data-anolis-xref="event-media-enter"><a href="#event-media-enter">enter</a></code> for the
   <code><a href="#texttrackcue">TextTrackCue</a></code> object with the <a href="#text-track-cue-start-time">text track cue start time</a>.</li>

   <li><p>For each <a data-anolis-xref="text track cue" href="#text-track-cue">text track cue</a> in <var data-anolis-xref="">other
   cues</var> that either has its <a href="#text-track-cue-active-flag">text track cue active flag</a> set or is in <var data-anolis-xref="">missed cues</var>, <a href="#prepare-an-event">prepare an event</a> named <code data-anolis-xref="event-media-exit"><a href="#event-media-exit">exit</a></code> for the <code><a href="#texttrackcue">TextTrackCue</a></code> object with the later of the
   <a href="#text-track-cue-end-time">text track cue end time</a> and the <a href="#text-track-cue-start-time">text track cue start time</a>.</li>

   <li><p>For each <a data-anolis-xref="text track cue" href="#text-track-cue">text track cue</a> in <var data-anolis-xref="">current
   cues</var> that does not have its <a href="#text-track-cue-active-flag">text track cue active flag</a> set, <a href="#prepare-an-event">prepare an
   event</a> named <code data-anolis-xref="event-media-enter"><a href="#event-media-enter">enter</a></code> for the <code><a href="#texttrackcue">TextTrackCue</a></code>
   object with the <a href="#text-track-cue-start-time">text track cue start time</a>.</li>

   <li>

    <p>Sort the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> in <var data-anolis-xref="">events</var> in ascending
    time order (<a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> with earlier times first).</p>

    <p>Further sort <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> in <var data-anolis-xref="">events</var> that have
    the same time by the relative <a href="#text-track-cue-order">text track cue order</a> of the <a data-anolis-xref="text track
    cue" href="#text-track-cue">text track cues</a> associated with these <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a>.</p>

    <p>Finally, sort <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> in <var data-anolis-xref="">events</var> that have
    the same time and same <a href="#text-track-cue-order">text track cue order</a> by placing <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> that fire <code data-anolis-xref="event-media-enter"><a href="#event-media-enter">enter</a></code> events before
    those that fire <code data-anolis-xref="event-media-exit"><a href="#event-media-exit">exit</a></code> events.</p>

   </li>

   <li><p><a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">Queue</a> each <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> in
   <var data-anolis-xref="">events</var>, in list order.</li>

   <li><p>Sort <var data-anolis-xref="">affected tracks</var> in the same order as the <a data-anolis-xref="text
   track" href="#text-track">text tracks</a> appear in the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text
   tracks</a>, and remove duplicates.</p>

   </li><li><p>For each <a href="#text-track">text track</a> in <var data-anolis-xref="">affected tracks</var>, in the list
   order, <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-cuechange"><a href="#event-media-cuechange">cuechange</a></code> at the <code><a href="#texttrack">TextTrack</a></code> object, and, if the
   <a href="#text-track">text track</a> has a corresponding <code><a href="#the-track-element">track</a></code> element, to then <a href="webappapis.html#fire-a-simple-event">fire a
   simple event</a> named <code data-anolis-xref="event-media-cuechange"><a href="#event-media-cuechange">cuechange</a></code> at the
   <code><a href="#the-track-element">track</a></code> element as well.</li>

   <li><p>Set the <a href="#text-track-cue-active-flag">text track cue active flag</a> of all the <a data-anolis-xref="text track
   cue" href="#text-track-cue">cues</a> in the <var data-anolis-xref="">current cues</var>, and unset the <a href="#text-track-cue-active-flag">text track cue
   active flag</a> of all the <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in the <var data-anolis-xref="">other
   cues</var>.</li>

   <li><p>Run the <a href="#rules-for-updating-the-text-track-rendering">rules for updating the text track rendering</a> of each of the <a data-anolis-xref="text track" href="#text-track">text tracks</a> in <var data-anolis-xref="">affected tracks</var> that are <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a>. For example, for <a data-anolis-xref="text track" href="#text-track">text
   tracks</a> based on <a href="infrastructure.html#webvtt">WebVTT</a>, the <a href="infrastructure.html#rules-for-updating-the-display-of-webvtt-text-tracks">rules for updating the display of WebVTT
   text tracks</a>. <a href="references.html#refsWEBVTT">[WEBVTT]</a> </li>

  </ol><p>For the purposes of the algorithm above, a <a href="#text-track-cue">text track cue</a> is considered to be part
  of a <a href="#text-track">text track</a> only if it is listed in the <a href="#text-track-list-of-cues">text track list of cues</a>, not
  merely if it is associated with the <a href="#text-track">text track</a>.</p>

  <p class="note">If the <a href="#media-element">media element</a>'s <code><a href="dom.html#document">Document</a></code> stops being a
  <a href="browsers.html#fully-active">fully active</a> document, then the playback will <a href="#media-playback">stop</a>
  until the document is active again.</p>

  <p>When a <a href="#media-element">media element</a> is <a data-anolis-xref="remove an element from a document" href="infrastructure.html#remove-an-element-from-a-document">removed
  from a <code>Document</code></a>, the user agent must run the following steps:</p>

  <ol><li><p>Asynchronously <a href="webappapis.html#await-a-stable-state">await a stable state</a>, allowing the <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that removed the <a href="#media-element">media element</a> from the
   <code><a href="dom.html#document">Document</a></code> to continue. The <a href="webappapis.html#synchronous-section">synchronous section</a> consists of all the
   remaining steps of this algorithm. (Steps in the <a href="webappapis.html#synchronous-section">synchronous section</a> are marked with
   ⌛.)</li>

   <li><p>⌛ If the <a href="#media-element">media element</a> is <a href="infrastructure.html#in-a-document">in a <code>Document</code></a>,
   abort these steps.</li>

   <li><p>⌛ Run the <a href="#internal-pause-steps">internal pause steps</a> for the <a href="#media-element">media element</a>.</p>

  </li></ol></div>



  <h5 id="seeking"><span class="secno">4.7.14.9</span> シーク</h5>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code></dt>

   <dd>

    <p>ユーザーエージェントが現在シークしている場合にtrueを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code></dt>

   <dd>

    <p>ユーザーエージェントがシーク可能である<a href="#media-resource">メディアリソース</a>の範囲を表す<code><a href="#timeranges">TimeRanges</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-fastSeek"><a href="#dom-media-fastseek">fastSeek</a></code>( <var data-anolis-xref="">time</var> )</dt>

   <dd>

    <p>高速化のため、できるだけ早く近くに与えられた<var data-anolis-xref="">time</var>をシークする。（正確な時刻を求めるために、<code data-anolis-xref="dom-media-currentTime"><a href="#dom-media-currenttime">currentTime</a></code>属性を使用する。）</p>

    <p>メディアリソースがロードされない場合、これは何もしない。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-seeking" id="dom-media-seeking"><code>seeking</code></dfn> attribute must initially have the
  value false.</p>

  <p>The <dfn data-anolis-xref="dom-media-fastSeek" id="dom-media-fastseek"><code>fastSeek()</code></dfn> method must <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to the time given by the method's argument, with the
  <i>approximate-for-speed</i> flag set.</p>

  <p>When the user agent is required to <dfn data-anolis-xref="dom-media-seek" id="dom-media-seek">seek</dfn> to a particular <var data-anolis-xref="">new playback position</var> in the <a href="#media-resource">media resource</a>, optionally with the
  <i>approximate-for-speed</i> flag set, it means that the user agent must run the following steps.
  This algorithm interacts closely with the <a href="webappapis.html#event-loop">event loop</a> mechanism; in particular, it has
  a <a href="webappapis.html#synchronous-section">synchronous section</a> (which is triggered as part of the <a href="webappapis.html#event-loop">event loop</a>
  algorithm). Steps in that section are marked with ⌛.</p>

  <ol><li><p>Set the <a href="#media-element">media element</a>'s <a href="#show-poster-flag">show poster flag</a> to false.</li>

   <li><p>If the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>
   is <code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>, abort these steps.</li>

   <li><p>If the element's <code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code> IDL attribute is true,
   then another instance of this algorithm is already running. Abort that other instance of the
   algorithm without waiting for the step that it is running to complete.</li>

   <li><p>Set the <code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code> IDL attribute to true.</li>

   <li><p>If the seek was in response to a DOM method call or setting of an IDL attribute, then
   continue the script. The remainder of these steps must be run asynchronously. With the exception
   of the steps marked with ⌛, they could be aborted at any time by another instance of this
   algorithm being invoked.</li>

   <li><p>If the <var data-anolis-xref="">new playback position</var> is later than the end of the <a href="#media-resource">media
   resource</a>, then let it be the end of the <a href="#media-resource">media resource</a> instead.</li>

   <li><p>If the <var data-anolis-xref="">new playback position</var> is less than the <a href="#earliest-possible-position">earliest possible
   position</a>, let it be that position instead.</li>

   <li><p>If the (possibly now changed) <var data-anolis-xref="">new playback position</var> is not in one of
   the ranges given in the <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code> attribute, then let it
   be the position in one of the ranges given in the <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code> attribute that is the nearest to the <var data-anolis-xref="">new
   playback position</var>. If two positions both satisfy that constraint (i.e. the <var data-anolis-xref="">new playback position</var> is exactly in the middle between two ranges in the <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code> attribute) then use the position that is closest to
   the <a href="#current-playback-position">current playback position</a>. If there are no ranges given in the <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code> attribute then set the <code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code> IDL attribute to false and abort these steps.</li>

   <li>

    <p>If the <i>approximate-for-speed</i> flag is set, adjust the <var data-anolis-xref="">new playback
    position</var> to a value that will allow for playback to resume promptly. If <var data-anolis-xref="">new
    playback position</var> before this step is before <a href="#current-playback-position">current playback position</a>, then
    the adjusted <var data-anolis-xref="">new playback position</var> must also be before the <a href="#current-playback-position">current
    playback position</a>. Similarly, if the <var data-anolis-xref="">new playback position</var> before
    this step is after <a href="#current-playback-position">current playback position</a>, then the adjusted <var data-anolis-xref="">new
    playback position</var> must also be after the <a href="#current-playback-position">current playback position</a>.</p>

    <p class="example">For example, the user agent could snap to the nearest key frame, so that it
    doesn't have to spend time decoding then discarding intermediate frames before resuming
    playback.</p>

    </li>

   <li><p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-seeking"><a href="#event-media-seeking">seeking</a></code> at the element.</li>

   <li>

    <p>Set the <a href="#current-playback-position">current playback position</a> to the given <var data-anolis-xref="">new playback
    position</var>.</p>

    <p class="note">If the <a href="#media-element">media element</a> was <a href="#potentially-playing">potentially playing</a>
    immediately before it started seeking, but seeking caused its <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> attribute to change to a value lower than <code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>, then a <code data-anolis-xref="event-media-waiting"><a href="#event-media-waiting">waiting</a></code> <a href="#fire-waiting-when-waiting">will be
    fired</a> at the element.</p><!-- also, timeupdate --><!-- also, it will do the "report the controller state" thing --> 
    

    <p class="note">This step sets the <a href="#current-playback-position">current playback position</a>, and thus can
    immediately trigger other conditions, such as the rules regarding when playback "<a href="#reaches-the-end">reaches the end of the media resource</a>" (part of the logic that
    handles looping), even before the user agent is actually able to render the media data for that
    position (as determined in the next step).</p>

    <p class="note">The <code data-anolis-xref="dom-media-currentTime"><a href="#dom-media-currenttime">currentTime</a></code> attribute does not
    get updated asynchronously, as it returns the <a href="#official-playback-position">official playback position</a>, not the
    <a href="#current-playback-position">current playback position</a>.</p>

   </li>

   <li><p>Wait until the user agent has established whether or not the <a href="#media-data">media data</a> for
   the <var data-anolis-xref="">new playback position</var> is available, and, if it is, until it has decoded
   enough data to play back that position.</p><!-- at which point, it will do the "port the controller state"
   thing again -->
   
   </li>

   <li><p><a href="webappapis.html#await-a-stable-state">Await a stable state</a>. The <a href="webappapis.html#synchronous-section">synchronous section</a> consists of all
   the remaining steps of this algorithm. (Steps in the <a href="webappapis.html#synchronous-section">synchronous section</a> are marked
   with ⌛.)</li>

   <li><p>⌛ Set the <code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code> IDL attribute to
   false.</li>

   <li><p>⌛ Run the <a href="#time-marches-on">time marches on</a> steps.</li>

   <li id="seekUpdate"><p>⌛ <a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a>
   named <code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code> at the element.</li>

   <li><p>⌛ <a href="webappapis.html#queue-a-task">Queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-seeked"><a href="#event-media-seeked">seeked</a></code> at the element.</li>

  </ol><hr><p>The <dfn data-anolis-xref="dom-media-seekable" id="dom-media-seekable"><code>seekable</code></dfn> attribute must return a new
  static <a href="#normalised-timeranges-object">normalised <code>TimeRanges</code> object</a> that represents the ranges of the
  <a href="#media-resource">media resource</a>, if any, that the user agent is able to seek to, at the time the
  attribute is evaluated.</p>

  <p class="note">If the user agent can seek to anywhere in the <a href="#media-resource">media resource</a>, e.g.
  because it is a simple movie file and the user agent and the server support HTTP Range requests,
  then the attribute would return an object with one range, whose start is the time of the first
  frame (the <a href="#earliest-possible-position">earliest possible position</a>, typically zero), and whose end is the same as
  the time of the first frame plus the <code data-anolis-xref="dom-media-duration"><a href="#dom-media-duration">duration</a></code> attribute's
  value (which would equal the time of the last frame, and might be positive Infinity).</p>

  <p class="note">The range might be continuously changing, e.g. if the user agent is buffering a
  sliding window on an infinite stream. This is the behavior seen with DVRs viewing live TV, for
  instance.</p>

  <p><a data-anolis-xref="media resource" href="#media-resource">Media resources</a> might be internally scripted or
  interactive. Thus, a <a href="#media-element">media element</a> could play in a non-linear fashion. If this
  happens, the user agent must act as if the algorithm for <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seeking</a> was used whenever the <a href="#current-playback-position">current playback position</a>
  changes in a discontinuous fashion (so that the relevant events fire). If the <a href="#media-element">media
  element</a> has a <a href="#current-media-controller">current media controller</a>, then the user agent must <a href="#seek-the-media-controller">seek
  the media controller</a> appropriately instead.  </p>

  </div>


  <h5 id="media-resources-with-multiple-media-tracks"><span class="secno">4.7.14.10</span> 複数のメディアトラックを伴うメディアリソース</h5>

  <p><a href="#media-resource">メディアリソース</a> は、複数の埋め込みオーディオおよびビデオトラックを持つことができる。たとえば、主ビデオトラックとオーディオトラックに加えて、<a href="#media-resource">メディアリソース</a>は、外国語吹き替えのやりとり、監督の解説、音声による説明、代替アングル、または手話のオーバーレイを持つかもしれない。</p>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code></dt>

   <dd>

    <p><a href="#media-resource">メディアリソース</a>で使用可能なオーディオトラックを表す<code><a href="#audiotracklist">AudioTrackList</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code></dt>

   <dd>

    <p><a href="#media-resource">メディアリソース</a>で使用可能なビデオトラックを表す<code><a href="#videotracklist">VideoTrackList</a></code>オブジェクトを返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-audioTracks" id="dom-media-audiotracks"><code>audioTracks</code></dfn> attribute of a
  <a href="#media-element">media element</a> must return a <a href="infrastructure.html#live">live</a> <code><a href="#audiotracklist">AudioTrackList</a></code> object
  representing the audio tracks available in the <a href="#media-element">media element</a>'s <a href="#media-resource">media
  resource</a>. The same object must be returned each time.</p>

  <p>The <dfn data-anolis-xref="dom-media-videoTracks" id="dom-media-videotracks"><code>videoTracks</code></dfn> attribute of a
  <a href="#media-element">media element</a> must return a <a href="infrastructure.html#live">live</a> <code><a href="#videotracklist">VideoTrackList</a></code> object
  representing the video tracks available in the <a href="#media-element">media element</a>'s <a href="#media-resource">media
  resource</a>. The same object must be returned each time.</p>

  <p class="note">There are only ever one <code><a href="#audiotracklist">AudioTrackList</a></code> object and one
  <code><a href="#videotracklist">VideoTrackList</a></code> object per <a href="#media-element">media element</a>, even if another <a href="#media-resource">media
  resource</a> is loaded into the element: the objects are reused. (The <code><a href="#audiotrack">AudioTrack</a></code>
  and <code><a href="#videotrack">VideoTrack</a></code> objects are not, though.)</p>

  </div>

  <div class="example">

   <p>この例において、スクリプトは、ビデオおよび動画が配置される要素の参照へのURLを取得する関数を定義する。その機能はビデオの読み込みを試み、そして、一度読み込まれると、利用可能な手話トラックがあるかどうかをチェックする。存在する場合、そのトラックも表示する。両方のトラックは与えられたコンテナにのみ配置される。スタイルが巧妙な方法でこの作業を行うために適用されることを前提にしている。</p>

   <pre>&lt;script&gt;
 function loadVideo(url, container) {
   var controller = new MediaController();
   var video = document.createElement('video');
   video.src = url;
   video.autoplay = true;
   video.controls = true;
   video.controller = controller;
   container.appendChild(video);
   video.onloadedmetadata = function (event) {
     for (var i = 0; i &lt; video.videoTracks.length; i += 1) {
       if (video.videoTracks[i].kind == 'sign') {
         var sign = document.createElement('video');
         sign.src = url + '#track=' + video.videoTracks[i].id; <!-- should escape this probably -->
         sign.autoplay = true;
         sign.controller = controller;
         container.appendChild(sign);
         return;
       }
     }
   };
 }
&lt;/script&gt;</pre>

  </div>


  <h6 id="audiotracklist-and-videotracklist-objects"><span class="secno">4.7.14.10.1</span> <code><a href="#audiotracklist">AudioTrackList</a></code>および<code><a href="#videotracklist">VideoTrackList</a></code>オブジェクト</h6>

  <p><code><a href="#audiotracklist">AudioTrackList</a></code>および<code><a href="#videotracklist">VideoTrackList</a></code>インターフェースは、前節で定義された属性で使用される。</p>

  <pre class="idl">interface <dfn id="audiotracklist">AudioTrackList</dfn> : <a href="infrastructure.html#eventtarget">EventTarget</a> {
  readonly attribute unsigned long <a data-anolis-xref="dom-AudioTrackList-length" href="#dom-audiotracklist-length">length</a>;
  getter <a href="#audiotrack">AudioTrack</a> (unsigned long index);
  <a href="#audiotrack">AudioTrack</a>? <a data-anolis-xref="dom-AudioTrackList-getTrackById" href="#dom-audiotracklist-gettrackbyid">getTrackById</a>(DOMString id);

           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TrackList-onchange" href="#handler-tracklist-onchange">onchange</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TrackList-onaddtrack" href="#handler-tracklist-onaddtrack">onaddtrack</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TrackList-onremovetrack" href="#handler-tracklist-onremovetrack">onremovetrack</a>;
};

interface <dfn id="audiotrack">AudioTrack</dfn> {
  readonly attribute DOMString <a data-anolis-xref="dom-AudioTrack-id" href="#dom-audiotrack-id">id</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-AudioTrack-kind" href="#dom-audiotrack-kind">kind</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-AudioTrack-label" href="#dom-audiotrack-label">label</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-AudioTrack-language" href="#dom-audiotrack-language">language</a>;
           attribute boolean <a data-anolis-xref="dom-AudioTrack-enabled" href="#dom-audiotrack-enabled">enabled</a>;
};

interface <dfn id="videotracklist">VideoTrackList</dfn> : <a href="infrastructure.html#eventtarget">EventTarget</a> {
  readonly attribute unsigned long <a data-anolis-xref="dom-VideoTrackList-length" href="#dom-videotracklist-length">length</a>;
  getter <a href="#videotrack">VideoTrack</a> (unsigned long index);
  <a href="#videotrack">VideoTrack</a>? <a data-anolis-xref="dom-VideoTrackList-getTrackById" href="#dom-videotracklist-gettrackbyid">getTrackById</a>(DOMString id);
  readonly attribute long <a data-anolis-xref="dom-VideoTrackList-selectedIndex" href="#dom-videotracklist-selectedindex">selectedIndex</a>;

           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TrackList-onchange" href="#handler-tracklist-onchange">onchange</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TrackList-onaddtrack" href="#handler-tracklist-onaddtrack">onaddtrack</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TrackList-onremovetrack" href="#handler-tracklist-onremovetrack">onremovetrack</a>;
};

interface <dfn id="videotrack">VideoTrack</dfn> {
  readonly attribute DOMString <a data-anolis-xref="dom-VideoTrack-id" href="#dom-videotrack-id">id</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-VideoTrack-kind" href="#dom-videotrack-kind">kind</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-VideoTrack-label" href="#dom-videotrack-label">label</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-VideoTrack-language" href="#dom-videotrack-language">language</a>;
           attribute boolean <a data-anolis-xref="dom-VideoTrack-selected" href="#dom-videotrack-selected">selected</a>;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code> . <code data-anolis-xref="dom-AudioTrackList-length"><a href="#dom-audiotracklist-length">length</a></code></dt>
   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code> . <code data-anolis-xref="dom-VideoTrackList-length"><a href="#dom-videotracklist-length">length</a></code></dt>

   <dd>

    <p>リスト内のトラックの数を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">audioTrack</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code>[<var data-anolis-xref="">index</var>]</dt>
   <dt><var data-anolis-xref="">videoTrack</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code>[<var data-anolis-xref="">index</var>]</dt>

   <dd>

    <p>指定<code><a href="#audiotrack">AudioTrack</a></code>または<code><a href="#videotrack">VideoTrack</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">audioTrack</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code> . <code data-anolis-xref="dom-AudioTrackList-getTrackById"><a href="#dom-audiotracklist-gettrackbyid">getTrackById</a></code>( <var data-anolis-xref="">id</var> )</dt>
   <dt><var data-anolis-xref="">videoTrack</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code> . <code data-anolis-xref="dom-VideoTrackList-getTrackById"><a href="#dom-videotracklist-gettrackbyid">getTrackById</a></code>( <var data-anolis-xref="">id</var> )</dt>

   <dd>

    <p>与えられた識別子とともに<code><a href="#audiotrack">AudioTrack</a></code>または<code><a href="#videotrack">VideoTrack</a></code>オブジェクトを返す、または一切トラックがその識別子を持たない場合nullを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">audioTrack</var> . <code data-anolis-xref="dom-AudioTrack-id"><a href="#dom-audiotrack-id">id</a></code></dt>
   <dt><var data-anolis-xref="">videoTrack</var> . <code data-anolis-xref="dom-VideoTrack-id"><a href="#dom-videotrack-id">id</a></code></dt>

   <dd>

    <p>指定されたトラックのIDを返す。フォーマットが<cite>Media Fragments URI</cite>構文をサポートし、<code data-anolis-xref="">getTrackById()</code>メソッドとともに使用できる場合、これは、フラグメント識別子で使用できるIDである。<a href="references.html#refsMEDIAFRAG">[MEDIAFRAG]</a></p>

   </dd>

   <dt><var data-anolis-xref="">audioTrack</var> . <code data-anolis-xref="dom-AudioTrack-kind"><a href="#dom-audiotrack-kind">kind</a></code></dt>
   <dt><var data-anolis-xref="">videoTrack</var> . <code data-anolis-xref="dom-VideoTrack-kind"><a href="#dom-videotrack-kind">kind</a></code></dt>

   <dd>

    <p>与えられたトラックに該当するカテゴリを返す。<a href="#dom-TrackList-getKind-categories">可能なトラックカテゴリ</a>は以下の通り。</p>

   </dd>

   <dt><var data-anolis-xref="">audioTrack</var> . <code data-anolis-xref="dom-AudioTrack-label"><a href="#dom-audiotrack-label">label</a></code></dt>
   <dt><var data-anolis-xref="">videoTrack</var> . <code data-anolis-xref="dom-VideoTrack-label"><a href="#dom-videotrack-label">label</a></code></dt>

   <dd>

    <p>既知の場合、指定されたトラックのラベルを返し、そうでなければ空文字列を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">audioTrack</var> . <code data-anolis-xref="dom-AudioTrack-language"><a href="#dom-audiotrack-language">language</a></code></dt>
   <dt><var data-anolis-xref="">videoTrack</var> . <code data-anolis-xref="dom-VideoTrack-language"><a href="#dom-videotrack-language">language</a></code></dt>

   <dd>

    <p>既知の場合、指定されたトラックの言語を返し、そうでなければ空の文字列を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">audioTrack</var> . <code data-anolis-xref="dom-AudioTrack-enabled"><a href="#dom-audiotrack-enabled">enabled</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>指定されたトラックがアクティブである場合、trueを返し、そうでなければfalseを返す。</p>

    <p>トラックが有効かどうかを変更する設定が可能である。複数のオーディオトラックが同時に有効である場合、それらが混在している。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code> . <code data-anolis-xref="dom-VideoTrackList-selectedIndex"><a href="#dom-videotracklist-selectedindex">selectedIndex</a></code></dt>

   <dd>

    <p>もしあれば、現在選択されているトラックのインデックスを返し、そうでなければ-1を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">videoTrack</var> . <code data-anolis-xref="dom-VideoTrack-selected"><a href="#dom-videotrack-selected">selected</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>指定されたトラックがアクティブである場合、trueを返し、そうでなければfalseを返す。</p>

    <p>トラックが選択されるかどうかを変更する設定が可能である。0個または1つのいずれかのビデオトラックが選択される。前の1つが選択されている間に新しいトラックを選択すると、1つ前の選択を解除する。</p>

   </dd>

  </dl><div class="impl">

  <p>An <code><a href="#audiotracklist">AudioTrackList</a></code> object represents a dynamic list of zero or more audio tracks,
  of which zero or more can be enabled at a time. Each audio track is represented by an
  <code><a href="#audiotrack">AudioTrack</a></code> object.</p>

  <p>A <code><a href="#videotracklist">VideoTrackList</a></code> object represents a dynamic list of zero or more video tracks, of
  which zero or one can be selected at a time. Each video track is represented by a
  <code><a href="#videotrack">VideoTrack</a></code> object.</p>

  <p>Tracks in <code><a href="#audiotracklist">AudioTrackList</a></code> and <code><a href="#videotracklist">VideoTrackList</a></code> objects must be
  consistently ordered. If the <a href="#media-resource">media resource</a> is in a format that defines an order,
  then that order must be used; otherwise, the order must be the relative order in which the tracks
  are declared in the <a href="#media-resource">media resource</a>. The order used is called the <i>natural order</i>
  of the list.</p>

  <p class="note">Each track in a <code>TrackList</code> thus has an index; the first has the index
  0, and each subsequent track is numbered one higher than the previous one. If a <a href="#media-resource">media
  resource</a> dynamically adds or removes audio or video tracks, then the indices of the tracks
  will change dynamically. If the <a href="#media-resource">media resource</a> changes entirely, then all the
  previous tracks will be removed and replaced with new tracks.</p>

  <p>The <dfn data-anolis-xref="dom-AudioTrackList-length" id="dom-audiotracklist-length"><code>AudioTrackList.length</code></dfn> and <dfn data-anolis-xref="dom-VideoTrackList-length" id="dom-videotracklist-length"><code>VideoTrackList.length</code></dfn> attributes must return
  the number of tracks represented by their objects at the time of getting.</p>

  <p>The <a href="infrastructure.html#supported-property-indices">supported property indices</a> of <code><a href="#audiotracklist">AudioTrackList</a></code> and
  <code><a href="#videotracklist">VideoTrackList</a></code> objects at any instant are the numbers from zero to the number of
  tracks represented by the respective object minus one, if any tracks are represented. If an
  <code><a href="#audiotracklist">AudioTrackList</a></code> or <code><a href="#videotracklist">VideoTrackList</a></code> object represents no tracks, it has no
  <a href="infrastructure.html#supported-property-indices">supported property indices</a>.</p>

  <p>To <a href="infrastructure.html#determine-the-value-of-an-indexed-property">determine the value of an indexed property</a> for a given index <var data-anolis-xref="">index</var> in an <code><a href="#audiotracklist">AudioTrackList</a></code> or <code><a href="#videotracklist">VideoTrackList</a></code> object <var data-anolis-xref="">list</var>, the user agent must return the <code><a href="#audiotrack">AudioTrack</a></code> or
  <code><a href="#videotrack">VideoTrack</a></code> object that represents the <var data-anolis-xref="">index</var>th track in <var data-anolis-xref="">list</var>.</p>

  <p>The <dfn data-anolis-xref="dom-AudioTrackList-getTrackById" id="dom-audiotracklist-gettrackbyid"><code>AudioTrackList.getTrackById(<var data-anolis-xref="">id</var>)</code></dfn> and <dfn data-anolis-xref="dom-VideoTrackList-getTrackById" id="dom-videotracklist-gettrackbyid"><code>VideoTrackList.getTrackById(<var data-anolis-xref="">id</var>)</code></dfn> methods must return the first <code><a href="#audiotrack">AudioTrack</a></code> or
  <code><a href="#videotrack">VideoTrack</a></code> object (respectively) in the <code><a href="#audiotracklist">AudioTrackList</a></code> or
  <code><a href="#videotracklist">VideoTrackList</a></code> object (respectively) whose identifier is equal to the value of the
  <var data-anolis-xref="">id</var> argument (in the natural order of the list, as defined above). When no
  tracks match the given argument, the methods must return null.</p>

  <p>The <code><a href="#audiotrack">AudioTrack</a></code> and <code><a href="#videotrack">VideoTrack</a></code> objects represent specific tracks of a
  <a href="#media-resource">media resource</a>. Each track can have an identifier, category, label, and language.
  These aspects of a track are permanent for the lifetime of the track; even if a track is removed
  from a <a href="#media-resource">media resource</a>'s <code><a href="#audiotracklist">AudioTrackList</a></code> or <code><a href="#videotracklist">VideoTrackList</a></code>
  objects, those aspects do not change.</p>

  <p>In addition, <code><a href="#audiotrack">AudioTrack</a></code> objects can each be enabled or disabled; this is the audio
  track's <i>enabled state</i>. When an <code><a href="#audiotrack">AudioTrack</a></code> is created, its <i>enabled state</i>
  must be set to false (disabled). The <a data-anolis-xref="concept-media-load-resource" href="#concept-media-load-resource">resource fetch
  algorithm</a> can override this.</p>

  <p>Similarly, a single <code><a href="#videotrack">VideoTrack</a></code> object per <code><a href="#videotracklist">VideoTrackList</a></code> object can
  be selected, this is the video track's <i>selection state</i>. When a <code><a href="#videotrack">VideoTrack</a></code> is
  created, its <i>selection state</i> must be set to false (not selected). The <a data-anolis-xref="concept-media-load-resource" href="#concept-media-load-resource">resource fetch algorithm</a> can override this.</p>

  <p>The <dfn data-anolis-xref="dom-AudioTrack-id" id="dom-audiotrack-id"><code>AudioTrack.id</code></dfn> and <dfn data-anolis-xref="dom-VideoTrack-id" id="dom-videotrack-id"><code>VideoTrack.id</code></dfn> attributes must return the identifier
  of the track, if it has one, or the empty string otherwise. If the <a href="#media-resource">media resource</a> is
  in a format that supports the <cite>Media Fragments URI</cite> fragment identifier syntax, the
  identifier returned for a particular track must be the same identifier that would enable the track
  if used as the name of a track in the track dimension of such a fragment identifier. <a href="references.html#refsMEDIAFRAG">[MEDIAFRAG]</a></p>

  <p class="example">For example, in Ogg files, this would be the Name header field of the track. <a href="references.html#refsOGGSKELETONHEADERS">[OGGSKELETONHEADERS]</a></p>

  <p>The <dfn data-anolis-xref="dom-AudioTrack-kind" id="dom-audiotrack-kind"><code>AudioTrack.kind</code></dfn> and <dfn data-anolis-xref="dom-VideoTrack-kind" id="dom-videotrack-kind"><code>VideoTrack.kind</code></dfn> attributes must return the category
  of the track, if it has one, or the empty string otherwise.</p>

  <p>The category of a track is the string given in the first column of the table below that is the
  most appropriate for the track based on the definitions in the table's second and third columns,
  as determined by the metadata included in the track in the <a href="#media-resource">media resource</a>. The cell
  in the third column of a row says what the category given in the cell in the first column of that
  row applies to; a category is only appropriate for an audio track if it applies to audio tracks,
  and a category is only appropriate for video tracks if it applies to video tracks. Categories must
  only be returned for <code><a href="#audiotrack">AudioTrack</a></code> objects if they are appropriate for audio, and must
  only be returned for <code><a href="#videotrack">VideoTrack</a></code> objects if they are appropriate for video.</p>

  </div>

  <table id="dom-TrackList-getKind-categories"><caption><code data-anolis-xref="dom-AudioTrack-kind"><a href="#dom-audiotrack-kind">AudioTrack.kind()</a></code>および<code data-anolis-xref="dom-VideoTrack-kind"><a href="#dom-videotrack-kind">VideoTrack.kind()</a></code>に値を返す</caption>
   <thead><tr><th>カテゴリ
     </th><th>定義
     </th><th>適用対象</th>
   <tbody></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-alternate" id="value-track-kind-alternate"><code>alternative</code></dfn>"
     
     </td><td>メイントラックへの可能な代替、たとえば、曲の別テイク（オーディオ）、または別アングル（ビデオ）。
     </td><td>Audioとvideo。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-caption" id="value-track-kind-caption"><code>captions</code></dfn>"
     
     </td><td>焼き付き字幕をもつ主ビデオトラックのバージョン。（レガシーコンテンツ用。新しいコンテンツはテキストトラックを使用する。）
     </td><td>Videoのみ。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-descriptions" id="value-track-kind-descriptions"><code>descriptions</code></dfn>"
     
     </td><td>ビデオトラックの音声解説。
     </td><td>Audioのみ。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-main" id="value-track-kind-main"><code>main</code></dfn>"
     
     </td><td>主オーディオまたはビデオトラック。
     </td><td>Audioとvideo。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-main-desc" id="value-track-kind-main-desc"><code>main-desc</code></dfn>"
     
     </td><td>音声解説と混合された、主オーディオトラック。
     </td><td>Audioのみ。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-sign" id="value-track-kind-sign"><code>sign</code></dfn>"
     
     </td><td>オーディオトラックの手話通訳。
     </td><td>Videoのみ。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-subtitle" id="value-track-kind-subtitle"><code>subtitles</code></dfn>"
     
     </td><td>焼き付き字幕をもつ主ビデオトラックのバージョン。（レガシーコンテンツ用。新しいコンテンツはテキストトラックを使用する。）
     </td><td>Videoのみ。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-translation" id="value-track-kind-translation"><code>translation</code></dfn>"
     
     </td><td>主オーディオトラックの翻訳バージョン。
     </td><td>Audioのみ。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-commentary" id="value-track-kind-commentary"><code>commentary</code></dfn>"
     
     </td><td>主オーディオまたはビデオトラックのコメンタリ。たとえばディレクターのコメント。
     </td><td>Audioとvideo。

    </td></tr><tr><td>"<dfn data-anolis-xref="value-track-kind-none" id="value-track-kind-none"><code></code></dfn>"（空文字列）
     </td><td>明示的な種類がないか、トラックのメタデータで指定された種類は、ユーザーエージェントによって認識されない。
     </td><td>Audioとvideo。

  </td></tr></table><div class="impl">

  <p>The <dfn data-anolis-xref="dom-AudioTrack-label" id="dom-audiotrack-label"><code>AudioTrack.label</code></dfn> and <dfn data-anolis-xref="dom-VideoTrack-label" id="dom-videotrack-label"><code>VideoTrack.label</code></dfn> attributes must return the label
  of the track, if it has one, or the empty string otherwise.</p>

  <p>The <dfn data-anolis-xref="dom-AudioTrack-language" id="dom-audiotrack-language"><code>AudioTrack.language</code></dfn> and <dfn data-anolis-xref="dom-VideoTrack-language" id="dom-videotrack-language"><code>VideoTrack.language</code></dfn> attributes must return the
  BCP 47 language tag of the language of the track, if it has one, or the empty string otherwise. If
  the user agent is not able to express that language as a BCP 47 language tag (for example because
  the language information in the <a href="#media-resource">media resource</a>'s format is a free-form string without
  a defined interpretation), then the method must return the empty string, as if the track had no
  language.</p>

  <p>Source attribute values for id, kind, label and language of multitrack audio and video tracks as
  described for the relevant <a href="#media-resource">media resource</a> format. <a href="references.html#refsINBANDTRACKS">[INBANDTRACKS]</a></p>

  <p>The <dfn data-anolis-xref="dom-AudioTrack-enabled" id="dom-audiotrack-enabled"><code>AudioTrack.enabled</code></dfn> attribute, on
  getting, must return true if the track is currently enabled, and false otherwise. On setting, it
  must enable the track if the new value is true, and disable it otherwise. (If the track is no
  longer in an <code><a href="#audiotracklist">AudioTrackList</a></code> object, then the track being enabled or disabled has no
  effect beyond changing the value of the attribute on the <code><a href="#audiotrack">AudioTrack</a></code> object.)</p>

  <p id="toggle-audio-track">Whenever an audio track in an <code><a href="#audiotracklist">AudioTrackList</a></code> that was
  disabled is enabled, and whenever one that was enabled is disabled, the user agent must
  <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-change"><a href="#event-media-change">change</a></code> at the <code><a href="#audiotracklist">AudioTrackList</a></code> object.</p>

  <p>The <dfn data-anolis-xref="dom-VideoTrackList-selectedIndex" id="dom-videotracklist-selectedindex"><code>VideoTrackList.selectedIndex</code></dfn> attribute
  must return the index of the currently selected track, if any. If the <code><a href="#videotracklist">VideoTrackList</a></code>
  object does not currently represent any tracks, or if none of the tracks are selected, it must
  instead return −1.</p>

  <p>The <dfn data-anolis-xref="dom-VideoTrack-selected" id="dom-videotrack-selected"><code>VideoTrack.selected</code></dfn> attribute, on
  getting, must return true if the track is currently selected, and false otherwise. On setting, it
  must select the track if the new value is true, and unselect it otherwise. If the track is in a
  <code><a href="#videotracklist">VideoTrackList</a></code>, then all the other <code><a href="#videotrack">VideoTrack</a></code> objects in that list must
  be unselected. (If the track is no longer in a <code><a href="#videotracklist">VideoTrackList</a></code> object, then the track
  being selected or unselected has no effect beyond changing the value of the attribute on the
  <code><a href="#videotrack">VideoTrack</a></code> object.)</p><!--CLEANUP-->


  <p id="toggle-video-track">Whenever a track in a <code><a href="#videotracklist">VideoTrackList</a></code> that was previously not selected is selected,
  the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-media-change"><a href="#event-media-change">change</a></code> at the <code><a href="#videotracklist">VideoTrackList</a></code> object. This <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> must be <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> before the
  <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that fires the <code data-anolis-xref="event-media-resize"><a href="#event-media-resize">resize</a></code> event, if any.</p>

  <hr><p>The following are the <a href="webappapis.html#event-handlers">event handlers</a> (and their corresponding <a data-anolis-xref="event
  handler event type" href="webappapis.html#event-handler-event-type">event handler event types</a>) <span class="impl">that must be</span> supported, as <a href="webappapis.html#event-handler-idl-attributes">event handler IDL attributes</a>,
  by all objects implementing the <code><a href="#audiotracklist">AudioTrackList</a></code> and <code><a href="#videotracklist">VideoTrackList</a></code>
  interfaces:</p>

  <table><thead><tr><th><a data-anolis-xref="event handlers" href="webappapis.html#event-handlers">イベントハンドラ</a> </th><th><a href="webappapis.html#event-handler-event-type">イベントハンドライベント型</a>
   <tbody></th></tr><tr><td><dfn data-anolis-xref="handler-TrackList-onchange" id="handler-tracklist-onchange"><code>onchange</code></dfn> </td><td> <code data-anolis-xref="event-media-change"><a href="#event-media-change">change</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-TrackList-onaddtrack" id="handler-tracklist-onaddtrack"><code>onaddtrack</code></dfn> </td><td> <code data-anolis-xref="event-media-addtrack"><a href="#event-media-addtrack">addtrack</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-TrackList-onremovetrack" id="handler-tracklist-onremovetrack"><code>onremovetrack</code></dfn> </td><td> <code data-anolis-xref="event-media-removetrack"><a href="#event-media-removetrack">removetrack</a></code>
  </td></tr></table><!-- v2 should also fire an event when the list changes (but note that that should be on the media element event task source) --></div>


  <h6 id="selecting-specific-audio-and-video-tracks-declaratively"><span class="secno">4.7.14.10.2</span> 宣言的に特定のオーディオとビデオトラックを選択する</h6>

  <p><code data-anolis-xref="dom-media-audioTracks"><a href="#dom-media-audiotracks">audioTracks</a></code>および<code data-anolis-xref="dom-media-videoTracks"><a href="#dom-media-videotracks">videoTracks</a></code>属性はスクリプトを再生すべきそのトラックを選択できるが、<a href="#media-resource">メディアリソース</a>の<a href="infrastructure.html#url">URL</a>のフラグメント識別子で特定のトラックを指定することにより、宣言的に特定のトラックを選択することも可能である。フラグメント識別子の形式は、<a href="#media-resource">メディアリソース</a>の<a href="infrastructure.html#mime-type">MIMEタイプ</a>に依存する。<a href="references.html#refsRFC2046">[RFC2046]</a> <a href="references.html#refsURL">[URL]</a></p>

  <div class="example">

   <p>この例において、<cite>Media Fragments URI</cite>フラグメント識別子の構文をサポートする形式を使用するビデオが、ラベル"Alternative"として代替アングルがデフォルトのビデオトラックの代わりに有効にされるように埋め込まれている。<a href="references.html#refsMEDIAFRAG">[MEDIAFRAG]</a></p>

   <pre>&lt;video src="myvideo#track=Alternative"&gt;&lt;/video&gt;</pre>

  </div>


  <h5 id="synchronising-multiple-media-elements"><span class="secno">4.7.14.11</span> 複数のメディア要素を同期する</h5>

  <h6 id="introduction-1"><span class="secno">4.7.14.11.1</span> 導入</h6>

  <p>各<a href="#media-element">メディア要素</a>は<code><a href="#mediacontroller">MediaController</a></code>を持つことができる。<code><a href="#mediacontroller">MediaController</a></code>は、たとえば手話通訳のトラックが同期を取ってビデオトラックに重ねることができるような、複数の<a data-anolis-xref="media element" href="#media-element">メディア要素</a>の再生を調整するオブジェクトである。</p>

  <p>デフォルトで、<a href="#media-element">メディア要素</a>は<code><a href="#mediacontroller">MediaController</a></code>を持たない。暗黙の<code><a href="#mediacontroller">MediaController</a></code>は<code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code>コンテンツ属性を使用して割り当てることができる。明示的な<code><a href="#mediacontroller">MediaController</a></code>は、直接<code data-anolis-xref="dom-media-controller"><a href="#dom-media-controller">controller</a></code>IDL属性を使用して割り当てることができる。</p>

  <p><code><a href="#mediacontroller">MediaController</a></code>を伴う<a data-anolis-xref="media element" href="#media-element">メディア要素</a>は、そのコントローラに<i>従属する</i>と言われる。<code><a href="#mediacontroller">MediaController</a></code>は、再生速度とそれに従属する<a data-anolis-xref="media element" href="#media-element">メディア要素</a>のそれぞれの再生音量を変更し、その従属する<a data-anolis-xref="media element" href="#media-element">メディア要素</a>のいずれかが予期せず失速した場合、他方が同時に停止することを保証する。</p>

  <p><a href="#media-element">メディア要素</a>が<code><a href="#mediacontroller">MediaController</a></code>に従属される場合、その再生速度は同じ<code><a href="#mediacontroller">MediaController</a></code>の他のトラックのものに固定され、任意のループが無効になる。</p><!-- v2: add control to loop, add control to playback rate
  <div class="example">

   <p>In this example, two audio elements are slaved to the same (implicit) controller so that a
   waltz played by one audio element is kept exactly synchronised to the "tick tock tock" sound of
   the metronome played by the second element:</p>

   <pre>&lt;audio src="The%20Amelia%20Earhart%20Waltz.wav" controls autoplay mediagroup="song">&lt;/audio>
&lt;audio src="metronomes/3-4.wav" autoplay loop mediagroup="song">&lt;/audio></pre>

   <p>Assuming the song keeps a regular tempo throughout and assuming the metronome has the same
   tempo, this works even though if the metronome file only has one measure's worth of "tick tock
   tock", because the controller (implied by the <code
   data-x="attr-media-mediagroup">mediagroup</code> attribute) guarantees that the two elements will
   be kept synchronised, even if the user rewinds, jumps to a different part of the song, etc (the
   user agent controls made available by the <code data-x="attr-media-controls">controls</code>
   attribute on the song's <code>audio</code> element affect the <code>MediaController</code>'s
   state).</p>

   <p>If the metronome has the wrong rate, its rate can be adjusted by script separately from the
   song's (using the <code data-x="dom-media-playbackRate">audio.playbackRate</code> IDL attribute).
   The two elements will play back their <span>media data</span> at different rates, but the ratio
   will again be controlled by the <code>MediaController</code>.</p>

  </div>
-->




  <h6 id="media-controllers"><span class="secno">4.7.14.11.2</span> メディアコントローラ</h6>

  <pre class="idl">enum <dfn id="mediacontrollerplaybackstate">MediaControllerPlaybackState</dfn> { "<a data-anolis-xref="dom-MediaController-waiting" href="#dom-mediacontroller-waiting">waiting</a>", "<a data-anolis-xref="dom-MediaController-playing" href="#dom-mediacontroller-playing">playing</a>", "<a data-anolis-xref="dom-MediaController-ended" href="#dom-mediacontroller-ended">ended</a>" };
[<a data-anolis-xref="dom-MediaController" href="#dom-mediacontroller">Constructor</a>]
interface <dfn id="mediacontroller">MediaController</dfn> : <a href="infrastructure.html#eventtarget">EventTarget</a> {
  readonly attribute unsigned short <a data-anolis-xref="dom-MediaController-readyState" href="#dom-mediacontroller-readystate">readyState</a>; // uses <a href="#htmlmediaelement">HTMLMediaElement</a>.<a data-anolis-xref="dom-media-readyState" href="#dom-media-readystate">readyState</a>'s values

  readonly attribute <a href="#timeranges">TimeRanges</a> <a data-anolis-xref="dom-MediaController-buffered" href="#dom-mediacontroller-buffered">buffered</a>;
  readonly attribute <a href="#timeranges">TimeRanges</a> <a data-anolis-xref="dom-MediaController-seekable" href="#dom-mediacontroller-seekable">seekable</a>;
  readonly attribute unrestricted double <a data-anolis-xref="dom-MediaController-duration" href="#dom-mediacontroller-duration">duration</a>;
           attribute double <a data-anolis-xref="dom-MediaController-currentTime" href="#dom-mediacontroller-currenttime">currentTime</a>;

  readonly attribute boolean <a data-anolis-xref="dom-MediaController-paused" href="#dom-mediacontroller-paused">paused</a>;
  readonly attribute <a href="#mediacontrollerplaybackstate">MediaControllerPlaybackState</a> <a data-anolis-xref="dom-MediaController-playbackState" href="#dom-mediacontroller-playbackstate">playbackState</a>;
  readonly attribute <a href="#timeranges">TimeRanges</a> <a data-anolis-xref="dom-MediaController-played" href="#dom-mediacontroller-played">played</a>;
  void <a data-anolis-xref="dom-MediaController-pause" href="#dom-mediacontroller-pause">pause</a>();
  void <a data-anolis-xref="dom-MediaController-unpause" href="#dom-mediacontroller-unpause">unpause</a>();
  void <a data-anolis-xref="dom-MediaController-play" href="#dom-mediacontroller-play">play</a>(); // calls play() on all media elements as well

           attribute double <a data-anolis-xref="dom-MediaController-defaultPlaybackRate" href="#dom-mediacontroller-defaultplaybackrate">defaultPlaybackRate</a>;
           attribute double <a data-anolis-xref="dom-MediaController-playbackRate" href="#dom-mediacontroller-playbackrate">playbackRate</a>;

           attribute double <a data-anolis-xref="dom-MediaController-volume" href="#dom-mediacontroller-volume">volume</a>;
           attribute boolean <a data-anolis-xref="dom-MediaController-muted" href="#dom-mediacontroller-muted">muted</a>;

           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onemptied" href="#handler-mediacontroller-onemptied">onemptied</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onloadedmetadata" href="#handler-mediacontroller-onloadedmetadata">onloadedmetadata</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onloadeddata" href="#handler-mediacontroller-onloadeddata">onloadeddata</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-oncanplay" href="#handler-mediacontroller-oncanplay">oncanplay</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-oncanplaythrough" href="#handler-mediacontroller-oncanplaythrough">oncanplaythrough</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onplaying" href="#handler-mediacontroller-onplaying">onplaying</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onended" href="#handler-mediacontroller-onended">onended</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onwaiting" href="#handler-mediacontroller-onwaiting">onwaiting</a>;

           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-ondurationchange" href="#handler-mediacontroller-ondurationchange">ondurationchange</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-ontimeupdate" href="#handler-mediacontroller-ontimeupdate">ontimeupdate</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onplay" href="#handler-mediacontroller-onplay">onplay</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onpause" href="#handler-mediacontroller-onpause">onpause</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onratechange" href="#handler-mediacontroller-onratechange">onratechange</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-MediaController-onvolumechange" href="#handler-mediacontroller-onvolumechange">onvolumechange</a>;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">controller</var> = new <code data-anolis-xref="dom-MediaController"><a href="#dom-mediacontroller">MediaController</a></code>()</dt>

   <dd>

    <p>新しい<code><a href="#mediacontroller">MediaController</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-controller"><a href="#dom-media-controller">controller</a></code> [ = <var data-anolis-xref="">controller</var> ]</dt>

   <dd>

    <p>もしあれば、<a href="#media-element">メディア要素</a>に対する現在の<code><a href="#mediacontroller">MediaController</a></code>を返し、そうでなければnullを返す。</p>

    <p>明示的な<code><a href="#mediacontroller">MediaController</a></code>を設定することが可能である。もしあれば、設定して<code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code>属性を削除する。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-readyState"><a href="#dom-mediacontroller-readystate">readyState</a></code></dt>

   <dd>

    <p><code><a href="#mediacontroller">MediaController</a></code>は、それが<a data-anolis-xref="report the controller state" href="#report-the-controller-state">コントローラの状態を報告する</a>結果としてイベントを発生させた最後の時間であった状態を返す。この属性の値は、<a data-anolis-xref="media element" href="#media-element">メディア要素</a>の<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>属性の場合と同じである。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-buffered"><a href="#dom-mediacontroller-buffered">buffered</a></code></dt>

   <dd>

    <p>ユーザーエージェントが、すべての従属<a data-anolis-xref="media
    element" href="#media-element">メディア要素</a>に関連するすべてのメディアのデータを持つ時間範囲の共通部分を表す<code><a href="#timeranges">TimeRanges</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-seekable"><a href="#dom-mediacontroller-seekable">seekable</a></code></dt>

   <dd>

    <p>ユーザーエージェントが、すべての従属<a data-anolis-xref="media element" href="#media-element">メディア要素</a>をシークできる時間範囲の共通部分を表す<code><a href="#timeranges">TimeRanges</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-duration"><a href="#dom-mediacontroller-duration">duration</a></code></dt>

   <dd>

    <p>（問題のデータが実際にバッファリングされた、または直接シーク可能ではないが、無限のストリームに対する将来の時間を含むかどうかを考慮しない）最も早い再生時点と最も遅い再生時点の差を返す。メディアが存在しない場合は0を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-currentTime"><a href="#dom-mediacontroller-currenttime">currentTime</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>秒単位で、0時間と現在時間の<code data-anolis-xref="dom-MediaController-duration"><a href="#dom-mediacontroller-duration">duration</a></code>の間の位置として、<a href="#current-playback-position">現在の再生位置</a>を返す。</p>

    <p>指定時間にシークするために、設定可能である。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-paused"><a href="#dom-mediacontroller-paused">paused</a></code></dt>

   <dd>

    <p>再生が一時停止された場合はtrueを返し、そうでなければfalseを返す。この属性がtrueの場合、このコントローラに従属するすべての<a href="#media-element">メディア要素</a>が停止される。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-playbackState"><a href="#dom-mediacontroller-playbackstate">playbackState</a></code></dt>

   <dd>

    <p><code><a href="#mediacontroller">MediaController</a></code>は、それが<a data-anolis-xref="report the controller state" href="#report-the-controller-state">コントローラの状態を報告する</a>結果としてイベントを発生させた最後の時間であった状態を返す。この属性の値は、メディアが積極的に再生されることを示す"<code data-anolis-xref="dom-MediaController-playing"><a href="#dom-mediacontroller-playing">playing</a></code>"、すべての<a href="#slaved-media-elements">従属メディア要素</a>の最後に到達しているために再生されていないことを示す"<code data-anolis-xref="dom-MediaController-ended"><a href="#dom-mediacontroller-ended">ended</a></code>"、またはその他の理由（たとえば<code><a href="#mediacontroller">MediaController</a></code>が一時停止されている）のために再生されていないことを示す"<code data-anolis-xref="dom-MediaController-waiting"><a href="#dom-mediacontroller-waiting">waiting</a></code>"のいずれかである。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-pause"><a href="#dom-mediacontroller-pause">pause</a></code>()</dt>

   <dd>

    <p>trueに<code data-anolis-xref="dom-MediaController-paused"><a href="#dom-mediacontroller-paused">paused</a></code>属性を設定する。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-unpause"><a href="#dom-mediacontroller-unpause">unpause</a></code>()</dt>

   <dd>

    <p>falseに<code data-anolis-xref="dom-MediaController-paused"><a href="#dom-mediacontroller-paused">paused</a></code>属性を設定する。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-play"><a href="#dom-mediacontroller-play">play</a></code>()</dt>

   <dd>

    <p>falseに<code data-anolis-xref="dom-MediaController-paused"><a href="#dom-mediacontroller-paused">paused</a></code>属性を設定し、各<a data-anolis-xref="slaved media
    elements" href="#slaved-media-elements">従属メディア要素</a>の<code data-anolis-xref="dom-media-play"><a href="#dom-media-play">play()</a></code>メソッドを呼び出す。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-played"><a href="#dom-mediacontroller-played">played</a></code></dt>

   <dd>

    <p>再生されているすべての従属<a data-anolis-xref="media element" href="#media-element">メディア要素</a>で時間範囲の和集合を表す<code><a href="#timeranges">TimeRanges</a></code>オブジェクトを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-defaultPlaybackRate"><a href="#dom-mediacontroller-defaultplaybackrate">defaultPlaybackRate</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>再生のデフォルト率を返す。</p>

    <p>再生のデフォルト率を変更する設定が可能である。</p>

    <p>デフォルト率は再生に直接影響を与えないが、ユーザーが早送りモードに切り替えた場合、モードが通常の再生モードに戻った際に、再生速度（<code data-anolis-xref="dom-MediaController-playbackRate"><a href="#dom-mediacontroller-playbackrate">playbackRate</a></code>）がデフォルト率に戻されることが期待される。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-playbackRate"><a href="#dom-mediacontroller-playbackrate">playbackRate</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>再生の現在速度を返す。</p>

    <p>再生速度を変更する設定が可能である。</p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-volume"><a href="#dom-mediacontroller-volume">volume</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>0.0から1.0までの範囲の数字として、現在の再生音量の乗数を返す。ここで0.0は最小音量で1.0は最大音量である。</p>

    <p>音量の乗数を変更する設定が可能である。</p>

    <p>新しい値が範囲0.0から1.0に含まれない場合、<code><a href="infrastructure.html#indexsizeerror">IndexSizeError</a></code>を投げる。 </p>

   </dd>

   <dt><var data-anolis-xref="">controller</var> . <code data-anolis-xref="dom-MediaController-muted"><a href="#dom-mediacontroller-muted">muted</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>（コントローラ上、またはこのコントローラに従属する任意の<a data-anolis-xref="media element" href="#media-element">メディア要素</a>のいずれかで他の属性に関係なく）すべてのオーディオがミュートである場合、trueを返し、そうでなければfalseを返す。</p>

    <p>オーディオがミュートであるかどうかを変更する設定が可能である。</p>

   </dd>

  </dl><div class="impl">

  <p>A <a href="#media-element">media element</a> can have a <dfn id="current-media-controller">current media controller</dfn>, which is a
  <code><a href="#mediacontroller">MediaController</a></code> object. When a <a href="#media-element">media element</a> is created without a <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> attribute, it does not have a <a href="#current-media-controller">current media
  controller</a>. (If it is created <em>with</em> such an attribute, then that attribute
  initializes the <a href="#current-media-controller">current media controller</a>, as defined below.)</p>

  <p>The <dfn id="slaved-media-elements">slaved media elements</dfn> of a <code><a href="#mediacontroller">MediaController</a></code> are the <a data-anolis-xref="media element" href="#media-element">media elements</a> whose <a href="#current-media-controller">current media controller</a> is that
  <code><a href="#mediacontroller">MediaController</a></code>. All the <a href="#slaved-media-elements">slaved media elements</a> of a
  <code><a href="#mediacontroller">MediaController</a></code> must use the same clock for their definition of their <a href="#media-timeline">media
  timeline</a>'s unit time. When the user agent is required to act on each <a data-anolis-xref="slaved
  media elements" href="#slaved-media-elements">slaved media element</a> in turn, they must be processed in the order that they
  were last associated with the <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <hr><p>The <dfn data-anolis-xref="dom-media-controller" id="dom-media-controller"><code>controller</code></dfn> attribute on a <a href="#media-element">media
  element</a>, on getting, must return the element's <a href="#current-media-controller">current media controller</a>, if
  any, or null otherwise. On setting, the user agent must run the following steps:</p>

  <ol><!-- very similar to the algorithm below for setting the content attribute --><li><p>Let <var data-anolis-xref="">m</var> be the <a href="#media-element">media element</a> in question.</li>

   <li><p>Let <var data-anolis-xref="">old controller</var> be <var data-anolis-xref="">m</var>'s <a href="#current-media-controller">current media
   controller</a>, if it currently has one, and null otherwise.</li>

   <li><p>Let <var data-anolis-xref="">new controller</var> be null.</li>

   <li><p>Let <var data-anolis-xref="">m</var> have no <a href="#current-media-controller">current media controller</a>, if it currently
   has one.</li>

   <li><p>Remove the element's <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> content
   attribute, if any.</li>

   <li><p>If the new value is null, then jump to the <i>update controllers</i> step below.</li>

   <li><p>Let <var data-anolis-xref="">m</var>'s <a href="#current-media-controller">current media controller</a> be the new
   value.</li>

   <li><p>Let <var data-anolis-xref="">new controller</var> be <var data-anolis-xref="">m</var>'s <a href="#current-media-controller">current media
   controller</a>.</li>

   <li><p><a href="#bring-the-media-element-up-to-speed-with-its-new-media-controller">Bring the media element up to speed with its new media controller</a>.</li>

   <li><p><i>Update controllers</i>: If <var data-anolis-xref="">old controller</var> and <var data-anolis-xref="">new
   controller</var> are the same (whether both null or both the same controller) then abort these
   steps.</li>

   <li><p>If <var data-anolis-xref="">old controller</var> is not null and still has one or more <a href="#slaved-media-elements">slaved
   media elements</a>, then <a href="#report-the-controller-state">report the controller state</a> for <var data-anolis-xref="">old
   controller</var>.</li>

   <li><p>If <var data-anolis-xref="">new controller</var> is not null, then <a href="#report-the-controller-state">report the controller
   state</a> for <var data-anolis-xref="">new controller</var>.</li>

  </ol><hr><p>The <dfn data-anolis-xref="dom-MediaController" id="dom-mediacontroller"><code>MediaController()</code></dfn> constructor, when
  invoked, must return a newly created <code><a href="#mediacontroller">MediaController</a></code> object.</p>

  <hr><p>The <dfn data-anolis-xref="dom-MediaController-readyState" id="dom-mediacontroller-readystate"><code>readyState</code></dfn> attribute must
  return the value to which it was most recently set. When the <code><a href="#mediacontroller">MediaController</a></code> object
  is created, the attribute must be set to the value 0 (<code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>). The value is updated by the <a href="#report-the-controller-state">report the
  controller state</a> algorithm below.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-seekable" id="dom-mediacontroller-seekable"><code>seekable</code></dfn> attribute must return
  a new static <a href="#normalised-timeranges-object">normalised <code>TimeRanges</code> object</a> that represents the
  intersection of the ranges of the <a data-anolis-xref="media resource" href="#media-resource">media resources</a> of the
  <a href="#slaved-media-elements">slaved media elements</a> that the user agent is able to seek to, at the time the
  attribute is evaluated.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-buffered" id="dom-mediacontroller-buffered"><code>buffered</code></dfn> attribute must return
  a new static <a href="#normalised-timeranges-object">normalised <code>TimeRanges</code> object</a> that represents the
  intersection of the ranges of the <a data-anolis-xref="media resource" href="#media-resource">media resources</a> of the
  <a href="#slaved-media-elements">slaved media elements</a> that the user agent has buffered, at the time the attribute is
  evaluated. Users agents must accurately determine the ranges available, even for media streams
  where this can only be determined by tedious inspection.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-duration" id="dom-mediacontroller-duration"><code>duration</code></dfn> attribute must return
  the <a href="#media-controller-duration">media controller duration</a>.</p>

  <p>Every 15 to 250ms, or whenever the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-duration">media controller
  duration</a> changes, whichever happens least often, the user agent must <a href="webappapis.html#queue-a-task">queue a
  task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-MediaController-durationchange"><a href="#event-mediacontroller-durationchange">durationchange</a></code> at the
  <code><a href="#mediacontroller">MediaController</a></code>. If the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-duration">media controller
  duration</a> decreases such that the <a href="#media-controller-position">media controller position</a> is greater than the
  <a href="#media-controller-duration">media controller duration</a>, the user agent must immediately <a href="#seek-the-media-controller">seek the media
  controller</a> to <a href="#media-controller-duration">media controller duration</a>.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-currentTime" id="dom-mediacontroller-currenttime"><code>currentTime</code></dfn> attribute must
  return the <a href="#media-controller-position">media controller position</a> on getting, and on setting must <a href="#seek-the-media-controller">seek the
  media controller</a> to the new value.</p>

  <p>Every 15 to 250ms, or whenever the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-position">media controller
  position</a> changes, whichever happens least often, the user agent must <a href="webappapis.html#queue-a-task">queue a
  task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-MediaController-timeupdate"><a href="#event-mediacontroller-timeupdate">timeupdate</a></code> at the
  <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <hr><p>When a <code><a href="#mediacontroller">MediaController</a></code> is created it is a <dfn id="playing-media-controller">playing media controller</dfn>. It
  can be changed into a <dfn id="paused-media-controller">paused media controller</dfn> and back either via the user agent's user
  interface (when the element is <a data-anolis-xref="expose a user interface to the user" href="#expose-a-user-interface-to-the-user">exposing a user
  interface to the user</a>) or by script using the APIs defined in this section (see below).</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-paused" id="dom-mediacontroller-paused"><code>paused</code></dfn> attribute must return
  true if the <code><a href="#mediacontroller">MediaController</a></code> object is a <a href="#paused-media-controller">paused media controller</a>, and
  false otherwise.</p>

  <p>When the <dfn data-anolis-xref="dom-MediaController-pause" id="dom-mediacontroller-pause"><code>pause()</code></dfn> method is invoked,
  if the <code><a href="#mediacontroller">MediaController</a></code> is a <a href="#playing-media-controller">playing media controller</a> then the user agent
  must change the <code><a href="#mediacontroller">MediaController</a></code> into a <a href="#paused-media-controller">paused media controller</a>,
  <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-MediaController-pause"><a href="#event-mediacontroller-pause">pause</a></code> at the <code><a href="#mediacontroller">MediaController</a></code>, and then
  <a href="#report-the-controller-state">report the controller state</a> of the <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <p>When the <dfn data-anolis-xref="dom-MediaController-unpause" id="dom-mediacontroller-unpause"><code>unpause()</code></dfn> method is
  invoked, if the <code><a href="#mediacontroller">MediaController</a></code> is a <a href="#paused-media-controller">paused media controller</a>, the user
  agent must change the <code><a href="#mediacontroller">MediaController</a></code> into a <a href="#playing-media-controller">playing media controller</a>,
  <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-MediaController-play"><a href="#event-mediacontroller-play">play</a></code> at the <code><a href="#mediacontroller">MediaController</a></code>, and then
  <a href="#report-the-controller-state">report the controller state</a> of the <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <p>When the <dfn data-anolis-xref="dom-MediaController-play" id="dom-mediacontroller-play"><code>play()</code></dfn> method is invoked, the
  user agent must invoke the <code data-anolis-xref="dom-media-play"><a href="#dom-media-play">play()</a></code> method of each <a data-anolis-xref="slaved media elements" href="#slaved-media-elements">slaved media element</a> in turn, and then invoke the <code data-anolis-xref="dom-MediaController-unpause"><a href="#dom-mediacontroller-unpause">unpause</a></code> method of the <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-playbackState" id="dom-mediacontroller-playbackstate"><code>playbackState</code></dfn> attribute
  must return the value to which it was most recently set. When the <code><a href="#mediacontroller">MediaController</a></code>
  object is created, the attribute must be set to the value "<code data-anolis-xref="dom-MediaController-waiting"><a href="#dom-mediacontroller-waiting">waiting</a></code>". The value is updated by the <a href="#report-the-controller-state">report the
  controller state</a> algorithm below.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-played" id="dom-mediacontroller-played"><code>played</code></dfn> attribute must return a
  new static <a href="#normalised-timeranges-object">normalised <code>TimeRanges</code> object</a> that represents the union of the
  ranges of points on the <a data-anolis-xref="media timeline" href="#media-timeline">media timelines</a> of the <a data-anolis-xref="media resource" href="#media-resource">media resources</a> of the <a href="#slaved-media-elements">slaved media elements</a> that the
  user agent has so far reached through the usual monotonic increase of their <a data-anolis-xref="current
  playback position" href="#current-playback-position">current playback positions</a> during normal playback, at the time the
  attribute is evaluated.</p>

  <hr><p>A <code><a href="#mediacontroller">MediaController</a></code> has a <dfn id="media-controller-default-playback-rate">media controller default playback rate</dfn> and a
  <dfn id="media-controller-playback-rate">media controller playback rate</dfn>, which must both be set to 1.0 when the
  <code><a href="#mediacontroller">MediaController</a></code> object is created.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-defaultPlaybackRate" id="dom-mediacontroller-defaultplaybackrate"><code>defaultPlaybackRate</code></dfn>
  attribute, on getting, must return the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-default-playback-rate">media controller
  default playback rate</a>, and on setting, must set the <code><a href="#mediacontroller">MediaController</a></code>'s
  <a href="#media-controller-default-playback-rate">media controller default playback rate</a> to the new value, then <a href="webappapis.html#queue-a-task">queue a
  task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-MediaController-ratechange"><a href="#event-mediacontroller-ratechange">ratechange</a></code> at the
  <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-playbackRate" id="dom-mediacontroller-playbackrate"><code>playbackRate</code></dfn> attribute, on
  getting, must return the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-playback-rate">media controller playback
  rate</a>, and on setting, must set the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-playback-rate">media controller
  playback rate</a> to the new value, then <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
  event</a> named <code data-anolis-xref="event-MediaController-ratechange"><a href="#event-mediacontroller-ratechange">ratechange</a></code> at the
  <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <hr><p>A <code><a href="#mediacontroller">MediaController</a></code> has a <dfn id="media-controller-volume-multiplier">media controller volume multiplier</dfn>, which must
  be set to 1.0 when the <code><a href="#mediacontroller">MediaController</a></code> object is created, and a <dfn id="media-controller-mute-override">media controller
  mute override</dfn>, much must initially be false.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-volume" id="dom-mediacontroller-volume"><code>volume</code></dfn> attribute, on getting,
  must return the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-volume-multiplier">media controller volume multiplier</a>,
  and on setting, if the new value is in the range 0.0 to 1.0 inclusive, must set the
  <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-volume-multiplier">media controller volume multiplier</a> to the new value
  and <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-MediaController-volumechange"><a href="#event-mediacontroller-volumechange">volumechange</a></code> at the
  <code><a href="#mediacontroller">MediaController</a></code>. If the new value is outside the range 0.0 to 1.0 inclusive, then, on
  setting, an <code><a href="infrastructure.html#indexsizeerror">IndexSizeError</a></code> exception must be thrown instead.</p>

  <p>The <dfn data-anolis-xref="dom-MediaController-muted" id="dom-mediacontroller-muted"><code>muted</code></dfn> attribute, on getting, must
  return the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-mute-override">media controller mute override</a>, and on
  setting, must set the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-mute-override">media controller mute override</a>
  to the new value and <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-MediaController-volumechange"><a href="#event-mediacontroller-volumechange">volumechange</a></code> at the
  <code><a href="#mediacontroller">MediaController</a></code>.</p>

  <hr><p>The <a data-anolis-xref="media resource" href="#media-resource">media resources</a> of all the <a href="#slaved-media-elements">slaved media
  elements</a> of a <code><a href="#mediacontroller">MediaController</a></code> have a defined temporal relationship which
  provides relative offsets between the zero time of each such <a href="#media-resource">media resource</a>: for
  <a data-anolis-xref="media resource" href="#media-resource">media resources</a> with a <a href="#timeline-offset">timeline offset</a>, their
  relative offsets are the difference between their <a href="#timeline-offset">timeline offset</a>; the zero times of
  all the <a data-anolis-xref="media resource" href="#media-resource">media resources</a> without a <a href="#timeline-offset">timeline offset</a>
  are not offset from each other (i.e. the origins of their timelines are cotemporal); and finally,
  the zero time of the <a href="#media-resource">media resource</a> with the earliest <a href="#timeline-offset">timeline offset</a>
  (if any) is not offset from the zero times of the <a data-anolis-xref="media resource" href="#media-resource">media
  resources</a> without a <a href="#timeline-offset">timeline offset</a> (i.e. the origins of <a data-anolis-xref="media
  resource" href="#media-resource">media resources</a> without a <a href="#timeline-offset">timeline offset</a> are further cotemporal
  with the earliest defined point on the timeline of the <a href="#media-resource">media resource</a> with the
  earliest <a href="#timeline-offset">timeline offset</a>).</p>

  <p>The <dfn id="media-resource-end-position">media resource end position</dfn> of a <a href="#media-resource">media resource</a> in a <a href="#media-element">media
  element</a> is defined as follows: if the <a href="#media-resource">media resource</a> has a finite and known
  duration, the <a href="#media-resource-end-position">media resource end position</a> is the duration of the <a href="#media-resource">media
  resource</a>'s timeline (the last defined position on that timeline); otherwise, the
  <a href="#media-resource">media resource</a>'s duration is infinite or unknown, and the <a href="#media-resource-end-position">media resource end
  position</a> is the time of the last frame of <a href="#media-data">media data</a> currently available for
  that <a href="#media-resource">media resource</a>.</p>

  <p>Each <code><a href="#mediacontroller">MediaController</a></code> also has its own defined timeline. On this timeline, all the
  <a data-anolis-xref="media resource" href="#media-resource">media resources</a> of all the <a href="#slaved-media-elements">slaved media elements</a>
  of the <code><a href="#mediacontroller">MediaController</a></code> are temporally aligned according to their defined offsets. The
  <dfn id="media-controller-duration">media controller duration</dfn> of that <code><a href="#mediacontroller">MediaController</a></code> is the time from the
  earliest <a href="#earliest-possible-position">earliest possible position</a>, relative to this <code><a href="#mediacontroller">MediaController</a></code>
  timeline, of any of the <a data-anolis-xref="media resource" href="#media-resource">media resources</a> of the <a href="#slaved-media-elements">slaved
  media elements</a> of the <code><a href="#mediacontroller">MediaController</a></code>, to the time of the latest <a href="#media-resource-end-position">media
  resource end position</a> of the <a data-anolis-xref="media resource" href="#media-resource">media resources</a> of the
  <a href="#slaved-media-elements">slaved media elements</a> of the <code><a href="#mediacontroller">MediaController</a></code>, again relative to this
  <code><a href="#mediacontroller">MediaController</a></code> timeline.</p>

  <p>Each <code><a href="#mediacontroller">MediaController</a></code> has a <dfn id="media-controller-position">media controller position</dfn>. This is the time
  on the <code><a href="#mediacontroller">MediaController</a></code>'s timeline at which the user agent is trying to play the
  <a href="#slaved-media-elements">slaved media elements</a>. When a <code><a href="#mediacontroller">MediaController</a></code> is created, its
  <a href="#media-controller-position">media controller position</a> is initially zero.</p>

  <p>When the user agent is to <dfn data-anolis-xref="bring the media element up to speed with its new media
  controller" id="bring-the-media-element-up-to-speed-with-its-new-media-controller">bring a media element up to speed with its new media controller</dfn>, it must <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> that <a href="#media-element">media element</a> to the
  <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-position">media controller position</a> relative to the <a href="#media-element">media
  element</a>'s timeline.</p>

  <p>When the user agent is to <dfn id="seek-the-media-controller">seek the media controller</dfn> to a particular <var data-anolis-xref="">new playback position</var>, it must follow these steps:</p>

  <ol><li><p>If the <var data-anolis-xref="">new playback position</var> is less than zero, then set it to
   zero.</li>

   <li><p>If the <var data-anolis-xref="">new playback position</var> is greater than the <a href="#media-controller-duration">media
   controller duration</a>, then set it to the <a href="#media-controller-duration">media controller duration</a>.</li>

   <li><p>Set the <a href="#media-controller-position">media controller position</a> to the <var data-anolis-xref="">new playback
   position</var>.</li>

   <li><p><a data-anolis-xref="dom-media-seek" href="#dom-media-seek">Seek</a> each <a data-anolis-xref="slaved media elements" href="#slaved-media-elements">slaved
   media element</a> to the <var data-anolis-xref="">new playback position</var> relative to the <a href="#media-element">media
   element</a> timeline.</li><!-- i.e. "bring the media element up to speed with its new
   media controller" --> 

  </ol><p>A <code><a href="#mediacontroller">MediaController</a></code> is a <dfn id="restrained-media-controller">restrained media controller</dfn> if the
  <code><a href="#mediacontroller">MediaController</a></code> is a <a href="#playing-media-controller">playing media controller</a>, but either at least one
  of its <a href="#slaved-media-elements">slaved media elements</a> whose <a href="#autoplaying-flag">autoplaying flag</a> is true still has
  its <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute set to true, or, all of its
  <a href="#slaved-media-elements">slaved media elements</a> have their <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>
  attribute set to true.</p>

  <p>A <code><a href="#mediacontroller">MediaController</a></code> is a <dfn id="blocked-media-controller">blocked media controller</dfn> if the
  <code><a href="#mediacontroller">MediaController</a></code> is a <a href="#paused-media-controller">paused media controller</a>, or if any of its
  <a href="#slaved-media-elements">slaved media elements</a> are <a data-anolis-xref="blocked media element" href="#blocked-media-element">blocked media
  elements</a>, or if any of its <a href="#slaved-media-elements">slaved media elements</a> whose <a href="#autoplaying-flag">autoplaying
  flag</a> is true still have their <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute set to
  true, or if all of its <a href="#slaved-media-elements">slaved media elements</a> have their <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute set to true.</p>

  <p>A <a href="#media-element">media element</a> is <dfn id="blocked-on-its-media-controller">blocked on its media controller</dfn> if the
  <code><a href="#mediacontroller">MediaController</a></code> is a <a href="#blocked-media-controller">blocked media controller</a>, or if its <a href="#media-controller-position">media
  controller position</a> is either before the <a href="#media-resource">media resource</a>'s <a href="#earliest-possible-position">earliest
  possible position</a> relative to the <code><a href="#mediacontroller">MediaController</a></code>'s timeline or after the end
  of the <a href="#media-resource">media resource</a> relative to the <code><a href="#mediacontroller">MediaController</a></code>'s timeline.</p>

  <p id="controller-playback">When a <code><a href="#mediacontroller">MediaController</a></code> is not a <a href="#blocked-media-controller">blocked media
  controller</a> and it has at least one <a data-anolis-xref="slaved media elements" href="#slaved-media-elements">slaved media
  element</a> whose <code><a href="dom.html#document">Document</a></code> is a <a href="browsers.html#fully-active">fully active</a> <code><a href="dom.html#document">Document</a></code>,
  the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-position">media controller position</a> must increase
  monotonically at <a href="#media-controller-playback-rate">media controller playback rate</a> units of time on the
  <code><a href="#mediacontroller">MediaController</a></code>'s timeline per unit time of the clock used by its <a href="#slaved-media-elements">slaved media
  elements</a>.</p>

  <p>When the zero point on the timeline of a <code><a href="#mediacontroller">MediaController</a></code> moves relative to the
  timelines of the <a href="#slaved-media-elements">slaved media elements</a> by a time difference <var data-anolis-xref="">ΔT</var>, the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#media-controller-position">media controller
  position</a> must be decremented by <var data-anolis-xref="">ΔT</var>.</p>

  <p class="note">In some situations, e.g. when playing back a live stream without buffering
  anything, the <a href="#media-controller-position">media controller position</a> would increase monotonically as described
  above at the same rate as the <var data-anolis-xref="">ΔT</var> described in the previous paragraph
  decreases it, with the end result that for all intents and purposes, the <a href="#media-controller-position">media controller
  position</a> would appear to remain constant (probably with the value 0).</p>

  <hr><p>A <code><a href="#mediacontroller">MediaController</a></code> has a <dfn id="most-recently-reported-readiness-state">most recently reported readiness state</dfn>, which
  is a number from 0 to 4 derived from the numbers used for the <a href="#media-element">media element</a> <code data-anolis-xref="attr-media-readyState">readyState</code> attribute, and a <dfn id="most-recently-reported-playback-state">most recently reported
  playback state</dfn>, which is either <i>playing</i>, <i>waiting</i>, or <i>ended</i>.</p>

  <p>When a <code><a href="#mediacontroller">MediaController</a></code> is created, its <a href="#most-recently-reported-readiness-state">most recently reported readiness
  state</a> must be set to 0, and its <a href="#most-recently-reported-playback-state">most recently reported playback state</a> must be
  set to <i>waiting</i>.</p>

  <p>When a user agent is required to <dfn id="report-the-controller-state">report the controller state</dfn> for a
  <code><a href="#mediacontroller">MediaController</a></code>, the user agent must run the following steps:</p>

  <ol><li>

    <p>If the <code><a href="#mediacontroller">MediaController</a></code> has no <a href="#slaved-media-elements">slaved media elements</a>, let <var data-anolis-xref="">new readiness state</var> be 0.</p>

    <p>Otherwise, let it have the lowest value of the <code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code> IDL attributes of all of its <a href="#slaved-media-elements">slaved media
    elements</a>.</p>

   </li>

   <li>

    <p>If the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#most-recently-reported-readiness-state">most recently reported readiness state</a> is
    less than the <var data-anolis-xref="">new readiness state</var>, then run these substeps:</p>

    <ol><li><p>Let <var data-anolis-xref="">next state</var> be the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#most-recently-reported-readiness-state">most
     recently reported readiness state</a>.</li>

     <li><p><i>Loop</i>: Increment <var data-anolis-xref="">next state</var> by one.</li>

     <li>

      <p><a href="webappapis.html#queue-a-task">Queue a task</a> to run the following steps:</p>

      <ol><li><p>Set the <code><a href="#mediacontroller">MediaController</a></code>'s <code data-anolis-xref="dom-MediaController-readyState"><a href="#dom-mediacontroller-readystate">readyState</a></code> attribute to the value <var data-anolis-xref="">next state</var>.</li>

       <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> at the <code><a href="#mediacontroller">MediaController</a></code> object, whose
       name is the event name corresponding to the value of <var data-anolis-xref="">next state</var> given in
       the table below.</li>

      </ol></li>

     <li><p>If <var data-anolis-xref="">next state</var> is less than <var data-anolis-xref="">new readiness state</var>,
     then return to the step labeled <i>loop</i>.</li>

    </ol><p>Otherwise, if the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#most-recently-reported-readiness-state">most recently reported readiness
    state</a> is greater than <var data-anolis-xref="">new readiness state</var> then <a href="webappapis.html#queue-a-task">queue a
    task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> at the <code><a href="#mediacontroller">MediaController</a></code> object,
    whose name is the event name corresponding to the value of <var data-anolis-xref="">new readiness
    state</var> given in the table below.</p>

    <table><thead><tr><th>Value of <var data-anolis-xref="">new readiness state</var>
       </th><th>イベント名

     <tbody></th></tr><tr><td>  0
       
       </td><td> <code data-anolis-xref="event-MediaController-emptied"><a href="#event-mediacontroller-emptied">emptied</a></code>

      </td></tr><tr><td>  1
       
       </td><td> <code data-anolis-xref="event-MediaController-loadedmetadata"><a href="#event-mediacontroller-loadedmetadata">loadedmetadata</a></code>

      </td></tr><tr><td>  2
       
       </td><td> <code data-anolis-xref="event-MediaController-loadeddata"><a href="#event-mediacontroller-loadeddata">loadeddata</a></code>

      </td></tr><tr><td>  3
       
       </td><td> <code data-anolis-xref="event-MediaController-canplay"><a href="#event-mediacontroller-canplay">canplay</a></code>

      </td></tr><tr><td>  4
       
       </td><td> <code data-anolis-xref="event-MediaController-canplaythrough"><a href="#event-mediacontroller-canplaythrough">canplaythrough</a></code>

    </td></tr></table></li>

   <li><p>Let the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#most-recently-reported-readiness-state">most recently reported readiness state</a>
   be <var data-anolis-xref="">new readiness state</var>.</li>

   <li>

    <p>Initialise <var data-anolis-xref="">new playback state</var> by setting it to the state given for the
    first matching condition from the following list:</p>

    <dl class="switch"><dt>If the <code><a href="#mediacontroller">MediaController</a></code> has no <a href="#slaved-media-elements">slaved media elements</a></dt>

     <dd>Let <var data-anolis-xref="">new playback state</var> be <i>waiting</i>.</dd>

     <dt>If all of the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#slaved-media-elements">slaved media elements</a> have
     <a href="#ended-playback">ended playback</a> and the <a href="#media-controller-playback-rate">media controller playback rate</a> is positive or
     zero</dt>

     <dd>Let <var data-anolis-xref="">new playback state</var> be <i>ended</i>.</dd>

     <dt>If the <code><a href="#mediacontroller">MediaController</a></code> is a <a href="#blocked-media-controller">blocked media controller</a></dt>

     <dd>Let <var data-anolis-xref="">new playback state</var> be <i>waiting</i>.</dd>

     <dt>そうでなければ</dt>

     <dd>Let <var data-anolis-xref="">new playback state</var> be <i>playing</i>.</dd>

    </dl></li>

   <li><p>If the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#most-recently-reported-playback-state">most recently reported playback state</a>
   is not equal to <var data-anolis-xref="">new playback state</var> and the <var data-anolis-xref="">new playback
   state</var> is <i>ended</i>, then <a href="webappapis.html#queue-a-task">queue a task</a> that, if the
   <code><a href="#mediacontroller">MediaController</a></code> object is a <a href="#playing-media-controller">playing media controller</a>, and all of the
   <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#slaved-media-elements">slaved media elements</a> have still <a href="#ended-playback">ended
   playback</a>, and the <a href="#media-controller-playback-rate">media controller playback rate</a> is still positive or zero,
   changes the <code><a href="#mediacontroller">MediaController</a></code> object to a <a href="#paused-media-controller">paused media controller</a> and
   then <a data-anolis-xref="fire a simple event" href="webappapis.html#fire-a-simple-event">fires a simple event</a> named <code data-anolis-xref="event-MediaController-pause"><a href="#event-mediacontroller-pause">pause</a></code> at the <code><a href="#mediacontroller">MediaController</a></code>
   object.</li>

   <li>

    <p>If the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#most-recently-reported-playback-state">most recently reported playback state</a> is
    not equal to <var data-anolis-xref="">new playback state</var> then <a href="webappapis.html#queue-a-task">queue a task</a> to run the
    following steps:</p>

    <ol><li><p>Set the <code><a href="#mediacontroller">MediaController</a></code>'s <code data-anolis-xref="dom-MediaController-playbackState"><a href="#dom-mediacontroller-playbackstate">playbackState</a></code> attribute to the value given in
     the second column of the row of the following table whose first column contains the <var data-anolis-xref="">new playback state</var>.</li>

     <li><p><a href="webappapis.html#fire-a-simple-event">Fire a simple event</a> at the <code><a href="#mediacontroller">MediaController</a></code> object, whose name
     is the value given in the third column of the row of the following table whose first column
     contains the <var data-anolis-xref="">new playback state</var>.</li>

    </ol><table><thead><tr><th>New playback state
       
       </th><th>New value for <code data-anolis-xref="dom-MediaController-playbackState"><a href="#dom-mediacontroller-playbackstate">playbackState</a></code>
       </th><th>イベント名
     <tbody></th></tr><tr><td><i>playing</i>
       </td><td>"<dfn data-anolis-xref="dom-MediaController-playing" id="dom-mediacontroller-playing"><code>playing</code></dfn>"
       
       </td><td><code data-anolis-xref="event-MediaController-playing"><a href="#event-mediacontroller-playing">playing</a></code>
      </td></tr><tr><td><i>waiting</i>
       </td><td>"<dfn data-anolis-xref="dom-MediaController-waiting" id="dom-mediacontroller-waiting"><code>waiting</code></dfn>"
       
       </td><td><code data-anolis-xref="event-MediaController-waiting"><a href="#event-mediacontroller-waiting">waiting</a></code>
      </td></tr><tr><td><i>ended</i>
       </td><td>"<dfn data-anolis-xref="dom-MediaController-ended" id="dom-mediacontroller-ended"><code>ended</code></dfn>"
       
       </td><td><code data-anolis-xref="event-MediaController-ended"><a href="#event-mediacontroller-ended">ended</a></code>
    </td></tr></table></li>

   <li><p>Let the <code><a href="#mediacontroller">MediaController</a></code>'s <a href="#most-recently-reported-playback-state">most recently reported playback state</a>
   be <var data-anolis-xref="">new playback state</var>.</li>

  </ol><hr><p>The following are the <a href="webappapis.html#event-handlers">event handlers</a> (and their corresponding <a data-anolis-xref="event
  handler event type" href="webappapis.html#event-handler-event-type">event handler event types</a>) <span class="impl">that must be</span> supported, as <a href="webappapis.html#event-handler-idl-attributes">event handler IDL attributes</a>,
  by all objects implementing the <code><a href="#mediacontroller">MediaController</a></code> interface:</p>

  <table><thead><tr><th><a data-anolis-xref="event handlers" href="webappapis.html#event-handlers">イベントハンドラ</a> </th><th><a href="webappapis.html#event-handler-event-type">イベントハンドライベント型</a>
   <tbody></th></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onemptied" id="handler-mediacontroller-onemptied"><code>onemptied</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-emptied"><a href="#event-mediacontroller-emptied">emptied</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onloadedmetadata" id="handler-mediacontroller-onloadedmetadata"><code>onloadedmetadata</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-loadedmetadata"><a href="#event-mediacontroller-loadedmetadata">loadedmetadata</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onloadeddata" id="handler-mediacontroller-onloadeddata"><code>onloadeddata</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-loadeddata"><a href="#event-mediacontroller-loadeddata">loadeddata</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-oncanplay" id="handler-mediacontroller-oncanplay"><code>oncanplay</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-canplay"><a href="#event-mediacontroller-canplay">canplay</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-oncanplaythrough" id="handler-mediacontroller-oncanplaythrough"><code>oncanplaythrough</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-canplaythrough"><a href="#event-mediacontroller-canplaythrough">canplaythrough</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onplaying" id="handler-mediacontroller-onplaying"><code>onplaying</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-playing"><a href="#event-mediacontroller-playing">playing</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onended" id="handler-mediacontroller-onended"><code>onended</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-ended"><a href="#event-mediacontroller-ended">ended</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onwaiting" id="handler-mediacontroller-onwaiting"><code>onwaiting</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-waiting"><a href="#event-mediacontroller-waiting">waiting</a></code>
   <tbody></td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-ondurationchange" id="handler-mediacontroller-ondurationchange"><code>ondurationchange</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-durationchange"><a href="#event-mediacontroller-durationchange">durationchange</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-ontimeupdate" id="handler-mediacontroller-ontimeupdate"><code>ontimeupdate</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-timeupdate"><a href="#event-mediacontroller-timeupdate">timeupdate</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onplay" id="handler-mediacontroller-onplay"><code>onplay</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-play"><a href="#event-mediacontroller-play">play</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onpause" id="handler-mediacontroller-onpause"><code>onpause</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-pause"><a href="#event-mediacontroller-pause">pause</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onratechange" id="handler-mediacontroller-onratechange"><code>onratechange</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-ratechange"><a href="#event-mediacontroller-ratechange">ratechange</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-MediaController-onvolumechange" id="handler-mediacontroller-onvolumechange"><code>onvolumechange</code></dfn> </td><td> <code data-anolis-xref="event-MediaController-volumechange"><a href="#event-mediacontroller-volumechange">volumechange</a></code>
  </td></tr></table><hr><p>このセクションに記載される<a data-anolis-xref="concept-task" href="webappapis.html#concept-task">タスク</a>の<a href="webappapis.html#task-source">タスクソース</a>は、<a href="webappapis.html#dom-manipulation-task-source">DOM操作タスクソース</a>である。</p>

  </div>


  <h6 id="assigning-a-media-controller-declaratively"><span class="secno">4.7.14.11.3</span> 宣言的メディアコントローラを割り当てる</h6>

  <p><a data-anolis-xref="media element" href="#media-element">メディア要素</a>の<dfn data-anolis-xref="attr-media-mediagroup" id="attr-media-mediagroup"><code>mediagroup</code></dfn>コンテンツ属性は、暗黙的に<code><a href="#mediacontroller">MediaController</a></code>を作成することによって、複数の<a data-anolis-xref="media
  element" href="#media-element">メディア要素</a>をリンクするために使用できる。値はテキストである。同じ値を持つ<a data-anolis-xref="media element" href="#media-element">メディア要素</a>はユーザーエージェントによって自動的にリンクされる。</p>

  <div class="impl">

  <p>When a <a href="#media-element">media element</a> is created with a <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> attribute, and when a <a href="#media-element">media element</a>'s
  <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> attribute is set, changed, or removed, the
  user agent must run the following steps:</p>

  <ol><!-- very similar to the algorithm above for setting the IDL attribute --><li><p>Let <var data-anolis-xref="">m</var> be the <a href="#media-element">media element</a> in question.</li>

   <li><p>Let <var data-anolis-xref="">old controller</var> be <var data-anolis-xref="">m</var>'s <a href="#current-media-controller">current media
   controller</a>, if it currently has one, and null otherwise.</li>

   <li><p>Let <var data-anolis-xref="">new controller</var> be null.</li>

   <li><p>Let <var data-anolis-xref="">m</var> have no <a href="#current-media-controller">current media controller</a>, if it currently
   has one.</li>

   <li><p>If <var data-anolis-xref="">m</var>'s <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> attribute
   is being removed, then jump to the <i>update controllers</i> step below.</li>

   <li>

    <p>If there is another <a href="#media-element">media element</a> whose <code><a href="dom.html#document">Document</a></code> is the same as
    <var data-anolis-xref="">m</var>'s <code><a href="dom.html#document">Document</a></code> (even if one or both of these elements are not
    actually <a data-anolis-xref="in a Document" href="infrastructure.html#in-a-document"><em>in</em> the <code>Document</code></a>), and which
    also has a <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> attribute, and whose <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> attribute has the same value as the new value of
    <var data-anolis-xref="">m</var>'s <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> attribute, then
    let <var data-anolis-xref="">controller</var> be that <a href="#media-element">media element</a>'s <a href="#current-media-controller">current media
    controller</a>.</p>

    <p>Otherwise, let <var data-anolis-xref="">controller</var> be a newly created
    <code><a href="#mediacontroller">MediaController</a></code>.</p>

   </li>

   <li><p>Let <var data-anolis-xref="">m</var>'s <a href="#current-media-controller">current media controller</a> be <var data-anolis-xref="">controller</var>.</li>

   <li><p>Let <var data-anolis-xref="">new controller</var> be <var data-anolis-xref="">m</var>'s <a href="#current-media-controller">current media
   controller</a>.</li>

   <li><p><a href="#bring-the-media-element-up-to-speed-with-its-new-media-controller">Bring the media element up to speed with its new media
   controller</a>.</li>

   <li><p><i>Update controllers</i>: If <var data-anolis-xref="">old
   controller</var> and <var data-anolis-xref="">new controller</var> are the
   same (whether both null or both the same controller) then abort
   these steps.</li>

   <li><p>If <var data-anolis-xref="">old controller</var> is not null and still has one or more <a href="#slaved-media-elements">slaved
   media elements</a>, then <a href="#report-the-controller-state">report the controller state</a> for <var data-anolis-xref="">old
   controller</var>.</li>

   <li><p>If <var data-anolis-xref="">new controller</var> is not null, then <a href="#report-the-controller-state">report the controller
   state</a> for <var data-anolis-xref="">new controller</var>.</li>

  </ol><p>The <dfn data-anolis-xref="dom-media-mediaGroup" id="dom-media-mediagroup"><code>mediaGroup</code></dfn> IDL attribute on <a data-anolis-xref="media element" href="#media-element">media elements</a> must <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code> content attribute.</p>

  </div>

  <div class="example">

   <p>同じ<a href="#media-resource">メディアリソース</a>を参照する複数の<a data-anolis-xref="media element" href="#media-element">メディア要素</a>は、単一のネットワーク要求を共有する。これは、画面上の2つの異なる場所で同じ<a href="#media-resource">メディアリソース</a>から2つの（ビデオ）トラックを効率的に再生するために使用できる。<code data-anolis-xref="attr-media-mediagroup"><a href="#attr-media-mediagroup">mediagroup</a></code>属性と共に使用して、これらの要素はまた同期を維持できる。</p>

   <p>この例において、ムービーファイル由来の手話通訳トラックが、2つの<code><a href="#the-video-element">video</a></code>要素、複数のCSS、および暗黙的な<code><a href="#mediacontroller">MediaController</a></code>を使用する、その同じビデオファイルの主ビデオトラック上にオーバーレイされる：</p>

   <pre>&lt;article&gt;
 &lt;style scoped&gt;
  div { margin: 1em auto; position: relative; width: 400px; height: 300px; }
  video { position; absolute; bottom: 0; right: 0; }
  video:first-child { width: 100%; height: 100%; }
  video:last-child { width: 30%; }
 &lt;/style&gt;
 &lt;div&gt;
  &lt;video src="movie.vid#track=Video&amp;amp;track=English" autoplay controls mediagroup=movie&gt;&lt;/video&gt;
  &lt;video src="movie.vid#track=sign" autoplay mediagroup=movie&gt;&lt;/video&gt;
 &lt;/div&gt;
&lt;/article&gt;</pre>

  </div><!--v2:
  <h6>Ducking</h6>

  <p><dfn>Ducking</dfn> is the process of reducing the volume of one audio track when another audio
  track is playing, for example occasionally reducing the volume of a soundtrack to allow the viewer
  to hear an intermittent commentary track.</p>

  (add an "autoduck" attribute that reduces the volume of other media elements with the same
  <span>current media controller</span> whenever this media element is playing audio)

   <video src="movie.vid#track=Video&amp;amp;track=English" autoplay controls mediagroup=main></video>
   <audio src="movie.vid#track=Descriptions" mediagroup=main autoduck></audio>
--><!--TOPIC:Video Text Tracks-->





  <h5 id="timed-text-tracks"><span class="secno">4.7.14.12</span> 時限テキストトラック</h5>

  <h6 id="text-track-model"><span class="secno">4.7.14.12.1</span> テキストトラックモデル</h6>

  <p><a href="#media-element">メディア要素</a>は、<a href="#media-element">メディア要素</a>の<dfn id="list-of-text-tracks">テキストトラックのリスト</dfn>として知られ、関連した<dfn data-anolis-xref="text track" id="text-track">テキストトラック</dfn>のグループを持つことができる。<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>は以下のようにソートされる：</p>

  <ol class="brief"><li><a href="infrastructure.html#tree-order">ツリー順</a>で、<a href="#media-element">メディア要素</a>の<code><a href="#the-track-element">track</a></code>要素の子に対応する<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>。</li>

   <li>古いものから順で、追加された順に、<code data-anolis-xref="dom-media-addTextTrack"><a href="#dom-media-addtexttrack">addTextTrack()</a></code>メソッドを使用して追加された任意の<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>。</li>

   <li><a href="#media-resource">メディアリソース</a>の書式仕様によって定義された順序で、任意の<a data-anolis-xref="media-resource-specific text track" href="#media-resource-specific-text-track">メディアリソース固有のテキストトラック</a>（<a href="#media-resource">メディアリソース</a>が内のデータに対応する<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>）。</li>

  </ol><p><a href="#text-track">テキストトラック</a>の構成要素は次のとおり：</p>

  <dl><dt><dfn data-anolis-xref="text track kind" id="text-track-kind">テキストトラックの種類</dfn>

   <dd>

    <p>これは、トラックがユーザーエージェントによって処理される方法を決定する。種類は文字列で表される。可能性のある文字列は次のとおり：</p>

    <ul class="brief"><li><dfn data-anolis-xref="dom-TextTrack-kind-subtitles" id="dom-texttrack-kind-subtitles"><code>subtitles</code></dfn>
     </li><li><dfn data-anolis-xref="dom-TextTrack-kind-captions" id="dom-texttrack-kind-captions"><code>captions</code></dfn>
     </li><li><dfn data-anolis-xref="dom-TextTrack-kind-descriptions" id="dom-texttrack-kind-descriptions"><code>descriptions</code></dfn>
     </li><li><dfn data-anolis-xref="dom-TextTrack-kind-chapters" id="dom-texttrack-kind-chapters"><code>chapters</code></dfn>
     </li><li><dfn data-anolis-xref="dom-TextTrack-kind-metadata" id="dom-texttrack-kind-metadata"><code>metadata</code></dfn>
    </li></ul><p><code><a href="#the-track-element">track</a></code>要素に対応する<a href="#text-track">テキストトラック</a>の場合、<a data-anolis-xref="text track kind" href="#text-track-kind">トラックの種類</a>は動的に変更できる。</p>

   </dd>

   <dt><dfn data-anolis-xref="text track label" id="text-track-label">ラベル</dfn>

   <dd>

    <p>これは、ユーザーに対するトラックを特定するために意図する判読可能な文字列である。</p>

    <p><code><a href="#the-track-element">track</a></code>要素に対応する<a href="#text-track">テキストトラック</a>の場合、<a data-anolis-xref="text track label" href="#text-track-label">トラックのラベル</a>は動的に変更できる。</p>

    <p><a href="#text-track-label">テキストトラックのラベル</a>が空の文字列である場合、ユーザーエージェントは自動的にそのユーザーインターフェースで使用するためのテキストトラックの他のプロパティー（たとえばテキストトラックの種類とテキストトラックの言語など）から適切なラベルを生成すべきである。この自動生成されたラベルは、APIで公開されない。</p>

   </dd>

   <dt><dfn data-anolis-xref="text track in-band metadata track dispatch type" id="text-track-in-band-metadata-track-dispatch-type">帯域内のメタデータトラックディスパッチタイプ</dfn>

   <dd>

    <p>これは、文書内の別のスクリプトに派遣できるようにするためにトラックを有効にする帯域内メタデータトラックに対する<a href="#media-resource">メディアリソース</a>から抽出された文字列である。</p>

    <p class="example">たとえば、ウェブ上やウェブ固有のインタラクティブ機能でのストリーミングによる従来のTV局の放送は、広告対象、ゲームショーの間のトリビアゲームデータ、スポーツゲームの間の選手の状態、食糧計画中のレシピ情報などに対するメタデータをもつテキストトラックを含むかもしれない。各プログラムが開始および終了すると、新しいトラックが追加されたりストリームから削除されたり、各トラックが追加されると、ユーザーエージェントはこの属性値を使用する専用のスクリプトモジュールにトラックを結合できる。</p>

    <p>帯域内のメタデータテキストトラック以外では、<a data-anolis-xref="text track in-band metadata
    track dispatch type" href="#text-track-in-band-metadata-track-dispatch-type">帯域内のメタデータトラックディスパッチタイプ</a>は、空の文字列である。この値が異なるメディア形式に対してどのように設定されるかは、<a href="#steps-to-expose-a-media-resource-specific-text-track">メディアリソース固有のテキストトラックを公開するための手順</a>に記載される。</p>

   </dd>

   <dt><dfn data-anolis-xref="text track language" id="text-track-language">言語</dfn>

   <dd>

    <p>これは、テキストトラックのキューの言語を表す文字列（BCP 47言語タグ）である。<a href="references.html#refsBCP47">[BCP47]</a></p>

    <p><code><a href="#the-track-element">track</a></code>要素に対応する<a href="#text-track">テキストトラック</a>の場合、<a data-anolis-xref="text track language" href="#text-track-language">テキストトラックの言語</a>は、動的に変更できる。</p>

   </dd>

   <dt><dfn data-anolis-xref="text track readiness state" id="text-track-readiness-state">準備状態</dfn>

   <dd>

    <p>以下のうちの1つをとる：</p>

    <dl><dt><dfn data-anolis-xref="text track not loaded" id="text-track-not-loaded">ロードされてない</dfn>

     <dd>

      <p>テキストトラックのキューが得られていないことを示す。</p>

     </dd>

     <dt><dfn data-anolis-xref="text track loading" id="text-track-loading">ロード中</dfn>

     <dd>

      <p>テキストトラックがロードされており、これまでに検出された致命的なエラーがないことを示す。追加のキューは、依然としてパーサによってトラックに追加されるかもしれない。</p>

     </dd>

     <dt><dfn data-anolis-xref="text track loaded" id="text-track-loaded">ロードされた</dfn>

     <dd>

      <p>テキストトラックが致命的なエラーなしでロードされたことを示す。</p>

     </dd>

     <dt><dfn data-anolis-xref="text track failed to load" id="text-track-failed-to-load">ロードに失敗した</dfn>

     <dd>

      <p>テキストトラックは有効であるが、ユーザーエージェントがトラックを取得しようとした際、これが何らかの方法（たとえば<a href="infrastructure.html#url">URL</a>が<a data-anolis-xref="resolve a
      url" href="infrastructure.html#resolve-a-url">解決</a>できなかった、ネットワークエラー、未知のテキストトラック形式など）で失敗したことを示す。キューの一部または全部は、おそらく欠落しているか、含まれていないだろう。</p>

     </dd>

    </dl><p>トラックが得られるように、<a href="#text-track">テキストトラック</a>の<a data-anolis-xref="text track readiness state" href="#text-track-readiness-state">準備状態</a>を動的に変更する。</p>

   </dd>

   <dt><dfn data-anolis-xref="text track mode" id="text-track-mode">モード</dfn>

   <dd>

    <p>以下のうちの1つをとる：</p>

    <dl><dt><dfn data-anolis-xref="text track disabled" id="text-track-disabled">無効</dfn>

     <dd>

      <p>テキストトラックがアクティブでないことを示す。DOM内のトラックを公開する目的以外では、ユーザーエージェントはテキストトラックを無視している。どのキューもアクティブでなく、どのイベントも発火せず、ユーザーエージェントは、トラックのキューを得ることを試みることはない。</p>

     </dd>

     <dt><dfn data-anolis-xref="text track hidden" id="text-track-hidden">非表示</dfn>

     <dd>

      <p>テキストトラックがアクティブであるが、ユーザーエージェントは、積極的にキューを表示していないことを示す。どの試みもまだトラックのキューを得るために行われていない場合、ユーザーエージェントは、一瞬そのような試みを実行する。ユーザーエージェントは、キューがアクティブであるリストを維持しており、イベントはそれに応じて発火されている。</p>

     </dd>

     <dt><dfn data-anolis-xref="text track showing" id="text-track-showing">表示</dfn>

     <dd>

      <p>テキストトラックがアクティブであることを示す。どの試みもまだトラックのキューを得るために行われていない場合、ユーザーエージェントは、一瞬そのような試みを実行する。ユーザーエージェントは、キューがアクティブであるリストを維持しており、イベントはそれに応じて発火されている。また、<a data-anolis-xref="text track kind" href="#text-track-kind">種類</a>が<code data-anolis-xref="dom-TextTrack-kind-subtitles"><a href="#dom-texttrack-kind-subtitles">subtitles</a></code>や<code data-anolis-xref="dom-TextTrack-kind-captions"><a href="#dom-texttrack-kind-captions">captions</a></code>であるテキストトラックで、キューは必要に応じてビデオにオーバーレイされている。<a data-anolis-xref="text track kind" href="#text-track-kind">種類</a>が<code data-anolis-xref="dom-TextTrack-kind-descriptions"><a href="#dom-texttrack-kind-descriptions">descriptions</a></code>であるテキストトラックで、ユーザーエージェントは、非視覚的な方法でユーザーに使用可能なキューを作成している。そして、<a data-anolis-xref="text track kind" href="#text-track-kind">種類</a>が<code data-anolis-xref="dom-TextTrack-kind-chapters"><a href="#dom-texttrack-kind-chapters">chapters</a></code>であるテキストトラックで、ユーザーエージェントは、ユーザーがキューを選択することによって<a href="#media-resource">メディアリソース</a>の任意のポイントに移動することができるメカニズムをユーザーに利用可能にしている。</p>

     </dd>

    </dl></dd>

   <dt><dfn data-anolis-xref="text track list of cues" id="text-track-list-of-cues">0個以上のキューリスト</dfn>

   <dd>

    <p><dfn id="rules-for-updating-the-text-track-rendering">テキストトラックのレンダリングを更新するための規則</dfn>とともに、<a data-anolis-xref="text track cue" href="#text-track-cue">テキストトラックキュー</a>のリスト。たとえば、<a href="infrastructure.html#webvtt">WebVTT</a>に対して、<a href="infrastructure.html#rules-for-updating-the-display-of-webvtt-text-tracks">WebVTTテキストトラックの表示を更新するための規則</a>。<a href="references.html#refsWEBVTT">[WEBVTT]</a> </p>

    <p><a data-anolis-xref="text track list of cues" href="#text-track-list-of-cues">テキストトラックのキューのリスト</a>は、<a href="#text-track">テキスト·トラック</a>が<a data-anolis-xref="text track not
    loaded" href="#text-track-not-loaded">まだロードされていない</a>か、すでに<a data-anolis-xref="text track loading" href="#text-track-loading">ロード中</a>である、またはDOM操作に起因してのいずれかのために、動的に変更できる。</p>

   </dd>

  </dl><p>各<a href="#text-track">テキストトラック</a>は、対応する<code><a href="#texttrack">TextTrack</a></code>オブジェクトを持つ。</p>

  <hr><p>各<a href="#media-element">メディア要素</a>は、最初は空でなければならない<dfn id="list-of-pending-text-tracks">保留中のテキストトラックのリスト</dfn>、最初はfalseでなければならない<dfn id="blocked-on-parser">blocked-on-parser</dfn>フラグ、最初はfalseでなければならない<dfn id="did-perform-automatic-track-selection">did-perform-automatic-track-selection</dfn>フラグを持つ。</p>

  <p>ユーザーエージェントが<a href="#media-element">メディア要素</a>に属する<dfn id="populate-the-list-of-pending-text-tracks">保留中のテキストトラックのリストを追加する</dfn>必要がある場合、ユーザーエージェントは、<a href="#list-of-pending-text-tracks">保留中のテキストトラックのリスト</a>に要素の<a href="#list-of-text-tracks">テキストトラックのリスト</a>で各<a href="#text-track">テキストトラック</a>を追加しなければならない。要素のテキストトラックのリストで<a href="#text-track-mode">テキストトラックモード</a>は<a data-anolis-xref="text track disabled" href="#text-track-disabled">無効</a>であり、かつそのリストの<a href="#text-track-readiness-state">テキストトラックの準備状態</a>は<a data-anolis-xref="text track loading" href="#text-track-loading">ロード中</a>である。</p>

  <p><code><a href="#the-track-element">track</a></code>要素の親ノードが変更ときはいつでも、ユーザーエージェントは、要素が属する全<a href="#list-of-pending-text-tracks">保留中のテキストトラックのリスト</a>から該当する<a href="#text-track">テキストトラック</a>を削除しなければならない。</p>

  <p><a href="#text-track">テキストトラック</a>の<a href="#text-track-readiness-state">テキストトラックの準備状態</a>が<a data-anolis-xref="text track loaded" href="#text-track-loaded">ロードされる</a>か、<a data-anolis-xref="text track failed to load" href="#text-track-failed-to-load">ロードに失敗する</a>のいずれかに変更されるときはいつでも、ユーザーエージェントは、テキストトラックが属する全<a href="#list-of-pending-text-tracks">保留中のテキストトラックのリスト</a>から削除しなければならない。</p>

  <p><a href="#media-element">メディア要素</a>が<a href="syntax.html#html-parser">HTMLパーサ</a>や<a href="the-xhtml-syntax.html#xml-parser">XMLパーサ</a>によって作成された場合、ユーザーエージェントは、要素の<a href="#blocked-on-parser">blocked-on-parser</a>フラグをtrueに設定しなければならない。<a href="#media-element">メディア要素</a>が<a href="syntax.html#html-parser">HTMLパーサ</a>や<a href="the-xhtml-syntax.html#xml-parser">XMLパーサ</a>の<a href="syntax.html#stack-of-open-elements">オープン要素のスタック</a>からポップされる場合、ユーザーエージェントは、<a href="#honor-user-preferences-for-automatic-text-track-selection">自動テキストトラックの選択に対してユーザーの好みを尊重</a>しなければならず、<a href="#populate-the-list-of-pending-text-tracks">保留中のテキストトラックのリストを追加し</a>、要素の<a href="#blocked-on-parser">blocked-on-parser</a>フラグをfalseに設定する。</p>

  <p>要素の<a href="#list-of-pending-text-tracks">保留中のテキストトラックのリスト</a>が空であり、要素の<a href="#blocked-on-parser">blocked-on-parser</a>フラグがfalseの両方である場合、<a href="#media-element">メディア要素</a>の<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>は<dfn data-anolis-xref="the text tracks are ready" id="the-text-tracks-are-ready">準備</dfn>ができている。</p>

  <p>各<a href="#media-element">メディア要素</a>は、最初に未設定でなければならない<dfn id="pending-text-track-change-notification-flag">保留中のテキストトラック変更通知フラグ</dfn>を持つ。</p>

  <p><a href="#media-element">メディア要素</a>の<a href="#list-of-text-tracks">テキストトラックのリスト</a>に属する<a href="#text-track">テキストトラック</a>が、その<a href="#text-track-mode">テキストトラックモード</a>変更値を持つたびに、ユーザーエージェントは、<a href="#media-element">メディア要素</a>のために次の手順を実行しなければならない：</p>

  <ol><li><p><a href="#media-element">メディア要素</a>の<a href="#pending-text-track-change-notification-flag">保留中のテキストトラックの変更通知フラグ</a>が設定される場合、この手順を中止する。</li>

   <li><p><a href="#media-element">メディア要素</a>の<a href="#pending-text-track-change-notification-flag">保留中のテキストトラック変更通知フラグ</a>を設定する。</li>

   <li>

    <p>次の手順を実行する<a href="webappapis.html#queue-a-task">キュータスク</a>：</p>

    <ol><li><p><a href="#media-element">メディア要素</a>の<a href="#pending-text-track-change-notification-flag">保留中のテキストトラック変更通知フラグ</a>を設定解除する。</li>

     <li><p><a href="#media-element">メディア要素</a>の<code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks</a></code>属性の<code><a href="#texttracklist">TextTrackList</a></code>オブジェクトで<code data-anolis-xref="event-media-change"><a href="#event-media-change">change</a></code>に名付けられる<a href="webappapis.html#fire-a-simple-event">単純イベントを発火する</a>。</li>

    </ol></li>

   <li><p><a href="#media-element">メディア要素</a>の<a href="#show-poster-flag">ショーポスターフラグ</a>が設定されていない場合、手順の<i><a href="#time-marches-on">時間行進</a></i>を実行する。</li>

  </ol><p>このセクションに記載される<a data-anolis-xref="concept-task" href="webappapis.html#concept-task">タスク</a>の<a href="webappapis.html#task-source">タスクソース</a>は、<a href="webappapis.html#dom-manipulation-task-source">DOM操作タスクソース</a>である。</p>

  <hr><p><dfn id="text-track-cue">テキストトラックキュー</dfn>は、特定の時刻に表示され別の時刻に消滅するテキストに字幕やキャプションに対するインスタンスに対応する、<a href="#text-track">テキストトラック</a>で時刻依存のデータの単位である。</p>

  <p>各<a href="#text-track-cue">テキストトラックキュー</a>の構成は次のとおり：</p>

  <dl><dt><dfn data-anolis-xref="text track cue identifier" id="text-track-cue-identifier">識別子</dfn>
   <dd>
    <p>任意の文字列。</p>
   </dd>

   <dt><dfn data-anolis-xref="text track cue start time" id="text-track-cue-start-time">開始時刻</dfn>
   <dd>
    <p>時刻は、秒、秒の小数で、キューが適用される<a href="#media-data">メディアデータ</a>の範囲の開始を表現する。</p>
   </dd>

   <dt><dfn data-anolis-xref="text track cue end time" id="text-track-cue-end-time">終了時刻</dfn>
   <dd>
    <p>時刻は、秒、秒の小数で、キューが適用される<a href="#media-data">メディアデータ</a>の範囲の終了を表現する。</p>
   </dd>

   <dt><dfn data-anolis-xref="text track cue pause-on-exit flag" id="text-track-cue-pause-on-exit-flag">pause-on-exitフラグ</dfn>
   <dd>
    <p>キューが適用される範囲の最後に達した際の、<a href="#media-resource">メディアリソース</a>の再生が一時停止するかどうかを示す真偽値。</p>
   </dd>

   <dt>追加の形式固有のデータ</dt>
   <dd>
    <p>フォーマットのために必要なものとしての、追加フィールド。たとえば、WebVTTは、<a href="infrastructure.html#text-track-cue-writing-direction">テキストトラックキュー書き込み方向</a>などを持つ。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>
   </dd>

   <dt><dfn data-anolis-xref="text track cue data" id="text-track-cue-data">キューのデータ</dfn>
   <dd>
    <p>キューの生データ、および<dfn id="rules-for-rendering-the-cue-in-isolation">分離してキューをレンダリングするための規則</dfn>。</p>
    <p>このデータの正確な特徴は、フォーマットによって定義される。たとえば、WebVTTはテキストを使用する。</p>
   </dd>

  </dl><p class="note"><a href="#text-track-cue-start-time">テキストトラックキューの開始時刻</a>および<a href="#text-track-cue-end-time">テキストトラックキューの終了時刻</a>は負であってもよい。（時刻ゼロがアクティブにすることはできない前の全体のキュー、しかし、<a href="#current-playback-position">現在の再生位置</a>は負になることはない。）</p>

  <p>各<a href="#text-track-cue">テキストトラックキュー</a>は、対応する<code><a href="#texttrackcue">TextTrackCue</a></code>オブジェクト（より具体的には、たとえばWebVTTのキューが<code>VTTCue</code>インターフェースを使用するような、<code><a href="#texttrackcue">TextTrackCue</a></code>を継承したオブジェクト）を持つ。<a href="#text-track-cue">テキストトラックキュー</a>のメモリ内表現は、動的にこの<code><a href="#texttrackcue">TextTrackCue</a></code> APIを通して変更できる。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

  <p><a href="#text-track-cue">テキストトラックキュー</a>は、<a href="#text-track-cue">テキストトラックキュー</a>の特定の種類に対して仕様で定義されている、<a href="#rules-for-updating-the-text-track-rendering">テキストトラックレンダリングを更新するための規則</a>に関連付けられる。これらの規則は、キューを表すオブジェクトが<code data-anolis-xref="dom-TextTrack-addCue"><a href="#dom-texttrack-addcue">addCue()</a></code>メソッドを使用して<code><a href="#texttrack">TextTrack</a></code>オブジェクトに追加される際に特に使用される。</p>

  <p>加えて、各<a href="#text-track-cue">テキストトラックキュー</a>は、動的な2つの情報を持つ：</p>

  <dl><dt><dfn data-anolis-xref="text track cue active flag" id="text-track-cue-active-flag">アクティブフラグ</dfn>
   <dd>

    <p>このフラグは、最初に設定を解除されなければならない。キューがアクティブまたは非アクティブになった際、フラグは、イベントが適切に発火されるように、および右のキューがレンダリングされることを確認するために使用される。</p>

    <p><a href="#text-track-cue">テキストトラックキュー</a>がその<a href="#text-track">テキストトラック</a>の<a href="#text-track-list-of-cues">キューのテキストトラックリスト</a>から削除されるたびに、<a href="#text-track">テキストトラック</a>自体はその<a href="#media-element">メディア要素</a>の<a href="#list-of-text-tracks">テキストトラックのリスト</a>から削除される、または<a data-anolis-xref="text track
    disabled" href="#text-track-disabled">無効</a>に変更されるその<a href="#text-track-mode">テキストトラックモード</a>を持つたびに、かつ<a href="#media-element">メディア要素</a>の<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が<code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>に戻されるたびに、ユーザーエージェントは同期的にこのフラグを設定解除しなければならない。フラグが、関連付帯条件より前に<a data-anolis-xref="text track
    showing" href="#text-track-showing">表示</a>されていた<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>内の1つ以上のキューに対してこの方法で解除される場合、影響を受けるすべてのキューに対してフラグを解除した後、ユーザーエージェントは、これらの<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>に属する<a href="#rules-for-updating-the-text-track-rendering">テキストトラックのレンダリングを更新するための規則</a>を適用しなければならない。たとえば、<a href="infrastructure.html#webvtt">WebVTT</a>に基づく<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>用、<a href="infrastructure.html#rules-for-updating-the-display-of-webvtt-text-tracks">WebVTTテキストトラックの表示を更新するための規則</a>など。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p> </dd>

   <dt><dfn data-anolis-xref="text track cue display state" id="text-track-cue-display-state">表示状態</dfn>
   <dd>

    <p>これは、一貫性のある位置にキューを保つために、レンダリングモデルの一部として使用される。これは最初は空でなければならない。<a href="#text-track-cue-active-flag">テキストトラックキューのアクティブフラグ</a>が設定解除されるたびに、ユーザーエージェントは<a href="#text-track-cue-display-state">テキストトラックキューの表示状態</a>を空にしなければならない。</p>

   </dd>

  </dl><p><a href="#media-element">メディア要素</a>の<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>の<a data-anolis-xref="text track cue" href="#text-track-cue">テキストトラックキュー</a>は、<dfn id="text-track-cue-order">テキストトラックキュー順</dfn>に互いに相対的に順序付けされ、以下のように決定される：<a href="#media-element">メディア要素</a>の<a href="#list-of-text-tracks">テキストトラックのリスト</a>に出現するそれらの<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>として同じ順序でソートされるグループをもつ、それらの<a href="#text-track">テキストトラック</a>で最初のグループの<a data-anolis-xref="text track
  cue" href="#text-track-cue">キュー</a>：次に、各グループ内で、<a data-anolis-xref="text track
  cue" href="#text-track-cue">キュー</a>は、最も早いものの順に、その<a data-anolis-xref="text track cue start time" href="#text-track-cue-start-time">開始時刻</a>でソートされなければならない。それから、同じ<a data-anolis-xref="text track cue start time" href="#text-track-cue-start-time">開始時刻</a>を持つ任意の<a data-anolis-xref="text track cue" href="#text-track-cue">キュー</a>は、最も遅いものの順に、その<a data-anolis-xref="text track cue end time" href="#text-track-cue-end-time">終了時刻</a>でソートされなければならず、最後に、同一の<a data-anolis-xref="text track cue end time" href="#text-track-cue-end-time">終了時刻</a>を持つ任意の<a data-anolis-xref="text
  track cue" href="#text-track-cue">キュー</a>は、最も古いものの順に、それらがそれぞれの<a href="#text-track-list-of-cues">キューのテキストトラックリスト</a>に最後に追加した順にソートされなければならない。（たとえば、<a href="infrastructure.html#webvtt">WebVTT</a>ファイル由来のキューに対して、最初にファイルに記載されていた順でなど。）<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>


  <h6 id="sourcing-in-band-text-tracks"><span class="secno">4.7.14.12.2</span> 帯域内テキストトラックの情報源</h6>

  <p><dfn id="media-resource-specific-text-track">メディアリソース固有のテキストトラック</dfn>は<a href="#media-resource">メディアリソース</a>で見つけられるデータに対応する<a href="#text-track">テキストトラック</a>である。</p>


  <div class="impl">

  <p>Rules for processing and rendering such data are defined by the relevant specifications, e.g.
  the specification of the video format if the <a href="#media-resource">media resource</a> is a video.</p>

  <p>When a <a href="#media-resource">media resource</a> contains data that the user agent recognises and supports as
  being equivalent to a <a href="#text-track">text track</a>, the user agent <a href="#found-a-media-resource-specific-timed-track">runs</a> the <dfn id="steps-to-expose-a-media-resource-specific-text-track">steps to expose a
  media-resource-specific text track</dfn> with the relevant data, as follows.</p><!-- this runs synchronously from a fetch task -->

  

  <ol><li><p>Associate the relevant data with a new <a href="#text-track">text track</a> and its corresponding new
   <code><a href="#texttrack">TextTrack</a></code> object. The <a href="#text-track">text track</a> is a <a href="#media-resource-specific-text-track">media-resource-specific
   text track</a>.</li>

   <li><p>Set the new <a href="#text-track">text track</a>'s <a data-anolis-xref="text track kind" href="#text-track-kind">kind</a>, <a data-anolis-xref="text track label" href="#text-track-label">label</a>, and <a data-anolis-xref="text track language" href="#text-track-language">language</a>
   based on the semantics of the relevant data, as defined for the relevant format <a href="references.html#refsINBANDTRACKS">[INBANDTRACKS]</a>. If there is no label in that data, then the <a data-anolis-xref="text track label" href="#text-track-label">label</a> must be set to the empty string.</li>

   <li><p>Associate the <a href="#text-track-list-of-cues">text track list of cues</a> with the <a href="#rules-for-updating-the-text-track-rendering">rules for updating the
   text track rendering</a> appropriate for the format in question.</p>

   </li><li>

    <p>If the new <a href="#text-track">text track</a>'s <a data-anolis-xref="text track kind" href="#text-track-kind">kind</a> is <code data-anolis-xref="dom-TextTrack-kind-metadata"><a href="#dom-texttrack-kind-metadata">metadata</a></code>, then set the <a href="#text-track-in-band-metadata-track-dispatch-type">text track in-band
    metadata track dispatch type</a> as follows, based on the type of the <a href="#media-resource">media
    resource</a>:</p>

    <dl class="switch"><dt>If the <a href="#media-resource">media resource</a> is an Ogg file</dt>

     <dd>The <a href="#text-track-in-band-metadata-track-dispatch-type">text track in-band metadata track dispatch type</a> must be set to the value
     of the Role header field. <a href="references.html#refsOGGSKELETONHEADERS">[OGGSKELETONHEADERS]</a></dd>

     <dt>If the <a href="#media-resource">media resource</a> is a WebM file</dt>

     <dd>The <a href="#text-track-in-band-metadata-track-dispatch-type">text track in-band metadata track dispatch type</a> must be set to the value
     of the <code data-anolis-xref="">CodecID</code> element. <a href="references.html#refsWEBMCG">[WEBMCG]</a></dd>

     <dt>If the <a href="#media-resource">media resource</a> is an MPEG-2 file</dt>

     <dd>Let <var data-anolis-xref="">stream type</var> be the value of the "stream_type" field describing the
     text track's type in the file's program map section, interpreted as an 8-bit unsigned integer.
     Let <var data-anolis-xref="">length</var> be the value of the "ES_info_length" field for the track in the
     same part of the program map section, interpreted as an integer as defined by the MPEG-2
     specification. Let <var data-anolis-xref="">descriptor bytes</var> be the <var data-anolis-xref="">length</var> bytes
     following the "ES_info_length" field. The <a href="#text-track-in-band-metadata-track-dispatch-type">text track in-band metadata track dispatch
     type</a> must be set to the concatenation of the <var data-anolis-xref="">stream type</var> byte and
     the zero or more <var data-anolis-xref="">descriptor bytes</var> bytes, expressed in hexadecimal using
     <a href="infrastructure.html#uppercase-ascii-hex-digits">uppercase ASCII hex digits</a>. <a href="references.html#refsMPEG2">[MPEG2]</a>

     </dd>

     <dt>If the <a href="#media-resource">media resource</a> is an MPEG-4 file</dt>

     <dd>Let the
     first <code data-anolis-xref="">stsd</code> box of the
     first <code data-anolis-xref="">stbl</code> box of the
     first <code data-anolis-xref="">minf</code> box of the
     first <code data-anolis-xref="">mdia</code> box of the
     <a href="#text-track">text track</a>'s <code data-anolis-xref="">trak</code> box in the
     first <code data-anolis-xref="">moov</code> box
     of the file be the <i>stsd box</i>, if any.

     If the file has no <i>stsd box</i>, or if the <i>stsd box</i> has neither a <code data-anolis-xref="">mett</code> box nor a <code data-anolis-xref="">metx</code> box, then the <a href="#text-track-in-band-metadata-track-dispatch-type">text track
     in-band metadata track dispatch type</a> must be set to the empty string.

     Otherwise, if the <i>stsd box</i> has a <code data-anolis-xref="">mett</code> box then the <a href="#text-track-in-band-metadata-track-dispatch-type">text
     track in-band metadata track dispatch type</a> must be set to the concatenation of the
     string "<code data-anolis-xref="">mett</code>", a U+0020 SPACE character, and the value of the first <code data-anolis-xref="">mime_format</code> field of the first <code data-anolis-xref="">mett</code> box of the <i>stsd
     box</i>, or the empty string if that field is absent in that box.

     Otherwise, if the <i>stsd box</i> has no <code data-anolis-xref="">mett</code> box but has a <code data-anolis-xref="">metx</code> box then the <a href="#text-track-in-band-metadata-track-dispatch-type">text track in-band metadata track dispatch type</a>
     must be set to the concatenation of the string "<code data-anolis-xref="">metx</code>", a U+0020 SPACE
     character, and the value of the first <code data-anolis-xref="">namespace</code> field of the first <code data-anolis-xref="">metx</code> box of the <i>stsd box</i>, or the empty string if that field is absent in
     that box.

     <a href="references.html#refsMPEG4">[MPEG4]</a>

     </dd>

     <dt>If the <a href="#media-resource">media resource</a> is a DASH media resource</dt>

     <dd>The <a href="#text-track-in-band-metadata-track-dispatch-type">text track in-band metadata track dispatch type</a> must be set to the concatenation
      of the "AdaptationSet" element attributes and all child Role descriptors.

      <a href="references.html#refsDASH">[DASH]</a>

     </dd>

    </dl></li>

   <li><p>Populate the new <a href="#text-track">text track</a>'s <a data-anolis-xref="text track list of cues" href="#text-track-list-of-cues">list of
   cues</a> with the cues parsed so far, following the <a href="#guidelines-for-exposing-cues-in-various-formats-as-text-track-cues">guidelines for exposing
   cues</a>, and begin updating it dynamically as necessary.</li>

   <li><p>Set the new <a href="#text-track">text track</a>'s <a data-anolis-xref="text track readiness state" href="#text-track-readiness-state">readiness
   state</a> to <a data-anolis-xref="text track loaded" href="#text-track-loaded">loaded</a>.</li><!-- otherwise, you'll
   have to load the whole media file just to start playing the first frame... --> 

   <li><p>Set the new <a href="#text-track">text track</a>'s <a data-anolis-xref="text track mode" href="#text-track-mode">mode</a> to the
   mode consistent with the user's preferences and the requirements of the relevant specification
   for the data.</p>

    <p class="note">For instance, if there are no other active subtitles, and this is a forced
    subtitle track (a subtitle track giving subtitles in the audio track's primary language, but
    only for audio that is actually in another language), then those subtitles might be activated
    here.</p>

   </li><!-- it's too late to apply the normal heuristic, so we don't bother --> 

   <li><p>Add the new <a href="#text-track">text track</a> to the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text
   tracks</a>.</li>

   <li><p><a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">Fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-media-addtrack"><a href="#event-media-addtrack">addtrack</a></code>, that does not bubble and is not cancelable, and that uses
   the <code><a href="#trackevent">TrackEvent</a></code> interface, with the <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code>
   attribute initialised to the <a href="#text-track">text track</a>'s <code><a href="#texttrack">TextTrack</a></code> object, at the
   <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks</a></code> attribute's
   <code><a href="#texttracklist">TextTrackList</a></code> object.</li>

  </ol><!-- removetrack: we don't currently ever remove an in-band text track, because it might have been
  manipulated or might be about to be manipulated. If we made in-band text tracks readonly, we could
  probably get away with cleaning them up when they fall into the time before the earliest possible
  position and are known to be over and done with. --><!-- if, after in-band text tracks have been found, there's no out-of-band text tracks, then apply
  user prefs? --></div>



  <div class="impl">

  <h6 id="sourcing-out-of-band-text-tracks"><span class="secno">4.7.14.12.3 </span>Sourcing out-of-band text tracks</h6>

  <p>When a <code><a href="#the-track-element">track</a></code> element is created, it must be associated with a new <a href="#text-track">text
  track</a> (with its value set as defined below) and its corresponding new
  <code><a href="#texttrack">TextTrack</a></code> object.</p>

  <p>The <a href="#text-track-kind">text track kind</a> is determined from the state of the element's <code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code> attribute according to the following table; for a state given
  in a cell of the first column, the <a data-anolis-xref="text track kind" href="#text-track-kind">kind</a> is the string given
  in the second column:</p>

  <table><thead><tr><th>状態
     </th><th>String
   
   <tbody></th></tr><tr><td><a data-anolis-xref="attr-track-kind-subtitles" href="#attr-track-kind-subtitles">Subtitles</a>
     </td><td><code data-anolis-xref="dom-TextTrack-kind-subtitles"><a href="#dom-texttrack-kind-subtitles">subtitles</a></code>
    </td></tr><tr><td><a data-anolis-xref="attr-track-kind-captions" href="#attr-track-kind-captions">Captions</a>
     </td><td><code data-anolis-xref="dom-TextTrack-kind-captions"><a href="#dom-texttrack-kind-captions">captions</a></code>
    </td></tr><tr><td><a data-anolis-xref="attr-track-kind-descriptions" href="#attr-track-kind-descriptions">概要</a>
     </td><td><code data-anolis-xref="dom-TextTrack-kind-descriptions"><a href="#dom-texttrack-kind-descriptions">descriptions</a></code>
    </td></tr><tr><td><a data-anolis-xref="attr-track-kind-chapters" href="#attr-track-kind-chapters">Chapters</a>
     </td><td><code data-anolis-xref="dom-TextTrack-kind-chapters"><a href="#dom-texttrack-kind-chapters">chapters</a></code>
    </td></tr><tr><td><a data-anolis-xref="attr-track-kind-metadata" href="#attr-track-kind-metadata">Metadata</a>
     </td><td><code data-anolis-xref="dom-TextTrack-kind-metadata"><a href="#dom-texttrack-kind-metadata">metadata</a></code>
  </td></tr></table><p>The <a href="#text-track-label">text track label</a> is the element's <a href="#track-label">track label</a>.</p>

  <p>The <a href="#text-track-language">text track language</a> is the element's <a href="#track-language">track language</a>, if any, or
  the empty string otherwise.</p>

  <p>As the <code data-anolis-xref="attr-track-kind"><a href="#attr-track-kind">kind</a></code>, <code data-anolis-xref="attr-track-label"><a href="#attr-track-label">label</a></code>,
  and <code data-anolis-xref="attr-track-srclang"><a href="#attr-track-srclang">srclang</a></code> attributes are set, changed, or removed, the
  <a href="#text-track">text track</a> must update accordingly, as per the definitions above.</p>

  <p class="note">Changes to the <a href="#track-url">track URL</a> are handled in the algorithm below.</p>

  <p>The <a href="#text-track-readiness-state">text track readiness state</a> is initially <a data-anolis-xref="text track not
  loaded" href="#text-track-not-loaded">not loaded</a>, and the <a href="#text-track-mode">text track mode</a> is initially <a data-anolis-xref="text
  track disabled" href="#text-track-disabled">disabled</a>.</p>

  <p>The <a href="#text-track-list-of-cues">text track list of cues</a> is initially empty. It is dynamically modified when
  the referenced file is parsed. Associated with the list are the <a href="#rules-for-updating-the-text-track-rendering">rules for updating the text
  track rendering</a> appropriate for the format in question; for <a href="infrastructure.html#webvtt">WebVTT</a>, this is
  the <a href="infrastructure.html#rules-for-updating-the-display-of-webvtt-text-tracks">rules for updating the display of WebVTT text tracks</a>. <a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

  <p>When a <code><a href="#the-track-element">track</a></code> element's parent element changes and the new parent is a <a href="#media-element">media
  element</a>, then the user agent must add the <code><a href="#the-track-element">track</a></code> element's corresponding
  <a href="#text-track">text track</a> to the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>, and
  then <a href="webappapis.html#queue-a-task">queue a task</a> to <a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-media-addtrack"><a href="#event-media-addtrack">addtrack</a></code>, that does not bubble and is not cancelable, and that uses
  the <code><a href="#trackevent">TrackEvent</a></code> interface, with the <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code>
  attribute initialised to the <a href="#text-track">text track</a>'s <code><a href="#texttrack">TextTrack</a></code> object, at the
  <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks</a></code> attribute's
  <code><a href="#texttracklist">TextTrackList</a></code> object.</p>

  <p>When a <code><a href="#the-track-element">track</a></code> element's parent element changes and the old parent was a <a href="#media-element">media
  element</a>, then the user agent must remove the <code><a href="#the-track-element">track</a></code> element's corresponding
  <a href="#text-track">text track</a> from the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>,
  and then <a href="webappapis.html#queue-a-task">queue a task</a> to <a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-media-removetrack"><a href="#event-media-removetrack">removetrack</a></code>, that does not bubble and is not cancelable, and that
  uses the <code><a href="#trackevent">TrackEvent</a></code> interface, with the <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code> attribute initialised to the <a href="#text-track">text track</a>'s
  <code><a href="#texttrack">TextTrack</a></code> object, at the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks</a></code> attribute's <code><a href="#texttracklist">TextTrackList</a></code> object.</p><!-- removetrack -->
  

  <hr><p>When a <a href="#text-track">text track</a> corresponding to a <code><a href="#the-track-element">track</a></code> element is added to a
  <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>, the user agent must <a href="webappapis.html#queue-a-task">queue a
  task</a> to run the following steps for the <a href="#media-element">media element</a>:</p>

  <ol><li><p>If the element's <a href="#blocked-on-parser">blocked-on-parser</a> flag is true, abort these steps.</li>

   <li><p>If the element's <a href="#did-perform-automatic-track-selection">did-perform-automatic-track-selection</a> flag is true, abort
   these steps.</li>

   <li><p><a href="#honor-user-preferences-for-automatic-text-track-selection">Honor user preferences for automatic text track selection</a> for this
   element.</li>

  </ol><p>When the user agent is required to <dfn id="honor-user-preferences-for-automatic-text-track-selection">honor user preferences for automatic text track
  selection</dfn> for a <a href="#media-element">media element</a>, the user agent must run the following steps:</p>

  <ol><li><p><a href="#perform-automatic-text-track-selection">Perform automatic text track selection</a> for <code data-anolis-xref="dom-TextTrack-kind-subtitles"><a href="#dom-texttrack-kind-subtitles">subtitles</a></code> and <code data-anolis-xref="dom-TextTrack-kind-captions"><a href="#dom-texttrack-kind-captions">captions</a></code>.</li>

   <li><p><a href="#perform-automatic-text-track-selection">Perform automatic text track selection</a> for <code data-anolis-xref="dom-TextTrack-kind-descriptions"><a href="#dom-texttrack-kind-descriptions">descriptions</a></code>.</li>

   <li><p><a href="#perform-automatic-text-track-selection">Perform automatic text track selection</a> for <code data-anolis-xref="dom-TextTrack-kind-chapters"><a href="#dom-texttrack-kind-chapters">chapters</a></code>.</li>

   <li><p>If there are any <a data-anolis-xref="text track" href="#text-track">text tracks</a> in the <a href="#media-element">media
   element</a>'s <a href="#list-of-text-tracks">list of text tracks</a> whose <a href="#text-track-kind">text track kind</a> is <code data-anolis-xref="dom-TextTrack-kind-metadata"><a href="#dom-texttrack-kind-metadata">metadata</a></code> that correspond to <code><a href="#the-track-element">track</a></code>
   elements with a <code data-anolis-xref="attr-track-default"><a href="#attr-track-default">default</a></code> attribute set whose <a href="#text-track-mode">text
   track mode</a> is set to <a data-anolis-xref="text track disabled" href="#text-track-disabled">disabled</a>, then set the
   <a href="#text-track-mode">text track mode</a> of all such tracks to <a data-anolis-xref="text track
   hidden" href="#text-track-hidden">hidden</a></li>

   <li><p>Set the element's <a href="#did-perform-automatic-track-selection">did-perform-automatic-track-selection</a> flag to
   true.</li>

  </ol><p>When the steps above say to <dfn id="perform-automatic-text-track-selection">perform automatic text track selection</dfn> for one or more
  <a data-anolis-xref="text track kind" href="#text-track-kind">text track kinds</a>, it means to run the following steps:</p>

  <ol><li><p>Let <var data-anolis-xref="">candidates</var> be a list consisting of the <a data-anolis-xref="text
   track" href="#text-track">text tracks</a> in the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>
   whose <a href="#text-track-kind">text track kind</a> is one of the kinds that were passed to the algorithm, if any,
   in the order given in the <a href="#list-of-text-tracks">list of text tracks</a>.</li>

   <li><p>If <var data-anolis-xref="">candidates</var> is empty, then abort these steps.</li>

   <li><p>If any of the <a data-anolis-xref="text track" href="#text-track">text tracks</a> in <var data-anolis-xref="">candidates</var> have a <a href="#text-track-mode">text track mode</a> set to <a data-anolis-xref="text track
   showing" href="#text-track-showing">showing</a>, abort these steps.</li>

   <li>

    <p>If the user has expressed an interest in having a track from <var data-anolis-xref="">candidates</var>
    enabled based on its <a href="#text-track-kind">text track kind</a>, <a href="#text-track-language">text track language</a>, and
    <a href="#text-track-label">text track label</a>, then set its <a href="#text-track-mode">text track mode</a> to <a data-anolis-xref="text
    track showing" href="#text-track-showing">showing</a><!--, and if there are any <span data-x="text track">text
    tracks</span> in <var data-x="">candidates</var> that correspond to <code>track</code> elements
    with a <code data-x="attr-track-default">default</code> attribute set whose <span>text track
    mode</span> is set to <span data-x="text track disabled">disabled</span>, then additionally set
    the <span>text track mode</span> of the first such track to <span data-x="text track
    hidden">hidden</span>--></p><!-- the idea behind the commented out stuff is that we still get
    events and stuff: we can expect authors to forget that default doesn't mean that it'll always be
    turned on, and that they'll still rely on events firing even if it doesn't show. But it is
    commented out, because we can equally expect authors to expect only one track is getting events,
    so we've got problems either way, and might as well go with the simpler behaviour. --> 

    <p class="note">For example, the user could have set a browser preference to the effect of "I
    want French captions whenever possible", or "If there is a subtitle track with 'Commentary' in
    the title, enable it", or "If there are audio description tracks available, enable one, ideally
    in Swiss German, but failing that in Standard Swiss German or Standard German".</p>

    <p>Otherwise, if there are any <a data-anolis-xref="text track" href="#text-track">text tracks</a> in <var data-anolis-xref="">candidates</var> that correspond to <code><a href="#the-track-element">track</a></code> elements with a <code data-anolis-xref="attr-track-default"><a href="#attr-track-default">default</a></code> attribute set whose <a href="#text-track-mode">text track mode</a> is
    set to <a data-anolis-xref="text track disabled" href="#text-track-disabled">disabled</a>, then set the <a href="#text-track-mode">text track
    mode</a> of the first such track to <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a>.</p>

   </li>

  </ol><p>When a <a href="#text-track">text track</a> corresponding to a <code><a href="#the-track-element">track</a></code> element experiences any of
  the following circumstances, the user agent must <a href="#start-the-track-processing-model">start the <code>track</code> processing
  model</a> for that <a href="#text-track">text track</a> and its <code><a href="#the-track-element">track</a></code> element:

  

  <ul><li>The <code><a href="#the-track-element">track</a></code> element is created.</li>

   <li>The <a href="#text-track">text track</a> has its <a href="#text-track-mode">text track mode</a> changed.</li>

   <li>The <code><a href="#the-track-element">track</a></code> element's parent element changes and the new parent is a <a href="#media-element">media
   element</a>.</li>

  </ul><p>When a user agent is to <dfn id="start-the-track-processing-model">start the <code>track</code> processing model</dfn> for a
  <a href="#text-track">text track</a> and its <code><a href="#the-track-element">track</a></code> element, it must run the following algorithm.
  This algorithm interacts closely with the <a href="webappapis.html#event-loop">event loop</a> mechanism; in particular, it has
  a <a href="webappapis.html#synchronous-section">synchronous section</a> (which is triggered as part of the <a href="webappapis.html#event-loop">event loop</a>
  algorithm). The steps in that section are marked with ⌛.</p>

  <ol><li><p>If another occurrence of this algorithm is already running for this <a href="#text-track">text
   track</a> and its <code><a href="#the-track-element">track</a></code> element, abort these steps, letting that other algorithm
   take care of this element.</li>

   <li><p>If the <a href="#text-track">text track</a>'s <a href="#text-track-mode">text track mode</a> is not set to one of <a data-anolis-xref="text track hidden" href="#text-track-hidden">hidden</a> or <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a>, abort
   these steps.</li>

   <li><p>If the <a href="#text-track">text track</a>'s <code><a href="#the-track-element">track</a></code> element does not have a <a href="#media-element">media
   element</a> as a parent, abort these steps.</li>

   <li><p>Run the remainder of these steps asynchronously, allowing whatever caused these steps to
   run to continue.</li>

   <li><p><i>Top</i>: <a href="webappapis.html#await-a-stable-state">Await a stable state</a>. The <a href="webappapis.html#synchronous-section">synchronous section</a>
   consists of the following steps. (The steps in the <a href="webappapis.html#synchronous-section">synchronous section</a> are marked
   with ⌛.)</li>

   <li><p>⌛ Set the <a href="#text-track-readiness-state">text track readiness state</a> to <a data-anolis-xref="text track
   loading" href="#text-track-loading">loading</a>.</li>

   <li><p>⌛ Let <var data-anolis-xref="">URL</var> be the <a href="#track-url">track URL</a> of the
   <code><a href="#the-track-element">track</a></code> element.</li>

   <li><p>⌛ If the <code><a href="#the-track-element">track</a></code> element's parent is a <a href="#media-element">media element</a> then
   let <var data-anolis-xref="">CORS mode</var> be the state of the parent <a href="#media-element">media element</a>'s <code data-anolis-xref="attr-media-crossorigin"><a href="#attr-media-crossorigin">crossorigin</a></code> content attribute. Otherwise, let <var data-anolis-xref="">CORS mode</var> be <a data-anolis-xref="attr-crossorigin-none" href="infrastructure.html#attr-crossorigin-none">No CORS</a>.</li>

   <li><p>End the <a href="webappapis.html#synchronous-section">synchronous section</a>, continuing the remaining steps
   asynchronously.</li>

   <li>

    <p>If <var data-anolis-xref="">URL</var> is not the empty string, perform a <a href="infrastructure.html#potentially-cors-enabled-fetch">potentially CORS-enabled
    fetch</a><!--FETCH-->  of <var data-anolis-xref="">URL</var>, with the <i>mode</i> being <var data-anolis-xref="">CORS mode</var>, the <i data-anolis-xref="">origin</i> being the <a href="browsers.html#origin-0">origin</a> of the
    <code><a href="#the-track-element">track</a></code> element's <code><a href="dom.html#document">Document</a></code>, and the <i>default origin behaviour</i> set
    to <i>fail</i>.</p>

    <p>The resource obtained in this fashion, if any, contains the text track data. If any data is
    obtained, it is by definition <a href="infrastructure.html#cors-same-origin">CORS-same-origin</a> (cross-origin resources that are not
    suitably CORS-enabled do not get this far).</p>

    <p>The <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the
    <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching algorithm</a> on the <a href="webappapis.html#networking-task-source">networking task source</a> to
    process the data as it is being fetched must  <!--<span data-x="Content-Type
    sniffing">-->determine the  <!--sniffed-->  type of the resource<!--</span>--> If the
    <!--sniffed-->  type of the resource is not a supported text track format, the load will fail, as
    described below. Otherwise, the resource's data must be passed to the appropriate parser (e.g.
    the <a href="infrastructure.html#webvtt-parser">WebVTT parser</a><!-- if the file starts with the "<code data-x="">WEBVTT</code>"
    signature-->) as it is received, with the <a href="#text-track-list-of-cues">text track list of cues</a> being used for
    that parser's output. <a href="references.html#refsWEBVTT">[WEBVTT]</a></p><!-- see also critical block below,
    and the word "sniffed" in the paragraph after that -->

    <p class="note">The appropriate parser will synchronously (during these <a href="webappapis.html#networking-task-source">networking task
    source</a> <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a>) and incrementally (as each such task is
    run with whatever data has been received from the network) update the <a href="#text-track-list-of-cues">text track list of
    cues</a>.</p>

    <p class="critical">This specification does not currently say whether or how to check the MIME
    types of text tracks, or whether or how to perform file type sniffing using the actual file
    data. Implementors differ in their intentions on this matter and it is therefore unclear what
    the right solution is. In the absence of any requirement here, the HTTP specification's strict
    requirement to follow the Content-Type header prevails ("Content-Type specifies the media type
    of the underlying data." ... "If and only if the media type is not given by a Content-Type
    field, the recipient MAY attempt to guess the media type via inspection of its content
    and<!---->./<!---->or the name extension(s) of the URI used to identify the resource.").</p>

    <p>If the <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching algorithm</a> fails for any reason (network error,
    the server returns an error code, a cross-origin check fails, etc), or if <var data-anolis-xref="">URL</var> is the empty string, then <a href="webappapis.html#queue-a-task">queue a task</a> to first change the
    <a href="#text-track-readiness-state">text track readiness state</a> to <a data-anolis-xref="text track failed to load" href="#text-track-failed-to-load">failed to
    load</a> and then <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <code><a href="#the-track-element">track</a></code> element. This <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> must use the <a href="webappapis.html#dom-manipulation-task-source">DOM manipulation task source</a>.  <!--
    can't be the media element one, since there might not be a media element by this point --></p>

    <p>If the <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching algorithm</a> does not fail, but the  <!--sniffed-->
    
    type of the resource is not a supported text track format, or the file was not successfully
    processed (e.g. the format in question is an XML format and the file contained a well-formedness
    error that the XML specification requires be detected and reported to the application), then the
    <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the
    <a href="webappapis.html#networking-task-source">networking task source</a> in which the aforementioned problem is found must change the
    <a href="#text-track-readiness-state">text track readiness state</a> to <a data-anolis-xref="text track failed to load" href="#text-track-failed-to-load">failed to
    load</a> and <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code>
    at the <code><a href="#the-track-element">track</a></code> element.</p>

    <p>If the <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching algorithm</a> does not fail, and the file was
    successfully processed, then the final <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> that is <a data-anolis-xref="queue a task" href="webappapis.html#queue-a-task">queued</a> by the <a href="webappapis.html#networking-task-source">networking task source</a>, after it has
    finished parsing the data, must change the <a href="#text-track-readiness-state">text track readiness state</a> to <a data-anolis-xref="text track loaded" href="#text-track-loaded">loaded</a>, and <a href="webappapis.html#fire-a-simple-event">fire a simple event</a> named <code data-anolis-xref="event-load"><a href="index.html#event-load">load</a></code> at the <code><a href="#the-track-element">track</a></code> element.</p>

    <p>If, while the <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching algorithm</a> is active, either:</p>

    <ul><li>the <a href="#track-url">track URL</a> changes so that it is no longer equal to <var data-anolis-xref="">URL</var>, while the <a href="#text-track-mode">text track mode</a> is set to <a data-anolis-xref="text track
     hidden" href="#text-track-hidden">hidden</a> or <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a>; or</li>

     <li>the <a href="#text-track-mode">text track mode</a> changes to <a data-anolis-xref="text track hidden" href="#text-track-hidden">hidden</a>
     or <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a>, while the <a href="#track-url">track URL</a> is not
     equal to <var data-anolis-xref="">URL</var></li>

    </ul><p>...then the user agent must abort the <a data-anolis-xref="fetch" href="infrastructure.html#fetch">fetching algorithm</a>,
    discarding any pending <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">tasks</a> generated by that algorithm (and
    in particular, not adding any cues to the <a href="#text-track-list-of-cues">text track list of cues</a> after the moment
    the URL changed), and then <a href="webappapis.html#queue-a-task">queue a task</a> that first changes the <a href="#text-track-readiness-state">text track
    readiness state</a> to <a data-anolis-xref="text track failed to load" href="#text-track-failed-to-load">failed to load</a> and
    then <a data-anolis-xref="fire a simple event" href="webappapis.html#fire-a-simple-event">fires a simple event</a> named <code data-anolis-xref="event-error"><a href="index.html#event-error">error</a></code> at the <code><a href="#the-track-element">track</a></code> element. This <a data-anolis-xref="concept-task" href="webappapis.html#concept-task">task</a> must use the <a href="webappapis.html#dom-manipulation-task-source">DOM manipulation task source</a>.  <!--
    can't be the media element one, since there might not be a media element by this point --></p>

   </li>

   <li><p>Wait until the <a href="#text-track-readiness-state">text track readiness state</a> is no longer set to <a data-anolis-xref="text track loading" href="#text-track-loading">loading</a>.</li>

   <li><p>Wait until the <a href="#track-url">track URL</a> is no longer equal to <var data-anolis-xref="">URL</var>, at
   the same time as the <a href="#text-track-mode">text track mode</a> is set to <a data-anolis-xref="text track
   hidden" href="#text-track-hidden">hidden</a> or <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a>.</li>

   <li><p>Jump to the step labeled <i>top</i>.</li>

  </ol><p>Whenever a <code><a href="#the-track-element">track</a></code> element has its <code data-anolis-xref="attr-track-src"><a href="#attr-track-src">src</a></code> attribute
  set, changed, or removed, the user agent must synchronously empty the element's <a href="#text-track">text
  track</a>'s <a href="#text-track-list-of-cues">text track list of cues</a>. (This also causes the algorithm above to stop
  adding cues from the resource being obtained using the previously given URL, if any.)</p>

  </div>


  <div class="impl">

  <h6 id="guidelines-for-exposing-cues-in-various-formats-as-text-track-cues"><span class="secno">4.7.14.12.4 </span><dfn>Guidelines for exposing cues</dfn> in various formats as <a data-anolis-xref="text track
  cue" href="#text-track-cue">text track cues</a></h6>

  <p>How a specific format's text track cues are to be interpreted for the purposes of processing by
  an HTML user agent is defined by that format <a href="references.html#refsINBANDTRACKS">[INBANDTRACKS]</a>. In the
  absence of such a specification, this section provides some constraints within which implementations can
  attempt to consistently expose such formats.</p>

  <p>To support the <a href="#text-track">text track</a> model of HTML, each unit of timed data is converted to a
  <a href="#text-track-cue">text track cue</a>. Where the mapping of the format's features to the aspects of a
  <a href="#text-track-cue">text track cue</a> as defined in this specification are not defined, implementations must
  ensure that the mapping is consistent with the definitions of the aspects of a <a href="#text-track-cue">text track
  cue</a> as defined above, as well as with the following constraints:</p>

  <dl><dt>The <a href="#text-track-cue-identifier">text track cue identifier</a>
   <dd>
    <p>Should be set to the empty string if the format has no obvious analogue to a per-cue
    identifier.</p>
   </dd>

   <dt>The <a href="#text-track-cue-pause-on-exit-flag">text track cue pause-on-exit flag</a>
   <dd>
    <p>Should be set to false.</p>
   </dd>

  </dl><p>For <a data-anolis-xref="media-resource-specific text track" href="#media-resource-specific-text-track">media-resource-specific text tracks</a>
   of <a data-anolis-xref="text track kind" href="#text-track-kind">kind</a> <code data-anolis-xref="dom-TextTrack-kind-metadata"><a href="#dom-texttrack-kind-metadata">metadata</a></code>,
   <a data-anolis-xref="text track cue" href="#text-track-cue">text track cues</a> are exposed using the <code><a href="#datacue">DataCue</a></code> object
   unless there is a more appropriate <code><a href="#texttrackcue">TextTrackCue</a></code> interface available.
   For example, if the <a href="#media-resource-specific-text-track">media-resource-specific text track</a> format is <a href="infrastructure.html#webvtt">WebVTT</a>,
   then <code>VTTCue</code> is more appropriate.</p>
     
  </div>


  <h6 id="text-track-api"><span class="secno">4.7.14.12.5</span> テキストトラックAPI</h6>

  <pre class="idl">interface <dfn id="texttracklist">TextTrackList</dfn> : <a href="infrastructure.html#eventtarget">EventTarget</a> {
  readonly attribute unsigned long <a data-anolis-xref="dom-TextTrackList-length" href="#dom-texttracklist-length">length</a>;
  getter <a href="#texttrack">TextTrack</a> (unsigned long index);
  <a href="#texttrack">TextTrack</a>? <a data-anolis-xref="dom-TextTrackList-getTrackById" href="#dom-texttracklist-gettrackbyid">getTrackById</a>(DOMString id);

           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TextTrackList-onchange" href="#handler-texttracklist-onchange">onchange</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TextTrackList-onaddtrack" href="#handler-texttracklist-onaddtrack">onaddtrack</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TextTrackList-onremovetrack" href="#handler-texttracklist-onremovetrack">onremovetrack</a>;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks</a></code> . <code data-anolis-xref="">length</code></dt>
   <dd>
    <p><a href="#media-element">メディア要素</a>（たとえば<code><a href="#the-track-element">track</a></code>要素から）に関連付けられた<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>の数を返す。これは、<a href="#media-element">メディア要素</a>の<a href="#list-of-text-tracks">テキストトラックのリスト</a>で<a data-anolis-xref="text track" href="#text-track">テキストトラック</a>の数である。</p>
   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks[</a></code> <var data-anolis-xref="">n</var> <code data-anolis-xref="">]</code></dt>
   <dd>
    <p><a href="#media-element">メディア要素</a>の<a href="#list-of-text-tracks">テキストトラックのリスト</a>で<var data-anolis-xref="">n</var>番目の<a href="#text-track">テキストトラック</a>を表す<code><a href="#texttrack">TextTrack</a></code>オブジェクトを返す。</p>
   </dd>

   <dt><var data-anolis-xref="">textTrack</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks</a></code> . <code data-anolis-xref="dom-TextTrackList-getTrackById"><a href="#dom-texttracklist-gettrackbyid">getTrackById</a></code>( <var data-anolis-xref="">id</var> )</dt>

   <dd>

    <p>与えられた識別子とともに<code><a href="#texttrack">TextTrack</a></code>オブジェクトを返す、または一切トラックがその識別子を持たない場合nullを返す。</p>

   </dd>

   <dt><var data-anolis-xref="">track</var> . <code data-anolis-xref="dom-track-track"><a href="#dom-track-track">track</a></code></dt>
   <dd>
    <p><code><a href="#the-track-element">track</a></code>要素の<a href="#text-track">テキストトラック</a>を表す<code><a href="#texttrack">TextTrack</a></code>オブジェクトを返す。</p>
   </dd>

  </dl><div class="impl">

  <p>A <code><a href="#texttracklist">TextTrackList</a></code> object represents a dynamically updating list of <a data-anolis-xref="text
  track" href="#text-track">text tracks</a> in a given order.</p>

  <p>The <dfn data-anolis-xref="dom-media-textTracks" id="dom-media-texttracks"><code>textTracks</code></dfn> attribute of <a data-anolis-xref="media element" href="#media-element">media elements</a> must return a <code><a href="#texttracklist">TextTrackList</a></code> object
  representing the <code><a href="#texttrack">TextTrack</a></code> objects of the <a data-anolis-xref="text track" href="#text-track">text tracks</a>
  in the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>, in the same order as in the
  <a href="#list-of-text-tracks">list of text tracks</a>. The same object must be returned each time the attribute is
  accessed. <a href="references.html#refsWEBIDL">[WEBIDL]</a></p>

  <p>The <dfn data-anolis-xref="dom-TextTrackList-length" id="dom-texttracklist-length"><code>length</code></dfn> attribute of a
  <code><a href="#texttracklist">TextTrackList</a></code> object must return the number of <a data-anolis-xref="text track" href="#text-track">text
  tracks</a> in the list represented by the <code><a href="#texttracklist">TextTrackList</a></code> object.</p>

  <p>The <a href="infrastructure.html#supported-property-indices">supported property indices</a> of a <code><a href="#texttracklist">TextTrackList</a></code> object at any
  instant are the numbers from zero to the number of <a data-anolis-xref="text track" href="#text-track">text tracks</a> in
  the list represented by the <code><a href="#texttracklist">TextTrackList</a></code> object minus one, if any. If there are no
  <a data-anolis-xref="text track" href="#text-track">text tracks</a> in the list, there are no <a href="infrastructure.html#supported-property-indices">supported property
  indices</a>.</p>

  <p>To <a href="infrastructure.html#determine-the-value-of-an-indexed-property">determine the value of an indexed property</a> of a <code><a href="#texttracklist">TextTrackList</a></code>
  object for a given index <var data-anolis-xref="">index</var>, the user agent must return the <var data-anolis-xref="">index</var>th <a href="#text-track">text track</a> in the list represented by the
  <code><a href="#texttracklist">TextTrackList</a></code> object.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrackList-getTrackById" id="dom-texttracklist-gettrackbyid"><code>getTrackById(<var data-anolis-xref="">id</var>)</code></dfn> method must return the first <code><a href="#texttrack">TextTrack</a></code> in the
  <code><a href="#texttracklist">TextTrackList</a></code> object whose <code data-anolis-xref="dom-TextTrack-id"><a href="#dom-texttrack-id">id</a></code> IDL attribute
  would return a value equal to the value of the <var data-anolis-xref="">id</var> argument. When no tracks
  match the given argument, the method must return null.</p>

  </div>

  <hr><pre class="idl">enum <dfn id="texttrackmode">TextTrackMode</dfn> {<!--
   --> "<a data-anolis-xref="dom-TextTrack-disabled" href="#dom-texttrack-disabled">disabled</a>", <!--
   --> "<a data-anolis-xref="dom-TextTrack-hidden" href="#dom-texttrack-hidden">hidden</a>", <!--
   --> "<a data-anolis-xref="dom-TextTrack-showing" href="#dom-texttrack-showing">showing</a>" };
enum <dfn id="texttrackkind">TextTrackKind</dfn> {<!--
   --> "<a data-anolis-xref="dom-TextTrack-kind-subtitles" href="#dom-texttrack-kind-subtitles">subtitles</a>", <!--
   --> "<a data-anolis-xref="dom-TextTrack-kind-captions" href="#dom-texttrack-kind-captions">captions</a>", <!--
   --> "<a data-anolis-xref="dom-TextTrack-kind-descriptions" href="#dom-texttrack-kind-descriptions">descriptions</a>", <!--
   --> "<a data-anolis-xref="dom-TextTrack-kind-chapters" href="#dom-texttrack-kind-chapters">chapters</a>", <!--
   --> "<a data-anolis-xref="dom-TextTrack-kind-metadata" href="#dom-texttrack-kind-metadata">metadata</a>" };
interface <dfn id="texttrack">TextTrack</dfn> : <a href="infrastructure.html#eventtarget">EventTarget</a> {
  readonly attribute <a href="#texttrackkind">TextTrackKind</a> <a data-anolis-xref="dom-TextTrack-kind" href="#dom-texttrack-kind">kind</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-TextTrack-label" href="#dom-texttrack-label">label</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-TextTrack-language" href="#dom-texttrack-language">language</a>;

  readonly attribute DOMString <a data-anolis-xref="dom-TextTrack-id" href="#dom-texttrack-id">id</a>;
  readonly attribute DOMString <a data-anolis-xref="dom-TextTrack-inBandMetadataTrackDispatchType" href="#dom-texttrack-inbandmetadatatrackdispatchtype">inBandMetadataTrackDispatchType</a>;

           attribute <a href="#texttrackmode">TextTrackMode</a> <a data-anolis-xref="dom-TextTrack-mode" href="#dom-texttrack-mode">mode</a>;

  readonly attribute <a href="#texttrackcuelist">TextTrackCueList</a>? <a data-anolis-xref="dom-TextTrack-cues" href="#dom-texttrack-cues">cues</a>;
  readonly attribute <a href="#texttrackcuelist">TextTrackCueList</a>? <a data-anolis-xref="dom-TextTrack-activeCues" href="#dom-texttrack-activecues">activeCues</a>;

  void <a data-anolis-xref="dom-TextTrack-addCue" href="#dom-texttrack-addcue">addCue</a>(<a href="#texttrackcue">TextTrackCue</a> cue);
  void <a data-anolis-xref="dom-TextTrack-removeCue" href="#dom-texttrack-removecue">removeCue</a>(<a href="#texttrackcue">TextTrackCue</a> cue);

           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TextTrack-oncuechange" href="#handler-texttrack-oncuechange">oncuechange</a>;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">textTrack</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-addTextTrack"><a href="#dom-media-addtexttrack">addTextTrack</a></code>( <var data-anolis-xref="">kind</var> [, <var data-anolis-xref="">label</var> [, <var data-anolis-xref="">language</var> ] ] )</dt>
   <dd>

    <p><a href="#media-element">メディア要素</a>の<a href="#list-of-text-tracks">テキストトラックのリスト</a>に追加された新しい<code><a href="#texttrack">TextTrack</a></code>オブジェクトを作成して返す。</p>

   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-kind"><a href="#dom-texttrack-kind">kind</a></code></dt>
   <dd>

    <p><a href="#text-track-kind">テキストトラックの種類</a>の文字列を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-label"><a href="#dom-texttrack-label">label</a></code></dt>
   <dd>

    <p>存在する、または空の文字列（オブジェクトがユーザーに公開される場合、オブジェクトの他の属性からおそらく生成する必要があるカスタムラベルを示す）がある場合、<a href="#text-track-label">テキストトラックのラベル</a>を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-language"><a href="#dom-texttrack-language">language</a></code></dt>
   <dd>
    <p><a href="#text-track-language">テキストトラックの言語</a>の文字列を返す。</p>
   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-id"><a href="#dom-texttrack-id">id</a></code></dt>
   <dd>

    <p>指定されたトラックのIDを返す。</p>

    <p>帯域内トラックに対して、フォーマットが<cite>Media Fragments URI</cite>構文をサポートし、<code data-anolis-xref="dom-TextTrackList-getTrackById"><a href="#dom-texttracklist-gettrackbyid">getTrackById()</a></code>メソッドとともに使用できる場合、これは、フラグメント識別子で使用できるIDである。<a href="references.html#refsMEDIAFRAG">[MEDIAFRAG]</a></p>

    <p><code><a href="#the-track-element">track</a></code>要素に対応する<code><a href="#texttrack">TextTrack</a></code>オブジェクトに対して、これは<code><a href="#the-track-element">track</a></code>要素のIDである。</p>

   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-inBandMetadataTrackDispatchType"><a href="#dom-texttrack-inbandmetadatatrackdispatchtype">inBandMetadataTrackDispatchType</a></code></dt>
   <dd>

    <p><a href="#text-track-in-band-metadata-track-dispatch-type">テキストトラック帯域内のメタデータトラックディスパッチタイプ</a>の文字列を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-mode"><a href="#dom-texttrack-mode">mode</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dd>

    <p>以下のリストから文字列によって表される、<a href="#text-track-mode">テキストトラックモード</a>を返す：</p>

    <dl><dt>"<code data-anolis-xref="dom-TextTrack-disabled"><a href="#dom-texttrack-disabled">disabled</a></code>"</dt>
     <dd>
      <p><a href="#text-track-disabled">テキストトラック無効</a>モード。</p>
     </dd>
     <dt>"<code data-anolis-xref="dom-TextTrack-hidden"><a href="#dom-texttrack-hidden">hidden</a></code>"</dt>
     <dd>
      <p><a href="#text-track-hidden">テキストトラック非表示</a>モード。</p>
     </dd>
     <dt>"<code data-anolis-xref="dom-TextTrack-showing"><a href="#dom-texttrack-showing">showing</a></code>"</dt>
     <dd>
      <p><a href="#text-track-showing">テキストトラック表示</a>モード。</p>
     </dd>
    </dl><p>モードを変更する設定が可能である。</p>

   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-cues"><a href="#dom-texttrack-cues">cues</a></code></dt>
   <dd>
    <p><code><a href="#texttrackcuelist">TextTrackCueList</a></code>オブジェクトとして、<a href="#text-track-list-of-cues">キューのテキストトラックリスト</a>を返す。</p>
   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-activeCues"><a href="#dom-texttrack-activecues">activeCues</a></code></dt>
   <dd>

    <p><code><a href="#texttrackcuelist">TextTrackCueList</a></code>オブジェクトとして、現在アクティブである<a href="#text-track-list-of-cues">キューのテキストトラックリスト</a>から、<a data-anolis-xref="text track cue" href="#text-track-cue">テキストトラックキュー</a>を返す（つまり、<a href="#current-playback-position">現在の再生位置</a>の前に開始し、その後で終了する）。</p>

   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-addCue"><a href="#dom-texttrack-addcue">addCue</a></code>( <var data-anolis-xref="">cue</var> )</dt>
   <dd>
    <p><var data-anolis-xref="">textTrack</var>の<a href="#text-track-list-of-cues">キューのテキストトラックリスト</a>に指定されたキューを追加する。</p>
   </dd>

   <dt><var data-anolis-xref="">textTrack</var> . <code data-anolis-xref="dom-TextTrack-removeCue"><a href="#dom-texttrack-removecue">removeCue</a></code>( <var data-anolis-xref="">cue</var> )</dt>
   <dd>
    <p><var data-anolis-xref="">textTrack</var>の<a href="#text-track-list-of-cues">キューのテキストトラックリスト</a>から指定されたキューを削除する。</p>
   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-addTextTrack" id="dom-media-addtexttrack"><code>addTextTrack(<var data-anolis-xref="">kind</var>, <var data-anolis-xref="">label</var>, <var data-anolis-xref="">language</var>)</code></dfn> method of <a data-anolis-xref="media
  element" href="#media-element">media elements</a>, when invoked, must run the following steps:</p>

  <ol><li>

    <p>Create a new <code><a href="#texttrack">TextTrack</a></code> object.</p>

   </li>

   <li>

    <p>Create a new <a href="#text-track">text track</a> corresponding to the new object, and set its <a href="#text-track-kind">text
    track kind</a> to <var data-anolis-xref="">kind</var>, its <a href="#text-track-label">text track label</a> to <var data-anolis-xref="">label</var>, its <a href="#text-track-language">text track language</a> to <var data-anolis-xref="">language</var>, its
    <a href="#text-track-readiness-state">text track readiness state</a> to the <a href="#text-track-loaded">text track loaded</a> state, its
    <a href="#text-track-mode">text track mode</a> to the <a href="#text-track-hidden">text track hidden</a> mode, and its <a href="#text-track-list-of-cues">text
    track list of cues</a> to an empty list.</p>

    <p>Initially, the <a href="#text-track-list-of-cues">text track list of cues</a> is not associated with any <a href="#rules-for-updating-the-text-track-rendering">rules
    for updating the text track rendering</a>. When a <a href="#text-track-cue">text track cue</a> is added to it,
    the <a href="#text-track-list-of-cues">text track list of cues</a> has its rules permanently set accordingly.</p>

   </li>

   <li>

    <p>Add the new <a href="#text-track">text track</a> to the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text
    tracks</a>.</p>

   </li>

   <li>

    <p><a href="webappapis.html#queue-a-task">Queue a task</a> to <a data-anolis-xref="concept-event-fire" href="infrastructure.html#concept-event-fire">fire</a> a <a data-anolis-xref="concept-events-trusted" href="infrastructure.html#concept-events-trusted">trusted</a> event with the name <code data-anolis-xref="event-media-addtrack"><a href="#event-media-addtrack">addtrack</a></code>, that does not bubble and is not cancelable, and
    that uses the <code><a href="#trackevent">TrackEvent</a></code> interface, with the <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code> attribute initialised to the new <a href="#text-track">text
    track</a>'s <code><a href="#texttrack">TextTrack</a></code> object, at the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-textTracks"><a href="#dom-media-texttracks">textTracks</a></code> attribute's <code><a href="#texttracklist">TextTrackList</a></code>
    object.</p>

   </li>

   <li>

    <p>Return the new <code><a href="#texttrack">TextTrack</a></code> object.</p>

   </li>

  </ol><hr><p>The <dfn data-anolis-xref="dom-TextTrack-kind" id="dom-texttrack-kind"><code>kind</code></dfn> attribute must return the
  <a href="#text-track-kind">text track kind</a> of the <a href="#text-track">text track</a> that the <code><a href="#texttrack">TextTrack</a></code> object
  represents.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrack-label" id="dom-texttrack-label"><code>label</code></dfn> attribute must return the
  <a href="#text-track-label">text track label</a> of the <a href="#text-track">text track</a> that the <code><a href="#texttrack">TextTrack</a></code>
  object represents.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrack-language" id="dom-texttrack-language"><code>language</code></dfn> attribute must return the
  <a href="#text-track-language">text track language</a> of the <a href="#text-track">text track</a> that the <code><a href="#texttrack">TextTrack</a></code>
  object represents.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrack-id" id="dom-texttrack-id"><code>id</code></dfn> attribute returns the track's
  identifier, if it has one, or the empty string otherwise. For tracks that correspond to
  <code><a href="#the-track-element">track</a></code> elements, the track's identifier is the value of the element's <code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code> attribute, if any. For in-band tracks, the track's identifier is
  specified by the <a href="#media-resource">media resource</a>. If the <a href="#media-resource">media resource</a> is in a format
  that supports the <cite>Media Fragments URI</cite> fragment identifier syntax, the identifier
  returned for a particular track must be the same identifier that would enable the track if used as
  the name of a track in the track dimension of such a fragment identifier. <a href="references.html#refsMEDIAFRAG">[MEDIAFRAG]</a></p>

  <p>The <dfn data-anolis-xref="dom-TextTrack-inBandMetadataTrackDispatchType" id="dom-texttrack-inbandmetadatatrackdispatchtype"><code>inBandMetadataTrackDispatchType</code></dfn>
  attribute must return the <a href="#text-track-in-band-metadata-track-dispatch-type">text track in-band metadata track dispatch type</a> of the
  <a href="#text-track">text track</a> that the <code><a href="#texttrack">TextTrack</a></code> object represents.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrack-mode" id="dom-texttrack-mode"><code>mode</code></dfn> attribute, on getting, must return
  the string corresponding to the <a href="#text-track-mode">text track mode</a> of the <a href="#text-track">text track</a> that
  the <code><a href="#texttrack">TextTrack</a></code> object represents, as defined by the following list:</p>

  <dl><dt>"<dfn data-anolis-xref="dom-TextTrack-disabled" id="dom-texttrack-disabled"><code>disabled</code></dfn>"</dt>
   <dd><a href="#text-track-disabled">テキストトラック無効</a>モード。</dd>
   <dt>"<dfn data-anolis-xref="dom-TextTrack-hidden" id="dom-texttrack-hidden"><code>hidden</code></dfn>"</dt>
   <dd><a href="#text-track-hidden">テキストトラック非表示</a>モード。</dd>
   <dt>"<dfn data-anolis-xref="dom-TextTrack-showing" id="dom-texttrack-showing"><code>showing</code></dfn>"</dt>
   <dd><a href="#text-track-showing">テキストトラック表示</a>モード。</dd>
  </dl><p>On setting, if the new value isn't equal to what the attribute would currently return, the new
  value must be processed as follows:</p>

  <dl class="switch"><dt>If the new value is "<code data-anolis-xref="dom-TextTrack-disabled"><a href="#dom-texttrack-disabled">disabled</a></code>"</dt>

   <dd>

    <p>Set the <a href="#text-track-mode">text track mode</a> of the <a href="#text-track">text track</a> that the
    <code><a href="#texttrack">TextTrack</a></code> object represents to the <a href="#text-track-disabled">text track disabled</a> mode.</p>

   </dd>

   <dt>If the new value is "<code data-anolis-xref="dom-TextTrack-hidden"><a href="#dom-texttrack-hidden">hidden</a></code>"</dt>

   <dd>

    <p>Set the <a href="#text-track-mode">text track mode</a> of the <a href="#text-track">text track</a> that the
    <code><a href="#texttrack">TextTrack</a></code> object represents to the <a href="#text-track-hidden">text track hidden</a> mode.</p>

   </dd>

   <dt>If the new value is "<code data-anolis-xref="dom-TextTrack-showing"><a href="#dom-texttrack-showing">showing</a></code>"</dt>

   <dd>

    <p>Set the <a href="#text-track-mode">text track mode</a> of the <a href="#text-track">text track</a> that the
    <code><a href="#texttrack">TextTrack</a></code> object represents to the <a href="#text-track-showing">text track showing</a> mode.</p>

   </dd>

  </dl><p>If the <a href="#text-track-mode">text track mode</a> of the <a href="#text-track">text track</a> that the
  <code><a href="#texttrack">TextTrack</a></code> object represents is not the <a href="#text-track-disabled">text track disabled</a> mode, then
  the <dfn data-anolis-xref="dom-TextTrack-cues" id="dom-texttrack-cues"><code>cues</code></dfn> attribute must return a
  <a href="infrastructure.html#live">live</a> <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object that represents the subset of the
  <a href="#text-track-list-of-cues">text track list of cues</a> of the <a href="#text-track">text track</a> that the
  <code><a href="#texttrack">TextTrack</a></code> object represents whose <a data-anolis-xref="text track cue end time" href="#text-track-cue-end-time">end
  times</a> occur at or after the <a href="#earliest-possible-position-when-the-script-started">earliest possible position when the script
  started</a>, in <a href="#text-track-cue-order">text track cue order</a>. Otherwise, it must return null. When an
  object is returned, the same object must be returned each time.</p>

  <p>The <dfn id="earliest-possible-position-when-the-script-started">earliest possible position when the script started</dfn> is whatever the
  <a href="#earliest-possible-position">earliest possible position</a> was the last time the <a href="webappapis.html#event-loop">event loop</a> reached step
  1.</p>

  <p>If the <a href="#text-track-mode">text track mode</a> of the <a href="#text-track">text track</a> that the
  <code><a href="#texttrack">TextTrack</a></code> object represents is not the <a href="#text-track-disabled">text track disabled</a> mode, then
  the <dfn data-anolis-xref="dom-TextTrack-activeCues" id="dom-texttrack-activecues"><code>activeCues</code></dfn> attribute must return a
  <a href="infrastructure.html#live">live</a> <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object that represents the subset of the
  <a href="#text-track-list-of-cues">text track list of cues</a> of the <a href="#text-track">text track</a> that the
  <code><a href="#texttrack">TextTrack</a></code> object represents whose <a href="#active-flag-was-set-when-the-script-started">active flag was set when the script
  started</a>, in <a href="#text-track-cue-order">text track cue order</a>. Otherwise, it must return null. When an
  object is returned, the same object must be returned each time.</p>

  <p>A <a href="#text-track-cue">text track cue</a>'s <dfn id="active-flag-was-set-when-the-script-started">active flag was set when the script started</dfn> if its
  <a href="#text-track-cue-active-flag">text track cue active flag</a> was set the last time the <a href="webappapis.html#event-loop">event loop</a> reached
  step 1.</p>

  <hr><p>The <dfn data-anolis-xref="dom-TextTrack-addCue" id="dom-texttrack-addcue"><code>addCue(<var data-anolis-xref="">cue</var>)</code></dfn> method
  of <code><a href="#texttrack">TextTrack</a></code> objects, when invoked, must run the following steps:</p>

  <ol><li><p>If the <a href="#text-track-list-of-cues">text track list of cues</a> does not yet have any associated <a href="#rules-for-updating-the-text-track-rendering">rules
   for updating the text track rendering</a>, then associate the <a href="#text-track-list-of-cues">text track list of
   cues</a> with the <a href="#rules-for-updating-the-text-track-rendering">rules for updating the text track rendering</a> appropriate to <var data-anolis-xref="">cue</var>.</p>

   </li><li><p>If <a href="#text-track-list-of-cues">text track list of cues</a>' associated <a href="#rules-for-updating-the-text-track-rendering">rules for updating the text
   track rendering</a> are not the same <a href="#rules-for-updating-the-text-track-rendering">rules for updating the text track rendering</a>
   as appropriate for <var data-anolis-xref="">cue</var>, then throw an <code><a href="infrastructure.html#invalidstateerror">InvalidStateError</a></code>
   exception and abort these steps.</p>

   </li><li><p>If the given <var data-anolis-xref="">cue</var> is in a <a href="#text-track-list-of-cues">text track list of cues</a>, then
   remove <var data-anolis-xref="">cue</var> from that <a href="#text-track-list-of-cues">text track list of cues</a>.</li>

   <li><p>Add <var data-anolis-xref="">cue</var> to the method's <code><a href="#texttrack">TextTrack</a></code> object's <a href="#text-track">text
   track</a>'s <a href="#text-track-list-of-cues">text track list of cues</a>.</li>

  </ol><p>The <dfn data-anolis-xref="dom-TextTrack-removeCue" id="dom-texttrack-removecue"><code>removeCue(<var data-anolis-xref="">cue</var>)</code></dfn>
  method of <code><a href="#texttrack">TextTrack</a></code> objects, when invoked, must run the following steps:</p>

  <ol><li><p>If the given <var data-anolis-xref="">cue</var> is not currently listed in the method's
   <code><a href="#texttrack">TextTrack</a></code> object's <a href="#text-track">text track</a>'s <a href="#text-track-list-of-cues">text track list of cues</a>,
   then throw a <code><a href="infrastructure.html#notfounderror">NotFoundError</a></code> exception and abort these steps.</li>

   <li><p>Remove <var data-anolis-xref="">cue</var> from the method's <code><a href="#texttrack">TextTrack</a></code> object's
   <a href="#text-track">text track</a>'s <a href="#text-track-list-of-cues">text track list of cues</a>.</li>

  </ol></div>

  <div class="example">

   <p>この例において、<code><a href="#the-audio-element">audio</a></code>要素は、多数のサウンドエフェクトを含むサウンドファイルから特定のサウンドエフェクトを再生するために使用される。キューは、たとえブラウザが一部のスクリプトを実行してビジーであっても、オーディオがクリップの最後で正確に終了するよう、オーディオを一時停止するために使用される。ページがオーディオを一時停止するスクリプトに依存し、ブラウザは指定された正確な時間にスクリプトを実行することができなかった場合、次のクリップの出だしを聞いているかもしれない。</p>

   <pre>var sfx = new Audio('sfx.wav');
var sounds = sfx.addTextTrack('metadata');

// add sounds we care about
function addFX(start, end, name) {
  var cue = new VTTCue(start, end, '');
  cue.id = name;
  cue.pauseOnExit = true;
  sounds.addCue(cue);
}
addFX(12.783, 13.612, 'dog bark');
addFX(13.612, 15.091, 'kitten mew'))

function playSound(id) {
  sfx.currentTime = sounds.getCueById(id).startTime;
  sfx.play();
}

// play a bark as soon as we can
sfx.oncanplaythrough = function () {
  playSound('dog bark');
}
// meow when the user tries to leave
window.onbeforeunload = function () {
  playSound('kitten mew');
  return 'Are you sure you want to leave this awesome page?';
}</pre>

  </div>

  <hr><pre class="idl">interface <dfn id="texttrackcuelist">TextTrackCueList</dfn> {
  readonly attribute unsigned long <a data-anolis-xref="dom-TextTrackCueList-length" href="#dom-texttrackcuelist-length">length</a>;
  getter <a href="#texttrackcue">TextTrackCue</a> (unsigned long index);
  <a href="#texttrackcue">TextTrackCue</a>? <a data-anolis-xref="dom-TextTrackCueList-getCueById" href="#dom-texttrackcuelist-getcuebyid">getCueById</a>(DOMString id);
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">cuelist</var> . <code data-anolis-xref="dom-TextTrackCueList-length"><a href="#dom-texttrackcuelist-length">length</a></code></dt>
   <dd>
    <p>リスト内の<a data-anolis-xref="text track cue" href="#text-track-cue">キュー</a>の数を返す。</p>
   </dd>

   <dt><var data-anolis-xref="">cuelist</var>[<var data-anolis-xref="">index</var>]</dt>
   <dd>
    <p>リスト内のインデックス<var data-anolis-xref="">index</var>を持つ<a href="#text-track-cue">テキストトラックキュー</a>を返す。キューは、<a href="#text-track-cue-order">テキストトラックキュー順</a>にソートされる。</p>
   </dd>

   <dt><var data-anolis-xref="">cuelist</var> . <code data-anolis-xref="dom-TextTrackCueList-getCueById"><a href="#dom-texttrackcuelist-getcuebyid">getCueById</a></code>( <var data-anolis-xref="">id</var> )</dt>
   <dd>
    <p><a href="#text-track-cue-identifier">テキストトラックキュー識別子</a><var data-anolis-xref="">id</var>を持つ（<a href="#text-track-cue-order">テキストトラックキュー順</a>で）最初の<a href="#text-track-cue">テキストトラックキュー</a>を返す。</p>
    <p>いずれのキューも指定された識別子を持たない場合、または引数が空の文字列である場合、nullを返す。</p>
   </dd>

  </dl><div class="impl">

  <p>A <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object represents a dynamically updating list of <a data-anolis-xref="text track cue" href="#text-track-cue">text track cues</a> in a given order.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrackCueList-length" id="dom-texttrackcuelist-length"><code>length</code></dfn> attribute must return
  the number of <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in the list represented by the
  <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object.</p>

  <p>The <a href="infrastructure.html#supported-property-indices">supported property indices</a> of a <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object at any
  instant are the numbers from zero to the number of <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in the
  list represented by the <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object minus one, if any. If there are no
  <a data-anolis-xref="text track cue" href="#text-track-cue">cues</a> in the list, there are no <a href="infrastructure.html#supported-property-indices">supported property
  indices</a>.</p>

  <p>To <a href="infrastructure.html#determine-the-value-of-an-indexed-property">determine the value of an indexed property</a> for a given index <var data-anolis-xref="">index</var>, the user agent must return the <var data-anolis-xref="">index</var>th <a href="#text-track-cue">text track
  cue</a> in the list represented by the <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrackCueList-getCueById" id="dom-texttrackcuelist-getcuebyid"><code>getCueById(<var data-anolis-xref="">id</var>)</code></dfn> method, when called with an argument other than the empty string,
  must return the first <a href="#text-track-cue">text track cue</a> in the list represented by the
  <code><a href="#texttrackcuelist">TextTrackCueList</a></code> object whose <a href="#text-track-cue-identifier">text track cue identifier</a> is <var data-anolis-xref="">id</var>, if any, or null otherwise. If the argument is the empty string, then the method
  must return null.</p>

  </div>

  <hr><pre class="idl">interface <dfn id="texttrackcue">TextTrackCue</dfn> : <a href="infrastructure.html#eventtarget">EventTarget</a> {
  readonly attribute <a href="#texttrack">TextTrack</a>? <a data-anolis-xref="dom-TextTrackCue-track" href="#dom-texttrackcue-track">track</a>;

           attribute DOMString <a data-anolis-xref="dom-TextTrackCue-id" href="#dom-texttrackcue-id">id</a>;
           attribute double <a data-anolis-xref="dom-TextTrackCue-startTime" href="#dom-texttrackcue-starttime">startTime</a>;
           attribute double <a data-anolis-xref="dom-TextTrackCue-endTime" href="#dom-texttrackcue-endtime">endTime</a>;
           attribute boolean <a data-anolis-xref="dom-TextTrackCue-pauseOnExit" href="#dom-texttrackcue-pauseonexit">pauseOnExit</a>;

           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TextTrackCue-onenter" href="#handler-texttrackcue-onenter">onenter</a>;
           attribute <a href="webappapis.html#eventhandler">EventHandler</a> <a data-anolis-xref="handler-TextTrackCue-onexit" href="#handler-texttrackcue-onexit">onexit</a>;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">cue</var> . <a data-anolis-xref="dom-TextTrackCue-track" href="#dom-texttrackcue-track">track</a></dt>
   <dd>
    <p>存在する場合、この<a href="#text-track-cue">テキストトラックキュー</a>が属する<code><a href="#texttrack">TextTrack</a></code>オブジェクトを返し、そうでなければnullを返す。</p>
   </dd>

   <dt><var data-anolis-xref="">cue</var> . <a data-anolis-xref="dom-TextTrackCue-id" href="#dom-texttrackcue-id">id</a> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dd>
    <p><a href="#text-track-cue-identifier">テキストトラックキュー識別子</a>を返す。</p>
    <p>設定可能である。</p>
   </dd>

   <dt><var data-anolis-xref="">cue</var> . <a data-anolis-xref="dom-TextTrackCue-startTime" href="#dom-texttrackcue-starttime">startTime</a> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dd>
    <p>秒単位で、<a href="#text-track-cue-start-time">テキストトラックキューの開始時刻</a>を返す。</p>
    <p>設定可能である。</p>
   </dd>

   <dt><var data-anolis-xref="">cue</var> . <a data-anolis-xref="dom-TextTrackCue-endTime" href="#dom-texttrackcue-endtime">endTime</a> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dd>
    <p>秒単位で、<a href="#text-track-cue-end-time">テキストトラックキューの終了時刻</a>を返す。</p>
    <p>設定可能である。</p>
   </dd>

   <dt><var data-anolis-xref="">cue</var> . <a data-anolis-xref="dom-TextTrackCue-pauseOnExit" href="#dom-texttrackcue-pauseonexit">pauseOnExit</a> [ = <var data-anolis-xref="">value</var> ]</dt>
   <dd>
    <p><a href="#text-track-cue-pause-on-exit-flag">テキスト·トラック·キューpause-on-exitフラグ</a>が設定される場合trueを返し、そうでなければfalseを返す。</p>
    <p>設定可能である。</p>
   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-TextTrackCue-track" id="dom-texttrackcue-track"><code>track</code></dfn> attribute, on getting, must
  return the <code><a href="#texttrack">TextTrack</a></code> object of the <a href="#text-track">text track</a> in whose <a data-anolis-xref="text
  track list of cues" href="#text-track-list-of-cues">list of cues</a> the <a href="#text-track-cue">text track cue</a> that the
  <code><a href="#texttrackcue">TextTrackCue</a></code> object represents finds itself, if any; or null otherwise.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrackCue-id" id="dom-texttrackcue-id"><code>id</code></dfn> attribute, on getting, must return
  the <a href="#text-track-cue-identifier">text track cue identifier</a> of the <a href="#text-track-cue">text track cue</a> that the
  <code><a href="#texttrackcue">TextTrackCue</a></code> object represents. On setting, the <a href="#text-track-cue-identifier">text track cue
  identifier</a> must be set to the new value.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrackCue-startTime" id="dom-texttrackcue-starttime"><code>startTime</code></dfn> attribute, on getting,
  must return the <a href="#text-track-cue-start-time">text track cue start time</a> of the <a href="#text-track-cue">text track cue</a> that the
  <code><a href="#texttrackcue">TextTrackCue</a></code> object represents, in seconds. On setting, the <a href="#text-track-cue-start-time">text track cue
  start time</a> must be set to the new value, interpreted in seconds; then, if the
  <code><a href="#texttrackcue">TextTrackCue</a></code> object's <a href="#text-track-cue">text track cue</a> is in a <a href="#text-track">text track</a>'s
  <a data-anolis-xref="text track list of cues" href="#text-track-list-of-cues">list of cues</a>, and that <a href="#text-track">text track</a> is in
  a <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>, and the <a href="#media-element">media
  element</a>'s <a href="#show-poster-flag">show poster flag</a> is not set, then run the <i><a href="#time-marches-on">time marches on</a></i>
  steps for that <a href="#media-element">media element</a>.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrackCue-endTime" id="dom-texttrackcue-endtime"><code>endTime</code></dfn> attribute, on getting,
  must return the <a href="#text-track-cue-end-time">text track cue end time</a> of the <a href="#text-track-cue">text track cue</a> that the
  <code><a href="#texttrackcue">TextTrackCue</a></code> object represents, in seconds. On setting, the <a href="#text-track-cue-end-time">text track cue end
  time</a> must be set to the new value, interpreted in seconds; then, if the
  <code><a href="#texttrackcue">TextTrackCue</a></code> object's <a href="#text-track-cue">text track cue</a> is in a <a href="#text-track">text track</a>'s
  <a data-anolis-xref="text track list of cues" href="#text-track-list-of-cues">list of cues</a>, and that <a href="#text-track">text track</a> is in
  a <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>, and the <a href="#media-element">media
  element</a>'s <a href="#show-poster-flag">show poster flag</a> is not set, then run the <i><a href="#time-marches-on">time marches on</a></i>
  steps for that <a href="#media-element">media element</a>.</p>

  <p>The <dfn data-anolis-xref="dom-TextTrackCue-pauseOnExit" id="dom-texttrackcue-pauseonexit"><code>pauseOnExit</code></dfn> attribute, on
  getting, must return true if the <a href="#text-track-cue-pause-on-exit-flag">text track cue pause-on-exit flag</a> of the <a href="#text-track-cue">text
  track cue</a> that the <code><a href="#texttrackcue">TextTrackCue</a></code> object represents is set; or false otherwise.
  On setting, the <a href="#text-track-cue-pause-on-exit-flag">text track cue pause-on-exit flag</a> must be set if the new value is
  true, and must be unset otherwise.</p>

  </div>

    <h6 id="text-tracks-exposing-in-band-metadata"><span class="secno">4.7.14.12.6 </span>Text tracks exposing in-band metadata</h6>

  <p><a data-anolis-xref="media resource" href="#media-resource">メディアリソース</a>は、1つ以上のブラウザがレンダリングしないデータを含む<a data-anolis-xref="media-resource-specific text track" href="#media-resource-specific-text-track">メディアリソース固有のテキストトラック</a>を含むことが多いが、対処できるようにするスクリプトに公開する。</p>

  <p>ブラウザが<a href="#media-resource-specific-text-track">メディアリソース固有のテキストトラック</a>のキューでデータを公開することがより適切である<code><a href="#texttrackcue">TextTrackCue</a></code>インターフェースを識別することができない場合、<a href="#datacue">DataCue</a>オブジェクトが使用される。<a href="references.html#refsINBANDTRACKS">[INBANDTRACKS]</a></p>

  <pre class="idl">[<span data-anolis-xref="dom-DataCue">Constructor</span>(double startTime, double endTime, ArrayBuffer data)]
   interface <dfn id="datacue">DataCue</dfn> : <a href="#texttrackcue">TextTrackCue</a> {
               attribute ArrayBuffer <a data-anolis-xref="dom-DataCue-data" href="#dom-datacue-data">data</a>;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">cue</var> = new <code data-anolis-xref="dom-DomCue">DataCue</code>( [ <var data-anolis-xref="">startTime</var>, <var data-anolis-xref="">endTime</var>, <var data-anolis-xref="">data</var> ] )</dt>
  <dd>
    <p><code data-anolis-xref="dom-TextTrack-addCue"><a href="#dom-texttrack-addcue">addCue()</a></code>メソッドとともに使用するために、新しい<code><a href="#datacue">DataCue</a></code>オブジェクトを返す。</p>
    <p><var data-anolis-xref="">startTime</var>引数は<a href="#text-track-cue-start-time">テキストトラックキューの開始時刻</a>を設定する。</p>
    <p><var data-anolis-xref="">endTime</var>引数は、<a href="#text-track-cue-end-time">テキストトラックキューの終了時刻</a>を設定する。</p>
    <p>The <var data-anolis-xref="">data</var> argument is copied as the <a href="#text-track-cue-data">text track cue data</a>.</p>
  </dd>

  <dt><var data-anolis-xref="">cue</var> . <a data-anolis-xref="dom-DataCue-data" href="#dom-datacue-data">data</a> [ = <var data-anolis-xref="">value</var> ]</dt>
  <dd>
    <p>生の未解析フォームで<a href="#text-track-cue-data">テキストトラックキューのデータ</a>を返す。</p>
    <p>設定可能である。</p>
  </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-DataCue-data" id="dom-datacue-data"><code>data</code></dfn> attribute, on getting, must
  return the raw text track cue data of the <a href="#text-track-cue">text track cue</a> that the
  <code><a href="#texttrackcue">TextTrackCue</a></code> object represents. On setting, the text track cue data must
  be set to the new value.</p>

  </div>

  <p>ユーザーエージェントは、<a data-anolis-xref="dom-TextTrack-kind-metadata" href="#dom-texttrack-kind-metadata">メタデータ</a>の<a href="#text-track-kind">テキストトラックの種類</a>を持つ<a href="#text-track">テキストトラック</a>に所属する<a href="#text-track-cue">テキストトラックキュー</a>オブジェクトのみを公開する<a href="#datacue">DataCue</a>を使用するだろう。</p>

  <p class="note">一般的なメタデータが<a href="#text-track">テキストトラック</a>のために管理する必要がある場合、<a href="#datacue">DataCue</a>は、スクリプトに<a href="#datacue">DataCue</a>オブジェクトを作成できるようにするコンストラクタを持つ。</p>

  <p><a href="#datacue">DataCue</a>の<a href="#rules-for-updating-the-text-track-rendering">テキストトラックレンダリングを更新するための規則</a>は、キューが<a data-anolis-xref="text track
  showing" href="#text-track-showing">表示</a>モードでありかつ、<a href="#text-track-kind">テキストトラックの種類</a>が<code data-anolis-xref="dom-TextTrack-kind-subtitles"><a href="#dom-texttrack-kind-subtitles">subtitles</a></code>、<code data-anolis-xref="dom-TextTrack-kind-captions"><a href="#dom-texttrack-kind-captions">captions</a></code>、 <code data-anolis-xref="dom-TextTrack-kind-descriptions"><a href="#dom-texttrack-kind-descriptions">descriptions</a></code>または<code data-anolis-xref="dom-TextTrack-kind-chapters"><a href="#dom-texttrack-kind-chapters">chapters</a></code>のいずれかであっても、単にレンダリングが存在しないと述べる。</p>
  
  <h6 id="text-tracks-describing-chapters"><span class="secno">4.7.14.12.7</span> 章を記述するテキストトラック</h6>

  <p>章は、指定されたタイトルをもつ<a href="#media-resource">メディアリソース</a>の区分である。文書アウトラインのセクションでサブセクションを持つことができるのと同じように、章は入れ子にできる。</p>

  <p>章を記述するために使用されている<a href="#text-track">テキストトラック</a>内の各<a href="#text-track-cue">テキストトラックキュー</a>は、章の開始時刻を与える<a href="#text-track-cue-start-time">テキストトラックキューの開始時刻</a>、章の終了時刻を与える<a href="#text-track-cue-end-time">テキストトラックキューの終了時刻</a>、および章のタイトルを与える<a href="#text-track-cue-data">テキストトラックキューのテキスト</a>の3つの主要な機能を持つ。</p>

  <div class="impl">

  <p>The <dfn id="rules-for-constructing-the-chapter-tree-from-a-text-track">rules for constructing the chapter tree from a text track</dfn> are as follows. They
  produce a potentially nested list of chapters, each of which have a start time, end time, title,
  and a list of nested chapters. This algorithm discards cues that do not correctly nest within each
  other, or that are out of order.</p>

  <ol><li><p>Let <var data-anolis-xref="">list</var> be a copy of the <a data-anolis-xref="text track list of cues" href="#text-track-list-of-cues">list
   of cues</a> of the <a href="#text-track">text track</a> being processed.</li>

   <li><p>Remove from <var data-anolis-xref="">list</var> any <a href="#text-track-cue">text track cue</a> whose <a href="#text-track-cue-end-time">text
   track cue end time</a> is before its <a href="#text-track-cue-start-time">text track cue start time</a>.</li>

   <li><p>Let <var data-anolis-xref="">output</var> be an empty list of chapters, where a chapter is a record
   consisting of a start time, an end time, a title, and a (potentially empty) list of nested
   chapters. For the purpose of this algorithm, each chapter also has a parent chapter.</li>

   <li><p>Let <var data-anolis-xref="">current chapter</var> be a stand-in chapter whose start time is negative
   infinity, whose end time is positive infinity, and whose list of nested chapters is <var data-anolis-xref="">output</var>. (This is just used to make the algorithm easier to describe.)</li><!-- while not empty... -->

   
   <li><p><i>Loop</i>: If <var data-anolis-xref="">list</var> is empty, jump to the step labeled
   <i>end</i>.</li><!-- do... -->

   
   <li><p>Let <var data-anolis-xref="">current cue</var> be the first cue in <var data-anolis-xref="">list</var>, and then
   remove it from <var data-anolis-xref="">list</var>.</li>

   <li><p>If <var data-anolis-xref="">current cue</var>'s <a href="#text-track-cue-start-time">text track cue start time</a> is less than
   the start time of <var data-anolis-xref="">current chapter</var>, then return to the step labeled
   <i>loop</i>.</p><!-- out of order chapter --> 

   </li><li><p>While <var data-anolis-xref="">current cue</var>'s <a href="#text-track-cue-start-time">text track cue start time</a> is greater
   than or equal to <var data-anolis-xref="">current chapter</var>'s end time, let <var data-anolis-xref="">current
   chapter</var> be <var data-anolis-xref="">current chapter</var>'s parent chapter.</li>

   <li><p>If <var data-anolis-xref="">current cue</var>'s <a href="#text-track-cue-end-time">text track cue end time</a> is greater than
   the end time of <var data-anolis-xref="">current chapter</var>, then return to the step labeled
   <i>loop</i>.</p><!-- misnested chapter --> 

   </li><li>

    <p>Create a new chapter <var data-anolis-xref="">new chapter</var>, whose start time is <var data-anolis-xref="">current cue</var>'s <a href="#text-track-cue-start-time">text track cue start time</a>, whose end time is <var data-anolis-xref="">current cue</var>'s <a href="#text-track-cue-end-time">text track cue end time</a>, whose title is <var data-anolis-xref="">current cue</var>'s <a href="#text-track-cue-data">text track cue data</a> interpreted according to its
    <a href="#rules-for-rendering-the-cue-in-isolation">rules for rendering the cue in isolation</a>, and whose list of nested chapters is
    empty.</p>

    <p class="note">For WebVTT, the <a href="#rules-for-rendering-the-cue-in-isolation">rules for rendering the cue in isolation</a> are the
    <a href="infrastructure.html#rules-for-interpreting-webvtt-cue-text">rules for interpreting WebVTT cue text</a>. <a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

   </li>

   <li><p>Append <var data-anolis-xref="">new chapter</var> to <var data-anolis-xref="">current chapter</var>'s list of
   nested chapters, and let <var data-anolis-xref="">current chapter</var> be <var data-anolis-xref="">new chapter</var>'s
   parent.</li>

   <li><p>Let <var data-anolis-xref="">current chapter</var> be <var data-anolis-xref="">new chapter</var>.</li>

   <li><p>Return to the step labeled <i>loop</i>.</li><!-- ...end while -->
   

   <li><p><i>End</i>: Return <var data-anolis-xref="">output</var>.</li>

  </ol></div>

  <div class="example">

   <p><a href="infrastructure.html#webvtt-file">WebVTTファイル</a>の以下の断片は、ネストされた章をマークアップする様子を示す。ファイルは、3つの50分の章、"Astrophysics"、"Computational Physics"、および"General Relativity"を記述する。1つ目は3つのサブチャプターを持ち、2つ目は4つ、3つ目は2つのサブチャプターを持つ。<a href="references.html#refsWEBVTT">[WEBVTT]</a></p>

   <pre>WEBVTT

00:00:00.000 --&gt; 00:50:00.000
Astrophysics

00:00:00.000 --&gt; 00:10:00.000
Introduction to Astrophysics

00:10:00.000 --&gt; 00:45:00.000
The Solar System

00:00:00.000 --&gt; 00:10:00.000
Coursework Description

00:50:00.000 --&gt; 01:40:00.000
Computational Physics

00:50:00.000 --&gt; 00:55:00.000
Introduction to Programming

00:55:00.000 --&gt; 01:30:00.000
Data Structures

01:30:00.000 --&gt; 01:35:00.000
Answers to Last Exam

01:35:00.000 --&gt; 01:40:00.000
Coursework Description

01:40:00.000 --&gt; 02:30:00.000
General Relativity

01:40:00.000 --&gt; 02:00:00.000
Tensor Algebra

02:00:00.000 --&gt; 02:30:00.000
The General Relativistic Field Equations</pre>

  </div>


  <div class="impl">

  <h6 id="cue-events"><span class="secno">4.7.14.12.8 </span>Event handlers for objects of the text track APIs</h6>

  <p>The following are the <a href="webappapis.html#event-handlers">event handlers</a> that (and their corresponding <a data-anolis-xref="event handler event type" href="webappapis.html#event-handler-event-type">event handler event types</a>) must be supported, as <a href="webappapis.html#event-handler-idl-attributes">event handler IDL
  attributes</a>, by all objects implementing the <code><a href="#texttracklist">TextTrackList</a></code> interface:</p>

  <table><thead><tr><th><a data-anolis-xref="event handlers" href="webappapis.html#event-handlers">イベントハンドラ</a> </th><th><a href="webappapis.html#event-handler-event-type">イベントハンドライベント型</a>
   <tbody></th></tr><tr><td><dfn data-anolis-xref="handler-TextTrackList-onchange" id="handler-texttracklist-onchange"><code>onchange</code></dfn> </td><td> <code data-anolis-xref="event-media-change"><a href="#event-media-change">change</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-TextTrackList-onaddtrack" id="handler-texttracklist-onaddtrack"><code>onaddtrack</code></dfn> </td><td> <code data-anolis-xref="event-media-addtrack"><a href="#event-media-addtrack">addtrack</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-TextTrackList-onremovetrack" id="handler-texttracklist-onremovetrack"><code>onremovetrack</code></dfn> </td><td> <code data-anolis-xref="event-media-removetrack"><a href="#event-media-removetrack">removetrack</a></code>
  </td></tr></table><p>The following are the <a href="webappapis.html#event-handlers">event handlers</a> that (and their corresponding <a data-anolis-xref="event handler event type" href="webappapis.html#event-handler-event-type">event handler event types</a>) must be supported, as <a href="webappapis.html#event-handler-idl-attributes">event handler IDL
  attributes</a>, by all objects implementing the <code><a href="#texttrack">TextTrack</a></code> interface:</p>

  <table><thead><tr><th><a data-anolis-xref="event handlers" href="webappapis.html#event-handlers">イベントハンドラ</a> </th><th><a href="webappapis.html#event-handler-event-type">イベントハンドライベント型</a>
   <tbody></th></tr><tr><td><dfn data-anolis-xref="handler-TextTrack-oncuechange" id="handler-texttrack-oncuechange"><code>oncuechange</code></dfn> </td><td> <code data-anolis-xref="event-media-cuechange"><a href="#event-media-cuechange">cuechange</a></code>
  </td></tr></table><p>The following are the <a href="webappapis.html#event-handlers">event handlers</a> that (and their corresponding <a data-anolis-xref="event handler event type" href="webappapis.html#event-handler-event-type">event handler event types</a>) must be supported, as <a href="webappapis.html#event-handler-idl-attributes">event handler IDL
  attributes</a>, by all objects implementing the <code><a href="#texttrackcue">TextTrackCue</a></code> interface:</p>

  <table><thead><tr><th><a data-anolis-xref="event handlers" href="webappapis.html#event-handlers">イベントハンドラ</a> </th><th><a href="webappapis.html#event-handler-event-type">イベントハンドライベント型</a>
   <tbody></th></tr><tr><td><dfn data-anolis-xref="handler-TextTrackCue-onenter" id="handler-texttrackcue-onenter"><code>onenter</code></dfn> </td><td> <code data-anolis-xref="event-media-enter"><a href="#event-media-enter">enter</a></code>
    </td></tr><tr><td><dfn data-anolis-xref="handler-TextTrackCue-onexit" id="handler-texttrackcue-onexit"><code>onexit</code></dfn> </td><td> <code data-anolis-xref="event-media-exit"><a href="#event-media-exit">exit</a></code>
  </td></tr></table></div>



  <h6 id="best-practices-for-metadata-text-tracks"><span class="secno">4.7.14.12.9 </span>Best practices for metadata text tracks</h6>

  <p><i>この節は非規範的である。</i></p>

  <p>テキストトラックは、対話型または拡張されたビューに対して、メディアデータに関連するデータを格納するために使用することができる。 </p>

  <p>たとえば、スポーツ中継を表示するページは、現在のスコアに関する情報を含むだろう。ロボット工学のコンテストがライブストリーミングされていたとする。次のように、画像にスコアを重ねることができる：</p><!--FORK data URL is in file instead -->

  
  <p><iframe height="400" src="images/robots.html" width="600"></iframe>

  <p>ユーザーがビデオ内の任意のポイントをシークするたびに、スコア表示を正しく描画させるために、メタデータテキストトラックキューは、スコアに適切であるようにする必要がある。たとえば、上のフレームにおいて、試合数を与える試合の長さに続く1つのキュー、青の同盟のスコアが変化するまで続く1つのキュー、そして赤の同盟のスコアが変化するまで続く1つのキューがおそらくあるだろう。ビデオがちょうどライブイベントのストリームである場合、右下における時間は、キューに基づくよりもむしろ、おそらく自動的に現在のビデオの時間から派生になる。しかし、ビデオが単なるハイライトだった場合、それはまたキューに記載されるかもしれない。</p>

  <p>次は、このようなものの断片がWebVTTファイル内のようになるものを示す：</p>

  <pre>WEBVTT

...

05:10:00.000 --&gt; 05:12:15.000
matchtype:qual
matchnumber:37

...

05:11:02.251 --&gt; 05:11:17.198
red:78

05:11:03.672 --&gt; 05:11:54.198
blue:66

05:11:17.198 --&gt; 05:11:25.912
red:80

05:11:25.912 --&gt; 05:11:26.522
red:83

05:11:26.522 --&gt; 05:11:26.982
red:86

05:11:26.982 --&gt; 05:11:27.499
red:89

...</pre>

  <p>ここで重要なことは、該当するイベントが適用する時間の長さに及ぶキューに情報が与えられることに注目することである。代わりに、スコアが変化する際に、スコアがゼロ長さ（または非常に短い、ほぼゼロ長さ）のキューとして指定された場合、
たとえば05:11:17.198で"red+2"、05:11:25.912で"red+3"などと言ったときに、問題は発生する。主に、スクリプトが一切の通知を見逃されていないことを確認するためにキューのリスト全体を渡り歩く必要があるため、シークは実装がはるかに困難である。キューが短い場合、スクリプトが明確にキューをリッスンしない限り、スクリプトはキューがアクティブであることを見ることはない。</p>

  <p>この方法でキューを使用する場合、著者は、現在の注釈を更新するために<code data-anolis-xref="event-media-cuechange"><a href="#event-media-cuechange">cuechange</a></code>イベントを使用することを勧める。（具体的には、それはキューが変更されていない場合でも、仕事をすることを必要とするように<code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code>イベントを使用することがあまり適切でなく、そしてより重要なことは、<code data-anolis-xref="event-media-timeupdate"><a href="#event-media-timeupdate">timeupdate</a></code>イベントがレート制限されているため、メタデータキューがアクティブになる場合、かつ表示が更新される場合、間のより高いレイテンシーを導入する。）</p>



  <h5 id="user-interface"><span class="secno">4.7.14.13</span> ユーザーインターフェース</h5>

  <p><dfn data-anolis-xref="attr-media-controls" id="attr-media-controls"><code>controls</code></dfn>属性は<a href="infrastructure.html#boolean-attribute">真偽属性</a>である。存在する場合、著者がスクリプト化されたコントローラを提供しておらず、ユーザーエージェントに独自のコントロールセットを提供したいと考えていることを示す。</p>

  <div class="impl">

  <p>If the attribute is present, or if <a data-anolis-xref="concept-n-noscript" href="webappapis.html#concept-n-noscript">scripting is
  disabled</a> for the <a href="#media-element">media element</a>, then the user agent should <dfn id="expose-a-user-interface-to-the-user">expose a user
  interface to the user</dfn>. This user interface should include features to begin playback, pause
  playback, seek to an arbitrary position in the content (if the content supports arbitrary
  seeking), change the volume, change the display of closed captions or embedded sign-language
  tracks, select different audio tracks or turn on audio descriptions, and show the media content in
  manners more suitable to the user (e.g. full-screen video or in an independent resizable window).
  Other controls may also be made available.</p>

  <p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, then the user
  agent should expose audio tracks from all the <a href="#slaved-media-elements">slaved media elements</a> (although
  avoiding duplicates if the same <a href="#media-resource">media resource</a> is being used several times). If a
  <a href="#media-resource">media resource</a>'s audio track exposed in this way has no known name, and it is the
  only audio track for a particular <a href="#media-element">media element</a>, the user agent should use the
  element's <code data-anolis-xref="attr-title"><a href="dom.html#attr-title">title</a></code> attribute, if any, as the name (or as part of the
  name) of that track.</p>

  <p>Even when the attribute is absent, however, user agents may provide controls to affect playback
  of the media resource (e.g. play, pause, seeking, and volume controls), but such features should
  not interfere with the page's normal rendering. For example, such features could be exposed in the
  <a href="#media-element">media element</a>'s context menu. The user agent may implement this simply by <a data-anolis-xref="expose a user interface to the user" href="#expose-a-user-interface-to-the-user">exposing a user interface to the user</a> as
  described above (as if the <code data-anolis-xref="attr-media-controls"><a href="#attr-media-controls">controls</a></code> attribute was
  present).</p>

  <p>If the user agent <a data-anolis-xref="expose a user interface to the user" href="#expose-a-user-interface-to-the-user">exposes a user interface to
  the user</a> by displaying controls over the <a href="#media-element">media element</a>, then the user agent
  should suppress any user interaction events while the user agent is interacting with this
  interface. (For example, if the user clicks on a video's playback control, <code data-anolis-xref="event-mousedown"><a href="infrastructure.html#event-mousedown">mousedown</a></code> events and so forth would not simultaneously be fired at
  elements on the page.)</p>

  <p>Where possible (specifically, for starting, stopping, pausing, and unpausing playback, for
  seeking, for changing the rate of playback, for fast-forwarding or rewinding, for listing,
  enabling, and disabling text tracks, and for muting or changing the volume of the audio), user
  interface features exposed by the user agent must be implemented in terms of the DOM API described
  above, so that, e.g., all the same events fire.</p>

  <p>When a <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, the user agent's
  user interface for pausing and unpausing playback, for seeking, for changing the rate of playback,
  for fast-forwarding or rewinding, and for muting or changing the volume of audio of the entire
  group must be implemented in terms of the <code><a href="#mediacontroller">MediaController</a></code> API exposed on that
  <a href="#current-media-controller">current media controller</a>. When a <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media
  controller</a>, and all the <a href="#slaved-media-elements">slaved media elements</a> of that
  <code><a href="#mediacontroller">MediaController</a></code> are paused, the user agent should also unpause all the <a href="#slaved-media-elements">slaved
  media elements</a> when the user invokes a user agent interface control for beginning
  playback.</p>

  <p>The "play" function in the user agent's interface must set the <code data-anolis-xref="">playbackRate</code> attribute to the value of the <code data-anolis-xref="">defaultPlaybackRate</code> attribute before invoking the <code data-anolis-xref="">play()</code>
  method. When a <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, the
  attributes and method with those names on that <code><a href="#mediacontroller">MediaController</a></code> object must be used.
  Otherwise, the attributes and method with those names on the <a href="#media-element">media element</a> itself
  must be used.  </p>

  <p>Features such as fast-forward or rewind must be implemented by only changing the <code data-anolis-xref="">playbackRate</code> attribute (and not the <code data-anolis-xref="">defaultPlaybackRate</code>
  attribute). Again, when a <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>,
  the attributes with those names on that <code><a href="#mediacontroller">MediaController</a></code> object must be used;
  otherwise, the attributes with those names on the <a href="#media-element">media element</a> itself must be used.</p>

  <p>When a <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, seeking must be
  implemented in terms of the <code data-anolis-xref="dom-MediaController-currentTime"><a href="#dom-mediacontroller-currenttime">currentTime</a></code>
  attribute on that <code><a href="#mediacontroller">MediaController</a></code> object. Otherwise, the user agent must directly
  <a data-anolis-xref="dom-media-seek" href="#dom-media-seek">seek</a> to the requested position in the <a href="#media-element">media
  element</a>'s <a href="#media-timeline">media timeline</a>. For media resources where seeking to an arbitrary
  position would be slow, user agents are encouraged to use the <i>approximate-for-speed</i> flag
  when seeking in response to the user manipulating an approximate position interface such as a seek
  bar.</p>

  <p>When a <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, user agents may
  additionally provide the user with controls that directly manipulate an individual <a href="#media-element">media
  element</a> without affecting the <code><a href="#mediacontroller">MediaController</a></code>, but such features are
  considered relatively advanced and unlikely to be useful to most users.</p>

  <p>The <a href="editing.html#activation-behavior">activation behavior</a> of a <a href="#media-element">media element</a> that is <a data-anolis-xref="expose a user interface to the user" href="#expose-a-user-interface-to-the-user">exposing a user interface to the user</a> must be
  to run the following steps:</p>

  <ol><li><p>If the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>, and that
   <a href="#current-media-controller">current media controller</a> is a <a href="#restrained-media-controller">restrained media controller</a>, then invoke
   the <code data-anolis-xref="dom-MediaController-play"><a href="#dom-mediacontroller-play">play()</a></code> method of the
   <code><a href="#mediacontroller">MediaController</a></code>.</li>

   <li><p>Otherwise, if the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>,
   and that <a href="#current-media-controller">current media controller</a> is a <a href="#paused-media-controller">paused media controller</a>, then
   invoke the <code data-anolis-xref="dom-MediaController-unpause"><a href="#dom-mediacontroller-unpause">unpause()</a></code> method of the
   <code><a href="#mediacontroller">MediaController</a></code>.</li>

   <li><p>Otherwise, if the <a href="#media-element">media element</a> has a <a href="#current-media-controller">current media controller</a>,
   then that <a href="#current-media-controller">current media controller</a> is a <a href="#playing-media-controller">playing media controller</a>;
   invoke the <code data-anolis-xref="dom-MediaController-pause"><a href="#dom-mediacontroller-pause">pause()</a></code> method of the
   <code><a href="#mediacontroller">MediaController</a></code>.</li>

   <li><p>Otherwise, the <a href="#media-element">media element</a> has no <a href="#current-media-controller">current media controller</a>; if
   the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is true,
   then invoke the <code data-anolis-xref="dom-media-play"><a href="#dom-media-play">play()</a></code> method on the <a href="#media-element">media
   element</a>.</li>

   <li><p>Otherwise, the <a href="#media-element">media element</a> has no <a href="#current-media-controller">current media controller</a>,
   and the <a href="#media-element">media element</a>'s <code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code> attribute is
   false; invoke the <code data-anolis-xref="dom-media-pause"><a href="#dom-media-pause">pause()</a></code> method on the <a href="#media-element">media
   element</a>.</li>

  </ol><p>For the purposes of listing chapters in the <a href="#media-resource">media resource</a>, only <a data-anolis-xref="text
  track" href="#text-track">text tracks</a> in the <a href="#media-element">media element</a>'s <a href="#list-of-text-tracks">list of text tracks</a>
  that are <a data-anolis-xref="text track showing" href="#text-track-showing">showing</a> and whose <a href="#text-track-kind">text track kind</a> is
  <code data-anolis-xref="dom-TextTrack-kind-chapters"><a href="#dom-texttrack-kind-chapters">chapters</a></code> should be used. Such tracks must be
  interpreted according to the <a href="#rules-for-constructing-the-chapter-tree-from-a-text-track">rules for constructing the chapter tree from a text
  track</a>. When seeking in response to a user maniplating a chapter selection interface, user
  agents should not use the <i>approximate-for-speed</i> flag.</p>

  <p>The <dfn data-anolis-xref="dom-media-controls" id="dom-media-controls"><code>controls</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the content attribute of the same name.</p>

  <hr></div>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-volume"><a href="#dom-media-volume">volume</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p>0.0から1.0までの範囲の数字として、現在の再生音量を返す。ここで0.0は最小音量で1.0は最大音量である。</p>

    <p>音量を変更する設定が可能である。</p>

    <p>新しい値が範囲0.0から1.0に含まれない場合、<code><a href="infrastructure.html#indexsizeerror">IndexSizeError</a></code>を投げる。 </p>

   </dd>

   <dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-media-muted"><a href="#dom-media-muted">muted</a></code> [ = <var data-anolis-xref="">value</var> ]</dt>

   <dd>

    <p><code data-anolis-xref="dom-media-volume"><a href="#dom-media-volume">volume</a></code>属性を上書きし、音声がミュートである場合trueを返し、<code data-anolis-xref="dom-media-volume"><a href="#dom-media-volume">volume</a></code>属性が無視される場合、falseを返す。</p>

    <p>オーディオがミュートであるかどうかを変更する設定が可能である。</p>

   </dd>

  </dl><div class="impl">

  <p>A <a href="#media-element">media element</a> has a <dfn data-anolis-xref="concept-media-volume" id="concept-media-volume">playback volume</dfn>, which is a fraction in the range 0.0 (silent) to 1.0 (loudest).
  Initially, the volume should be 1.0, but user agents may remember the last set value across
  sessions, on a per-site basis or otherwise, so the volume may start at other values.</p>

  <p>The <dfn data-anolis-xref="dom-media-volume" id="dom-media-volume"><code>volume</code></dfn> IDL attribute must return the
  <a data-anolis-xref="concept-media-volume" href="#concept-media-volume">playback volume</a> of any audio portions of the
  <a href="#media-element">media element</a>. On setting, if the new value is in the range 0.0 to 1.0 inclusive, the
  <a href="#media-element">media element</a>'s <a data-anolis-xref="concept-media-volume" href="#concept-media-volume">playback volume</a> must be
  set to the new value. If the new value is outside the range 0.0 to 1.0 inclusive, then, on
  setting, an <code><a href="infrastructure.html#indexsizeerror">IndexSizeError</a></code> exception must be thrown instead.</p>

  <p>A <a href="#media-element">media element</a> can also be <dfn data-anolis-xref="concept-media-muted" id="concept-media-muted">muted</dfn>. If
  anything is muting the element, then it is muted. (For example, when the <a href="#direction-of-playback">direction of
  playback</a> is backwards, the element is muted.)</p>

  <p>The <dfn data-anolis-xref="dom-media-muted" id="dom-media-muted"><code>muted</code></dfn> IDL attribute must return the value
  to which it was last set. When a <a href="#media-element">media element</a> is created, if the element has a <code data-anolis-xref="attr-media-muted"><a href="#attr-media-muted">muted</a></code> content attribute specified, then the <code data-anolis-xref="dom-media-muted"><a href="#dom-media-muted">muted</a></code> IDL attribute should be set to true; otherwise, the user
  agents may set the value to the user's preferred value (e.g. remembering the last set value across
  sessions, on a per-site basis or otherwise). While the <code data-anolis-xref="dom-media-muted"><a href="#dom-media-muted">muted</a></code>
  IDL attribute is set to true, the <a href="#media-element">media element</a> must be <a data-anolis-xref="concept-media-muted" href="#concept-media-muted">muted</a>.</p>

  <p>Whenever either of the values that would be returned by the <code data-anolis-xref="dom-media-volume"><a href="#dom-media-volume">volume</a></code> and <code data-anolis-xref="dom-media-muted"><a href="#dom-media-muted">muted</a></code> IDL
  attributes change, the user agent must <a href="webappapis.html#queue-a-task">queue a task</a> to <a href="webappapis.html#fire-a-simple-event">fire a simple
  event</a> named <code data-anolis-xref="event-media-volumechange"><a href="#event-media-volumechange">volumechange</a></code> at the <a href="#media-element">media
  element</a>.</p>

  <p>An element's <dfn id="effective-media-volume">effective media volume</dfn> is determined as follows:</p>

  <ol><li><p>If the user has indicated that the user agent is to override the volume of the element,
   then the element's <a href="#effective-media-volume">effective media volume</a> is the volume desired by the user. Abort
   these steps.</li>

   <li><p>If the element's audio output is <a data-anolis-xref="concept-media-muted" href="#concept-media-muted">muted</a>, the
   element's <a href="#effective-media-volume">effective media volume</a> is zero. Abort these steps.</li>

   <li><p>If the element has a <a href="#current-media-controller">current media controller</a> and that
   <code><a href="#mediacontroller">MediaController</a></code> object's <a href="#media-controller-mute-override">media controller mute override</a> is true, the
   element's <a href="#effective-media-volume">effective media volume</a> is zero. Abort these steps.</li>

   <li><p>Let <var data-anolis-xref="">volume</var> be the <a data-anolis-xref="concept-media-volume" href="#concept-media-volume">playback
   volume</a> of the audio portions of the <a href="#media-element">media element</a>, in range 0.0 (silent) to
   1.0 (loudest).</li>

   <li><p>If the element has a <a href="#current-media-controller">current media controller</a>, multiply <var data-anolis-xref="">volume</var> by that <code><a href="#mediacontroller">MediaController</a></code> object's <a href="#media-controller-volume-multiplier">media controller
   volume multiplier</a>. (The <a href="#media-controller-volume-multiplier">media controller volume multiplier</a> is in the range
   0.0 to 1.0, so this can only reduce the value.)</li>

   <li><p>The element's <a href="#effective-media-volume">effective media volume</a> is <var data-anolis-xref="">volume</var>,
   interpreted relative to the range 0.0 to 1.0, with 0.0 being silent, and 1.0 being the loudest
   setting, values in between increasing in loudness. The range need not be linear. The loudest
   setting may be lower than the system's loudest possible setting; for example the user could have
   set a maximum volume.</li>

  </ol></div>

  <p><a data-anolis-xref="media element" href="#media-element">メディア要素</a>の<dfn data-anolis-xref="attr-media-muted" id="attr-media-muted"><code>muted</code></dfn>属性は、潜在的にユーザー設定を上書きし、<a href="#media-resource">メディアリソース</a>に属するオーディオ出力のデフォルトの状態を制御する<a href="infrastructure.html#boolean-attribute">真偽属性</a>である。</p>

  <div class="impl">

  <p>The <dfn data-anolis-xref="dom-media-defaultMuted" id="dom-media-defaultmuted"><code>defaultMuted</code></dfn> IDL attribute must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-media-muted"><a href="#attr-media-muted">muted</a></code> content attribute.</p>

  </div>

  <p class="note">この属性は動的効果（要素のデフォルトの状態のみを制御する）を持たない。</p>

  <div class="example">

   <p>このビデオ（広告）は自動再生するが、ユーザーを悩ますのを避けるために音なしで再生して、ユーザーが音声をオンにできるようにする。</p>

   <pre>&lt;video src="adverts.cgi?kind=video" controls autoplay loop muted&gt;&lt;/video&gt;</pre>

  </div>




  <h5 id="time-ranges"><span class="secno">4.7.14.14</span> 時間範囲</h5>

  <p><code><a href="#timeranges">TimeRanges</a></code>インターフェースを実装したオブジェクトは、時間の範囲（期間）のリストを表す。</p>

  <pre class="idl">interface <dfn id="timeranges">TimeRanges</dfn> {
  readonly attribute unsigned long <a data-anolis-xref="dom-TimeRanges-length" href="#dom-timeranges-length">length</a>;
  double <a data-anolis-xref="dom-TimeRanges-start" href="#dom-timeranges-start">start</a>(unsigned long index);
  double <a data-anolis-xref="dom-TimeRanges-end" href="#dom-timeranges-end">end</a>(unsigned long index);
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-TimeRanges-length"><a href="#dom-timeranges-length">length</a></code></dt>

   <dd>

    <p>オブジェクト内の範囲の数を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">time</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-TimeRanges-start"><a href="#dom-timeranges-start">start</a></code>(<var data-anolis-xref="">index</var>)</dt>

   <dd>

    <p>指定されたインデックスをもつ範囲の開始時刻を返す。</p>

    <p>インデックスが範囲外の場合<code><a href="infrastructure.html#indexsizeerror">IndexSizeError</a></code>を投げる。</p>

   </dd>

   <dt><var data-anolis-xref="">time</var> = <var data-anolis-xref="">media</var> . <code data-anolis-xref="dom-TimeRanges-end"><a href="#dom-timeranges-end">end</a></code>(<var data-anolis-xref="">index</var>)</dt>

   <dd>

    <p>指定されたインデックスをもつ範囲の終了時刻を返す。</p>

    <p>インデックスが範囲外の場合<code><a href="infrastructure.html#indexsizeerror">IndexSizeError</a></code>を投げる。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-TimeRanges-length" id="dom-timeranges-length"><code>length</code></dfn> IDL attribute must return the
  number of ranges represented by the object.</p>

  <p>The <dfn data-anolis-xref="dom-TimeRanges-start" id="dom-timeranges-start"><code>start(<var data-anolis-xref="">index</var>)</code></dfn>
  method must return the position of the start of the <var data-anolis-xref="">index</var>th range represented
  by the object, in seconds measured from the start of the timeline that the object covers.</p>

  <p>The <dfn data-anolis-xref="dom-TimeRanges-end" id="dom-timeranges-end"><code>end(<var data-anolis-xref="">index</var>)</code></dfn> method
  must return the position of the end of the <var data-anolis-xref="">index</var>th range represented by the
  object, in seconds measured from the start of the timeline that the object covers.</p>

  <p>These methods must throw <code><a href="infrastructure.html#indexsizeerror">IndexSizeError</a></code> exceptions if called with an <var data-anolis-xref="">index</var> argument greater than or equal to the number of ranges represented by the
  object.</p>

  <p>When a <code><a href="#timeranges">TimeRanges</a></code> object is said to be a <dfn id="normalised-timeranges-object">normalised <code>TimeRanges</code>
  object</dfn>, the ranges it represents must obey the following criteria:</p>

  <ul><li>The start of a range must be greater than the end of all earlier ranges.</li>

   <li>The start of a range must be less than the end of that same range.</li>

  </ul><p>In other words, the ranges in such an object are ordered, don't overlap, aren't empty, and
  don't touch (adjacent ranges are folded into one bigger range).</p>

  <p>Ranges in a <code><a href="#timeranges">TimeRanges</a></code> object must be inclusive.</p>

  <p class="example">Thus, the end of a range would be equal to the start of a following adjacent
  (touching but not overlapping) range. Similarly, a range covering a whole timeline anchored at
  zero would have a start equal to zero and an end equal to the duration of the timeline.</p>

  <p>The timelines used by the objects returned by the <code data-anolis-xref="dom-media-buffered"><a href="#dom-media-buffered">buffered</a></code>, <code data-anolis-xref="dom-media-seekable"><a href="#dom-media-seekable">seekable</a></code> and
  <code data-anolis-xref="dom-media-played"><a href="#dom-media-played">played</a></code> IDL attributes of <a data-anolis-xref="media element" href="#media-element">media
  elements</a> must be that element's <a href="#media-timeline">media timeline</a>.</p>

  </div>


  <h5 id="the-trackevent-interface"><span class="secno">4.7.14.15</span> <code><a href="#trackevent">TrackEvent</a></code>インタフェース</h5>

  <pre class="idl">[Constructor(DOMString type, optional <a href="#trackeventinit">TrackEventInit</a> eventInitDict)]
interface <dfn id="trackevent">TrackEvent</dfn> : <a href="infrastructure.html#event">Event</a> {
  readonly attribute (<a href="#videotrack">VideoTrack</a> or <a href="#audiotrack">AudioTrack</a> or <a href="#texttrack">TextTrack</a>) <a data-anolis-xref="dom-TrackEvent-track" href="#dom-trackevent-track">track</a>;
};

dictionary <dfn id="trackeventinit">TrackEventInit</dfn> : <a href="infrastructure.html#eventinit">EventInit</a> {
  (<a href="#videotrack">VideoTrack</a> or <a href="#audiotrack">AudioTrack</a> or <a href="#texttrack">TextTrack</a>) track;
};</pre>

  <dl class="domintro"><dt><var data-anolis-xref="">event</var> . <code data-anolis-xref="dom-TrackEvent-track"><a href="#dom-trackevent-track">track</a></code></dt>

   <dd>

    <p>イベントが関連するトラックオブジェクト（<code><a href="#texttrack">TextTrack</a></code>、<code><a href="#audiotrack">AudioTrack</a></code>、または<code><a href="#videotrack">VideoTrack</a></code>）を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-TrackEvent-track" id="dom-trackevent-track"><code>track</code></dfn> attribute must return the value it was initialised to. オブジェクトが作成される際、この属性はnullに初期化しなければならない。It represents the context information for the event.</p>

  </div>



  <h5 id="mediaevents"><span class="secno">4.7.14.16 </span>Event summary</h5>

  <p><i>この節は非規範的である。</i></p>

  <p>上記の処理モデルの一部として、<a data-anolis-xref="media element" href="#media-element">メディア要素</a>で以下のイベントが発火する：</p>

  <table><thead><tr><th>イベント名
     </th><th>インターフェース
     </th><th>発火条件
     </th><th>Preconditions

   

   <tbody></th></tr><tr><td><dfn data-anolis-xref="event-media-loadstart" id="event-media-loadstart"><code>loadstart</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、<a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">リソース選択アルゴリズム</a>の一部として、<a href="#media-data">メディアデータ</a>を探し始める。

     </td><td><code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate"> networkState</a></code>が<code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>と等しい

    </td></tr><tr><td><dfn data-anolis-xref="event-media-progress" id="event-media-progress"><code>progress</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、<a href="#media-data">メディアデータ</a>をフェッチしている。

     </td><td><code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate"> networkState</a></code>が<code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>と等しい

    </td></tr><tr><td><dfn data-anolis-xref="event-media-suspend" id="event-media-suspend"><code>suspend</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、意図的に現在の<a href="#media-data">メディアデータ</a>をフェッチしていない。

     </td><td><code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate"> networkState</a></code>は<code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code>と等しい

    </td></tr><tr><td><dfn data-anolis-xref="event-media-abort" id="event-media-abort"><code>abort</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、完全にダウンロードされる前に<a href="#media-data">メディアデータ</a>のフェッチを停止するが、エラーによるものではない。

     </td><td><code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code>は、コード<code data-anolis-xref="dom-MediaError-MEDIA_ERR_ABORTED"><a href="#dom-mediaerror-media_err_aborted">MEDIA_ERR_ABORTED</a></code>をもつオブジェクトである。<code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate"> networkState</a></code>は、ダウンロードが中止された時期に応じて、<code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>または<code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code>のいずれかに等しい。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-error" id="event-media-error"><code>error</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><a href="#media-data">メディアデータ</a>のフェッチ中にエラーが発生する。

     </td><td><code data-anolis-xref="dom-media-error"><a href="#dom-media-error">error</a></code>は、コード<code data-anolis-xref="dom-MediaError-MEDIA_ERR_NETWORK"><a href="#dom-mediaerror-media_err_network">MEDIA_ERR_NETWORK</a></code>以上をもつオブジェクトである。<code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate"> networkState</a></code>は、ダウンロードが中止された時期に応じて、<code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>または<code data-anolis-xref="dom-media-NETWORK_IDLE"><a href="#dom-media-network_idle">NETWORK_IDLE</a></code>のいずれかに等しい。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-emptied" id="event-media-emptied"><code>emptied</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>以前<code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>状態でなかった<code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>である<a href="#media-element">メディア要素</a>が、その状態にちょうど切り替わった（ロード中に致命的なエラーが発生したため、<a data-anolis-xref="concept-media-load-algorithm" href="#concept-media-load-algorithm">リソース選択アルゴリズム</a>がすでに実行している間に<code data-anolis-xref="dom-media-load"><a href="#dom-media-load">load()</a></code>メソッドが呼び出されたためのいずれか）。

     </td><td><code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>は<code data-anolis-xref="dom-media-NETWORK_EMPTY"><a href="#dom-media-network_empty">NETWORK_EMPTY</a></code>であり、すべてのIDL属性は、初期状態である。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-stalled" id="event-media-stalled"><code>stalled</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、<a href="#media-data">メディアデータ</a>をフェッチしようとしているが、データが突発的に用意されない。

     </td><td><code data-anolis-xref="dom-media-networkState"><a href="#dom-media-networkstate">networkState</a></code>は<code data-anolis-xref="dom-media-NETWORK_LOADING"><a href="#dom-media-network_loading">NETWORK_LOADING</a></code>である。

   <tbody></td></tr><tr><td><dfn data-anolis-xref="event-media-loadedmetadata" id="event-media-loadedmetadata"><code>loadedmetadata</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、ちょうど<a href="#media-resource">メディアリソース</a>と<a href="#the-text-tracks-are-ready">テキストトラックの準備</a>の期間と寸法を決定した。

     </td><td><code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>は初期時間に対して新たに<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>に等しいかそれ以上である。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-loadeddata" id="event-media-loadeddata"><code>loadeddata</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、初期時間に対して<a href="#current-playback-position">現在の再生位置</a>で<a href="#media-data">メディアデータ</a>をレンダリングできる。

     </td><td><code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>は、初期時間に対して新たに<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>以上に増加した。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-canplay" id="event-media-canplay"><code>canplay</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、<a href="#media-data">メディアデータ</a>の再生を再開できるが、再生を今すぐ開始されることになったかどうかを推定し、<a href="#media-resource">メディアリソース</a>は、コンテンツの追加のバッファリングに対して停止させることなく、終わりに現在の再生レートでレンダリングできなかった。

     </td><td><code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>は、新たに<code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>以上に増加した。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-canplaythrough" id="event-media-canplaythrough"><code>canplaythrough</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>ユーザーエージェントは、再生が今すぐ開始されることになったかどうかを推定し、<a href="#media-resource">メディアリソース</a>は追加のバッファリングに対して停止することなく、現在の再生レートの最後までのすべての方法でレンダリングできる。

     </td><td><code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>は最近の<code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code>に等しい。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-playing" id="event-media-playing"><code>playing</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>再生は、<a href="#media-data">メディアデータ</a>の不足のために、一時停止または遅延された後に開始する準備ができている。

     </td><td><code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が新たに等しいまたは<code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>を超えており、<code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>はfalseであり、または<code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>が新たにfalseであり、<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が等しいか、または<code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>より大きい。たとえこのイベントが発火しても、 要素は依然として<a href="#potentially-playing">潜在的に再生</a>されていないかもしれない。たとえば、要素が<a href="#blocked-on-its-media-controller">メディアコントローラ上でブロックされる</a>場合（たとえば、<a href="#current-media-controller">現在のメディアコントローラ</a>が一時停止するか、または別の<a data-anolis-xref="slaved media elements" href="#slaved-media-elements">従属メディア要素</a>が何らかの形でストールしているため、または<a href="#media-resource">メディアリソース</a>が<a href="#media-controller-position">メディアコントローラの位置</a>に対応するデータがないため）、または要素が<a href="#paused-for-user-interaction">ユーザーとの対話のために一時停止</a>または<a href="#paused-for-in-band-content">帯域内コンテンツのために一時停止</a>である。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-waiting" id="event-media-waiting"><code>waiting</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>次のフレームが利用できないため、再生が停止したが、ユーザーエージェントは、そのフレームがやがて利用できるようになると予想する。

     </td><td><code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が等しいか、または<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>未満であり、<code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>はfalseである。<code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code>はtrueである、または<a href="#current-playback-position">現在の再生位置</a>は<code data-anolis-xref="dom-media-buffered"><a href="#dom-media-buffered">buffered</a></code>内の領域のいずれかに含まれていないかのいずれか。再生が<code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>がfalseでなしにその他の理由で停止することは可能であるが、それらの理由はこのイベントは発火しない（そしてそのような状況が解決するときに、別々の<code data-anolis-xref="event-media-playing"><a href="#event-media-playing">playing</a></code>イベントがどちらか発火しない）：たとえば、要素が新たに<a href="#blocked-on-its-media-controller">そのメディアコントローラ上でブロック</a>される、<a data-anolis-xref="ended playback" href="#ended-playback">再生が終了</a>する、または再生が<a href="#stopped-due-to-errors">エラーにより停止</a>され、または要素が<a href="#paused-for-user-interaction">ユーザーとの対話のために一時停止</a>または<a href="#paused-for-in-band-content">帯域内コンテンツのために一時停止</a>している。

   <tbody></td></tr><tr><td><dfn data-anolis-xref="event-media-seeking" id="event-media-seeking"><code>seeking</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code>IDL属性がtrueに変更され、かつユーザーエージェントが新しい位置を探し始めている。

     </td><td>

    </td></tr><tr><td><dfn data-anolis-xref="event-media-seeked" id="event-media-seeked"><code>seeked</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><a href="#current-playback-position">current playback position</a>が変更された後に、<code data-anolis-xref="dom-media-seeking"><a href="#dom-media-seeking">seeking</a></code>IDL属性がfalseに変更された。

     </td><td>

    </td></tr><tr><td><dfn data-anolis-xref="event-media-ended" id="event-media-ended"><code>ended</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><a href="#media-resource">メディアリソース</a>の終わりに達したため、再生が停止した。

     </td><td><code data-anolis-xref="dom-media-currentTime"><a href="#dom-media-currenttime">currentTime</a></code>は、<a href="#media-resource">メディアリソース</a>の最後に等しく、<code data-anolis-xref="dom-media-ended"><a href="#dom-media-ended">ended</a></code>はtrueである。

   <tbody></td></tr><tr><td><dfn data-anolis-xref="event-media-durationchange" id="event-media-durationchange"><code>durationchange</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-media-duration"><a href="#dom-media-duration">duration</a></code>属性はちょうど更新された。

     </td><td>

    </td></tr><tr><td><dfn data-anolis-xref="event-media-timeupdate" id="event-media-timeupdate"><code>timeupdate</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><a href="#current-playback-position">現在の再生位置</a>が、通常の再生の一部として、または、たとえば不連続的に、特に興味深い方法で変更された。

     </td><td>

    </td></tr><tr><td><dfn data-anolis-xref="event-media-play" id="event-media-play"><code>play</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>要素はもはや一時停止でない。<code data-anolis-xref="dom-media-play"><a href="#dom-media-play">play()</a></code>メソッドが返された後、または<code data-anolis-xref="attr-media-autoplay"><a href="#attr-media-autoplay">autoplay</a></code>属性を開始する再生を起こす際に発火した。

     </td><td><code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>は、新たにfalseである。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-pause" id="event-media-pause"><code>pause</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>要素が一時停止された。<code data-anolis-xref="dom-media-pause"><a href="#dom-media-pause">pause()</a></code>メソッドが返された後に発火した。

     </td><td><code data-anolis-xref="dom-media-paused"><a href="#dom-media-paused">paused</a></code>は、新たにtrueである。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-ratechange" id="event-media-ratechange"><code>ratechange</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-media-defaultPlaybackRate"><a href="#dom-media-defaultplaybackrate"> defaultPlaybackRate</a></code>または<code data-anolis-xref="dom-media-playbackRate"><a href="#dom-media-playbackrate"> playbackRate</a></code>属性が更新されたばかりのいずれか。

     </td><td>

   <tbody></td></tr><tr><td><dfn data-anolis-xref="event-media-resize" id="event-media-resize"><code>resize</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-video-videoWidth"><a href="#dom-video-videowidth">videoWidth</a></code>と<code data-anolis-xref="dom-video-videoWidth"><a href="#dom-video-videowidth">videoWidth</a></code>属性のいずれかまたは両方がちょうど更新されている。

     </td><td><a href="#media-element">メディア要素</a>は<code><a href="#the-video-element">video</a></code>要素である。<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>は<code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>でない。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-volumechange" id="event-media-volumechange"><code>volumechange</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-media-volume"><a href="#dom-media-volume">volume</a></code>属性または<code data-anolis-xref="dom-media-muted"><a href="#dom-media-muted">muted</a></code>属性のいずれかが変更された。関連する属性のセッターが返された後に発火した。

     </td><td>

  </td></tr></table><p><code><a href="#mediacontroller">MediaController</a></code>オブジェクトで次のイベントが発火する：</p>

  <table><thead><tr><th>イベント名

     </th><th>インターフェース

     </th><th>発火条件

   <tbody></th></tr><tr><td><dfn data-anolis-xref="event-MediaController-emptied" id="event-mediacontroller-emptied"><code>emptied</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>すべての<a href="#slaved-media-elements">従属メディア要素</a>は、新たに<code data-anolis-xref="dom-media-HAVE_NOTHING"><a href="#dom-media-have_nothing">HAVE_NOTHING</a></code>以上に設定した<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>をもつか、または<a href="#slaved-media-elements">従属メディア要素</a>がもはや存在しない。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-loadedmetadata" id="event-mediacontroller-loadedmetadata"><code>loadedmetadata</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>すべての<a href="#slaved-media-elements">従属メディア要素</a>の<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が新た<code data-anolis-xref="dom-media-HAVE_METADATA"><a href="#dom-media-have_metadata">HAVE_METADATA</a></code>以上に設定される。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-loadeddata" id="event-mediacontroller-loadeddata"><code>loadeddata</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>すべての<a href="#slaved-media-elements">従属メディア要素</a>の<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が新た<code data-anolis-xref="dom-media-HAVE_CURRENT_DATA"><a href="#dom-media-have_current_data">HAVE_CURRENT_DATA</a></code>以上に設定される。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-canplay" id="event-mediacontroller-canplay"><code>canplay</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>すべての<a href="#slaved-media-elements">従属メディア要素</a>の<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が新た<code data-anolis-xref="dom-media-HAVE_FUTURE_DATA"><a href="#dom-media-have_future_data">HAVE_FUTURE_DATA</a></code>以上に設定される。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-canplaythrough" id="event-mediacontroller-canplaythrough"><code>canplaythrough</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>すべての<a href="#slaved-media-elements">従属メディア要素</a>の<code data-anolis-xref="dom-media-readyState"><a href="#dom-media-readystate">readyState</a></code>が新た<code data-anolis-xref="dom-media-HAVE_ENOUGH_DATA"><a href="#dom-media-have_enough_data">HAVE_ENOUGH_DATA</a></code>以上に設定される。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-playing" id="event-mediacontroller-playing"><code>playing</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code><a href="#mediacontroller">MediaController</a></code>は、もはや<a href="#blocked-media-controller">ブロックメディアコントローラ</a>ではない。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-waiting" id="event-mediacontroller-waiting"><code>waiting</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code><a href="#mediacontroller">MediaController</a></code>は現在、<a href="#blocked-media-controller">ブロックされたメディアコントローラ</a>である。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-ended" id="event-mediacontroller-ended"><code>ended</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>すべての<a href="#slaved-media-elements">従属メディア要素</a>は、新たに<a href="#ended-playback">再生を終了して</a>いる。<code><a href="#mediacontroller">MediaController</a></code>は、すべての<a href="#slaved-media-elements">従属メディア要素</a>の終わりに達した。

   <tbody></td></tr><tr><td><dfn data-anolis-xref="event-MediaController-durationchange" id="event-mediacontroller-durationchange"><code>durationchange</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-MediaController-duration"><a href="#dom-mediacontroller-duration">duration</a></code>属性はちょうど更新された。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-timeupdate" id="event-mediacontroller-timeupdate"><code>timeupdate</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><a href="#media-controller-position">メディアコントローラの位置</a>が変更された。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-play" id="event-mediacontroller-play"><code>play</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-MediaController-paused"><a href="#dom-mediacontroller-paused">paused</a></code>属性が新たにfalseである。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-pause" id="event-mediacontroller-pause"><code>pause</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-MediaController-paused"><a href="#dom-mediacontroller-paused">paused</a></code>属性が新たにtrueである。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-ratechange" id="event-mediacontroller-ratechange"><code>ratechange</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-MediaController-defaultPlaybackRate"><a href="#dom-mediacontroller-defaultplaybackrate">defaultPlaybackRate</a></code>属性または<code data-anolis-xref="dom-MediaController-playbackRate"><a href="#dom-mediacontroller-playbackrate">playbackRate</a></code>属性がちょうど更新されたかのいずれか。

    </td></tr><tr><td><dfn data-anolis-xref="event-MediaController-volumechange" id="event-mediacontroller-volumechange"><code>volumechange</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td><code data-anolis-xref="dom-MediaController-volume"><a href="#dom-mediacontroller-volume">volume</a></code>属性または<code data-anolis-xref="dom-MediaController-muted"><a href="#dom-mediacontroller-muted">muted</a></code>属性がちょうど更新されたかのいずれか。

  </td></tr></table><p><code><a href="#audiotracklist">AudioTrackList</a></code>、<code><a href="#videotracklist">VideoTrackList</a></code>、および<code><a href="#texttracklist">TextTrackList</a></code> オブジェクトで次のイベントが発火する：</p>

  <table><thead><tr><th>イベント名

     </th><th>インターフェース

     </th><th>発火条件

   <tbody></th></tr><tr><td><dfn data-anolis-xref="event-media-change" id="event-media-change"><code>change</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>トラックリストの1つ以上のトラックが有効か無効である。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-addtrack" id="event-media-addtrack"><code>addtrack</code></dfn>

     </td><td><code><a href="#trackevent">TrackEvent</a></code>

     </td><td>トラックはトラックリストに加えられている。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-removetrack" id="event-media-removetrack"><code>removetrack</code></dfn>

     </td><td><code><a href="#trackevent">TrackEvent</a></code>

     </td><td>トラックはトラックリストから削除されている。

  </td></tr></table><p>以下のイベントは、<code><a href="#texttrack">TextTrack</a></code>オブジェクトおよび<code><a href="#the-track-element">track</a></code>要素で発火する：</p>

  <table><thead><tr><th>イベント名

     </th><th>インターフェース

     </th><th>発火条件

   <tbody></th></tr><tr><td><dfn data-anolis-xref="event-media-cuechange" id="event-media-cuechange"><code>cuechange</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>トラック内の1つ以上のキューがアクティブになるか、アクティブで停止している。

  </td></tr></table><p>以下のイベントは、<code><a href="#texttrackcue">TextTrackCue</a></code>オブジェクトで発火する：</p>

  <table><thead><tr><th>イベント名

     </th><th>インターフェース

     </th><th>発火条件

   <tbody></th></tr><tr><td><dfn data-anolis-xref="event-media-enter" id="event-media-enter"><code>enter</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>キューはアクティブになっている。

    </td></tr><tr><td><dfn data-anolis-xref="event-media-exit" id="event-media-exit"><code>exit</code></dfn>

     </td><td><code><a href="infrastructure.html#event">Event</a></code>

     </td><td>キューはアクティブになるのを停止している。

  </td></tr></table><!--ADD-TOPIC:Security--><div class="impl">

  <h5 id="security-and-privacy-considerations"><span class="secno">4.7.14.17 </span>Security and privacy considerations</h5>

  <p>The main security and privacy implications of the <code><a href="#the-video-element">video</a></code> and <code><a href="#the-audio-element">audio</a></code>
  elements come from the ability to embed media cross-origin. There are two directions that threats
  can flow: from hostile content to a victim page, and from a hostile page to victim content.</p>

  <hr><p>If a victim page embeds hostile content, the threat is that the content might contain scripted
  code that attempts to interact with the <code><a href="dom.html#document">Document</a></code> that embeds the content. To avoid
  this, user agents must ensure that there is no access from the content to the embedding page. In
  the case of media content that uses DOM concepts, the embedded content must be treated as if it
  was in its own unrelated <a href="browsers.html#top-level-browsing-context">top-level browsing context</a>.</p>

  <p class="example">For instance, if an SVG animation was embedded in a <code><a href="#the-video-element">video</a></code> element,
  the user agent would not give it access to the DOM of the outer page. From the perspective of
  scripts in the SVG resource, the SVG file would appear to be in a lone top-level browsing context
  with no parent.</p>

  <hr><p>If a hostile page embeds victim content, the threat is that the embedding page could obtain
  information from the content that it would not otherwise have access to. The API does expose some
  information: the existence of the media, its type, its duration, its size, and the performance
  characteristics of its host. Such information is already potentially problematic, but in practice
  the same information can more or less be obtained using the <code><a href="#the-img-element">img</a></code> element, and so it
  has been deemed acceptable.</p>

  <p>However, significantly more sensitive information could be obtained if the user agent further
  exposes metadata within the content such as subtitles or chapter titles. Such information is
  therefore only exposed if the video resource passes a CORS <a href="infrastructure.html#resource-sharing-check">resource sharing check</a>.
  The <code data-anolis-xref="attr-media-crossorigin"><a href="#attr-media-crossorigin">crossorigin</a></code> attribute allows authors to control
  how this check is performed. <a href="references.html#refsFETCH">[FETCH]</a></p>

  <p class="example">Without this restriction, an attacker could trick a user running within a
  corporate network into visiting a site that attempts to load a video from a previously leaked
  location on the corporation's intranet. If such a video included confidential plans for a new
  product, then being able to read the subtitles would present a serious confidentiality breach.</p>

  </div><!--REMOVE-TOPIC:Security-->



  <h5 id="best-practices-for-authors-using-media-elements"><span class="secno">4.7.14.18 </span>Best practices for authors using media elements</h5>

  <p><i>この節は非規範的である。</i></p>

  <p>セットトップボックスや携帯電話などの小型機器上でオーディオおよびビデオを再生するリソースは多くの場合、限られたデバイスのハードウェアリソースによって制限される。たとえば、デバイスは3つの一斉ビデオのみをサポートするかもしれない。このような理由から、要素への参照をすべて削除することに関して非常に慎重であり、かつガーベジコレクションすることによって、または要素の<code data-anolis-xref="attr-media-src"><a href="#attr-media-src">src</a></code>属性と任意の<code><a href="#the-source-element">source</a></code>要素の子孫を削除してから、要素の<code data-anolis-xref="dom-media-load"><a href="#dom-media-load">load()</a></code>メソッドを呼び出ことによってのいずれかで、それらが再生し終わった際、<a data-anolis-xref="media element" href="#media-element">メディア要素</a>が保持するリソースを解放することを推奨する。</p>

  <p>同様に、再生速度が正確に1.0でない場合、ハードウェア、ソフトウェア、またはフォーマットの制限はビデオフレームに欠落や、オーディオに音途切れや無音をもたらすかもしれない。</p>


  <div class="impl">

  <h5 id="best-practices-for-implementors-of-media-elements"><span class="secno">4.7.14.19 </span>Best practices for implementors of media elements</h5>

  <p><i>この節は非規範的である。</i></p>

  <p>How accurately various aspects of the <a href="#media-element">media element</a> API are implemented is
  considered a quality-of-implementation issue.</p>

  <p>For example, when implementing the <code data-anolis-xref="attr-media-buffered">buffered</code> attribute,
  how precise an implementation reports the ranges that have been buffered depends on how carefully
  the user agent inspects the data. Since the API reports ranges as times, but the data is obtained
  in byte streams, a user agent receiving a variable-bit-rate stream might only be able to determine
  precise times by actually decoding all of the data. User agents aren't required to do this,
  however; they can instead return estimates (e.g. based on the average bit rate seen so far) which
  get revised as more information becomes available.</p>

  <p>As a general rule, user agents are urged to be conservative rather than optimistic. For
  example, it would be bad to report that everything had been buffered when it had not.</p>

  <p>Another quality-of-implementation issue would be playing a video backwards when the codec is
  designed only for forward playback (e.g. there aren't many key frames, and they are far apart, and
  the intervening frames only have deltas from the previous frame). User agents could do a poor job,
  e.g. only showing key frames; however, better implementations would do more work and thus do a
  better job, e.g. actually decoding parts of the video forwards, storing the complete frames, and
  then playing the frames backwards.</p>

  <p>Similarly, while implementations are allowed to drop buffered data at any time (there is no
  requirement that a user agent keep all the media data obtained for the lifetime of the media
  element), it is again a quality of implementation issue: user agents with sufficient resources to
  keep all the data around are encouraged to do so, as this allows for a better user experience. For
  example, if the user is watching a live stream, a user agent could allow the user only to view the
  live video; however, a better user agent would buffer everything and allow the user to seek
  through the earlier material, pause it, play it forwards and backwards, etc.</p>

  <p>When multiple tracks are synchronised with a <code><a href="#mediacontroller">MediaController</a></code>, it is possible for
  scripts to add and remove media elements from the <code><a href="#mediacontroller">MediaController</a></code>'s list of
  <a href="#slaved-media-elements">slaved media elements</a>, even while these tracks are playing. How smoothly the media
  plays back in such situations is another quality-of-implementation issue.</p>

  <hr><p>When a <a href="#media-element">media element</a> that is paused is <a data-anolis-xref="remove an element from a
  document" href="infrastructure.html#remove-an-element-from-a-document">removed from a document</a> and not reinserted before the next time the <a href="webappapis.html#event-loop">event
  loop</a> reaches step 1, implementations that are resource constrained are encouraged to take
  that opportunity to release all hardware resources (like video planes, networking resources, and
  data buffers) used by the <a href="#media-element">media element</a>. (User agents still have to keep track of the
  playback position and so forth, though, in case playback is later restarted.)</p>

  </div>


  <h4 id="the-map-element"><span class="secno">4.7.15</span> <dfn><code>map</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dd><a href="dom.html#palpable-content-0">パルパブルコンテンツ</a>。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>が期待される場所。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd><a href="dom.html#transparent">透過的</a>。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-map-name"><a href="#attr-map-name">name</a></code> - <code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code>属性から参照する<a href="#image-map">イメージマップ</a>名 </dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd>どちらのタグも省略不可</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd>なし</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmlmapelement">HTMLMapElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-map-name" href="#dom-map-name">name</a>;
  readonly attribute <a href="infrastructure.html#htmlcollection">HTMLCollection</a> <a data-anolis-xref="dom-map-areas" href="#dom-map-areas">areas</a>;
  readonly attribute <a href="infrastructure.html#htmlcollection">HTMLCollection</a> <a data-anolis-xref="dom-map-images" href="#dom-map-images">images</a>;
};</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-map-element">map</a></code>要素は、<code><a href="#the-img-element">img</a></code>要素および任意の<code><a href="#the-area-element">area</a></code>要素の子孫と連動して、<a href="#image-map">イメージマップ</a>を定義する。要素は、その子を<a href="dom.html#represents">表す</a>。</p>

  <p><dfn data-anolis-xref="attr-map-name" id="attr-map-name"><code>name</code></dfn>属性は、マップを参照できるようマップに名前を与える。属性は存在しなければならず、<a data-anolis-xref="space character" href="infrastructure.html#space-character">空白文字</a>なしで非空白の値を持たなければならない。<code data-anolis-xref="attr-map-name"><a href="#attr-map-name">name</a></code>属性の値は、同じ文書で別の<code><a href="#the-map-element">map</a></code>要素の<code data-anolis-xref="attr-map-name"><a href="#attr-map-name">name</a></code>属性値とマッチする<a data-anolis-xref="compatibility
  caseless" href="infrastructure.html#compatibility-caseless">互換性大文字・小文字不区別</a>であってはならない。<code data-anolis-xref="attr-id"><a href="dom.html#the-id-attribute">id</a></code>属性がまた指定される場合、両方の属性が同じ値を持たなければならない。</p><!--TOPIC:DOM APIs-->


  <dl class="domintro"><dt><var data-anolis-xref="">map</var> . <code data-anolis-xref="dom-map-areas"><a href="#dom-map-areas">areas</a></code></dt>

   <dd>

    <p><code><a href="#the-map-element">map</a></code>の<code><a href="#the-area-element">area</a></code>要素の<code><a href="infrastructure.html#htmlcollection">HTMLCollection</a></code>を返す。</p>

   </dd>

   <dt><var data-anolis-xref="">map</var> . <code data-anolis-xref="dom-map-images"><a href="#dom-map-images">images</a></code></dt>

   <dd>

    <p><code><a href="#the-map-element">map</a></code>を使用する<code><a href="#the-img-element">img</a></code>および<code><a href="#the-object-element">object</a></code>要素の<code><a href="infrastructure.html#htmlcollection">HTMLCollection</a></code>を返す。</p>

   </dd>

  </dl><div class="impl">

  <p>The <dfn data-anolis-xref="dom-map-areas" id="dom-map-areas"><code>areas</code></dfn> attribute must return an
  <code><a href="infrastructure.html#htmlcollection">HTMLCollection</a></code> rooted at the <code><a href="#the-map-element">map</a></code> element, whose filter matches only
  <code><a href="#the-area-element">area</a></code> elements.</p>

  <p>The <dfn data-anolis-xref="dom-map-images" id="dom-map-images"><code>images</code></dfn> attribute must return an
  <code><a href="infrastructure.html#htmlcollection">HTMLCollection</a></code> rooted at the <code><a href="dom.html#document">Document</a></code> node, whose filter matches only
  <code><a href="#the-img-element">img</a></code> and <code><a href="#the-object-element">object</a></code> elements that are associated with this <code><a href="#the-map-element">map</a></code>
  element according to the <a href="#image-map">image map</a> processing model.</p>

  <p>The IDL attribute <dfn data-anolis-xref="dom-map-name" id="dom-map-name"><code>name</code></dfn> must <a href="infrastructure.html#reflect">reflect</a>
  the content attribute of the same name.</p>

  </div><!--TOPIC:HTML-->


  <div class="example">

   <p>イメージマップは、メンテナンスを容易にするために、ページ上の他のコンテンツと組み合わせて定義できる。この例は、ページの上部に、イメージマップと下部のテキストリンクの対応するセットを使用したページである。</p>

   <pre>&lt;!DOCTYPE HTML&gt;
&lt;TITLE&gt;Babies™: Toys&lt;/TITLE&gt;
&lt;HEADER&gt;
 &lt;H1&gt;Toys&lt;/H1&gt;
 &lt;IMG SRC="/images/menu.gif"
      ALT="Babies™ navigation menu. Select a department to go to its page."
      USEMAP="#NAV"&gt;
&lt;/HEADER&gt;
 ...
&lt;FOOTER&gt;
 &lt;MAP NAME="NAV"&gt;
  &lt;P&gt;
   &lt;A HREF="/clothes/"&gt;Clothes&lt;/A&gt;
   &lt;AREA ALT="Clothes" COORDS="0,0,100,50" HREF="/clothes/"&gt; |
   &lt;A HREF="/toys/"&gt;Toys&lt;/A&gt;
   &lt;AREA ALT="Toys" COORDS="100,0,200,50" HREF="/toys/"&gt; |
   &lt;A HREF="/food/"&gt;Food&lt;/A&gt;
   &lt;AREA ALT="Food" COORDS="200,0,300,50" HREF="/food/"&gt; |
   &lt;A HREF="/books/"&gt;Books&lt;/A&gt;
   &lt;AREA ALT="Books" COORDS="300,0,400,50" HREF="/books/"&gt;
 &lt;/MAP&gt;
&lt;/FOOTER&gt;</pre>

  </div>



  <h4 id="the-area-element"><span class="secno">4.7.16</span> <dfn><code>area</code></dfn>要素</h4>

  <dl class="element"><dt><a data-anolis-xref="concept-element-categories" href="dom.html#concept-element-categories">カテゴリ</a>：</dt>
   <dd><a href="dom.html#flow-content-1">フローコンテンツ</a>。</dd>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>。</dd>
   <dt><a data-anolis-xref="concept-element-contexts" href="dom.html#concept-element-contexts">この要素を使用できるコンテキスト</a>：</dt>
   <dd><a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>が期待される場所、ただし先祖<code><a href="#the-map-element">map</a></code>要素または先祖<code><a href="scripting-1.html#the-template-element">template</a></code>要素が存在する場合のみを除く。</dd>
   <dt><a data-anolis-xref="concept-element-content-model" href="dom.html#concept-element-content-model">コンテンツモデル</a>：</dt>
   <dd>空。</dd>
   <dt><a data-anolis-xref="concept-element-attributes" href="dom.html#concept-element-attributes">コンテンツ属性</a>：</dt>
   <dd><a href="dom.html#global-attributes">グローバル属性</a></dd>
   <dd><code data-anolis-xref="attr-area-alt"><a href="#attr-area-alt">alt</a></code> - 画像が利用不可の際使用する置換テキスト</dd>
   <dd><code data-anolis-xref="attr-area-coords"><a href="#attr-area-coords">coords</a></code> - <a href="#image-map">イメージマップ</a>内に作成する図形の座標</dd>
   <dd><code data-anolis-xref="attr-hyperlink-download"><a href="links.html#attr-hyperlink-download">download</a></code> - リソースをナビゲートする代わりにダウンロードし、その場合リソースのファイル名にするかどうか</dd>
   <dd><code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code> — <a href="links.html#hyperlink">ハイパーリンク</a>のアドレス</dd>
   <dd><code data-anolis-xref="attr-hyperlink-hreflang"><a href="links.html#attr-hyperlink-hreflang">hreflang</a></code> — リンクされたリソースの言語</dd><!--PING-->

   <dd><code data-anolis-xref="attr-hyperlink-rel"><a href="links.html#attr-hyperlink-rel">rel</a></code> — ハイパーリンクと宛先のリソースを含む文書の関係</dd>
   <dd><code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> - <a href="#image-map">イメージマップ</a>内に作成する図形の種類</dd>
   <dd><code data-anolis-xref="attr-hyperlink-target"><a href="links.html#attr-hyperlink-target">target</a></code> -<a href="links.html#hyperlink">ハイパーリンク</a><a data-anolis-xref="navigate" href="browsers.html#navigate">ナビゲーション</a>に対する<a href="browsers.html#browsing-context">ブラウジングコンテキスト</a></dd>
   <dd><code data-anolis-xref="attr-hyperlink-type"><a href="links.html#attr-hyperlink-type">type</a></code> — 参照されるリソースタイプのヒント</dd>
   <dt><a data-anolis-xref="concept-element-tag-omission" href="dom.html#concept-element-tag-omission">text/htmlにおけるタグ省略</a>：</dt>
   <dd><a data-anolis-xref="syntax-end-tag" href="syntax.html#syntax-end-tag">終了タグ</a>なし</dd>
   <dt>許可される<a href="dom.html#aria-role-attribute">ARIAロール属性</a>値：</dt>
   <dd><a href="dom.html#index-aria-link"><code title="">link</code></a> （デフォルト - <a href="dom.html#aria-usage-note"><em>設定しない</em></a>）。</dd>
   <dt>許可される<a href="dom.html#state-and-property-attributes">ARIAステートおよびプロパティー</a>：</dt>
   <dd><a href="dom.html#index-aria-global">グローバルaria-* 属性</a></dd>
   <dd><a href="dom.html#allowed-aria-roles,-states-and-properties">許可されるロールで受け入れ可能な</a>任意の<code title="">aria-*</code>属性。</dd>
   <dt><a data-anolis-xref="concept-element-dom" href="dom.html#concept-element-dom">DOMインターフェース</a>：</dt><!--TOPIC:DOM APIs-->
   <dd>
<pre class="idl">interface <dfn id="htmlareaelement">HTMLAreaElement</dfn> : <a href="dom.html#htmlelement">HTMLElement</a> {
           attribute DOMString <a data-anolis-xref="dom-area-alt" href="#dom-area-alt">alt</a>;
           attribute DOMString <a data-anolis-xref="dom-area-coords" href="#dom-area-coords">coords</a>;
           attribute DOMString <a data-anolis-xref="dom-area-shape" href="#dom-area-shape">shape</a>;
           attribute DOMString <a data-anolis-xref="dom-area-target" href="#dom-area-target">target</a>;
           attribute DOMString <a data-anolis-xref="dom-area-download" href="#dom-area-download">download</a>;
<!--PING-->
           attribute DOMString <a data-anolis-xref="dom-area-rel" href="#dom-area-rel">rel</a>;
  readonly attribute <a href="infrastructure.html#domtokenlist">DOMTokenList</a> <a data-anolis-xref="dom-area-relList" href="#dom-area-rellist">relList</a>;
           attribute DOMString <a data-anolis-xref="dom-area-hreflang" href="#dom-area-hreflang">hreflang</a>;
           attribute DOMString <a data-anolis-xref="dom-area-type" href="#dom-area-type">type</a>;
};
<a href="#htmlareaelement">HTMLAreaElement</a> implements <a href="infrastructure.html#urlutils">URLUtils</a>;</pre>
   </dd>
  </dl><!--TOPIC:HTML--><p><code><a href="#the-area-element">area</a></code>要素は、テキストと<a href="#image-map">イメージマップ</a>で領域に対応をもつハイパーリンク、またはイメージマップ上の不感領域のいずれかを<a href="dom.html#represents">表す</a>。</p>

  <p>親ノードとともに<code><a href="#the-area-element">area</a></code>要素は、<code><a href="#the-map-element">map</a></code>要素の祖先または<code><a href="scripting-1.html#the-template-element">template</a></code>要素の祖先を持たなければならない。</p>

  <p><code><a href="#the-area-element">area</a></code>要素が<code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code>属性を持つ場合、<code><a href="#the-area-element">area</a></code>要素は<a href="links.html#hyperlink">ハイパーリンク</a>を表す。この場合、<dfn data-anolis-xref="attr-area-alt" id="attr-area-alt"><code>alt</code></dfn>属性が存在しなければならない。この属性は、ハイパーリンクのテキストを指定する。属性値は、<a href="#image-map">イメージマップ</a>の他のハイパーリンクに指定されるテキストを伴い、かつ画像の代替テキストを伴うが、画像なしで提示された場合、テキストでなければならず、テキストなしだが画像に適用される形状を伴うような場合、ハイパーリンクとして同じ選択の種類をユーザーに提供しなければならない。同じリソースを指す<a href="#image-map">イメージマップ</a>と非空白の<code data-anolis-xref="attr-area-alt"><a href="#attr-area-alt">alt</a></code>属性を持つ別の<code><a href="#the-area-element">area</a></code>要素が存在する場合、<code data-anolis-xref="attr-area-alt"><a href="#attr-area-alt">alt</a></code>属性は空白のままであってもよい。</p>

  <p><code><a href="#the-area-element">area</a></code>要素が<code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code>属性を持たない場合、その要素によって表される領域を選択できず、<code data-anolis-xref="attr-area-alt"><a href="#attr-area-alt">alt</a></code>属性を省略しなければならない。</p>

  <p>どちらの場合も、<code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code>と<code data-anolis-xref="attr-area-coords"><a href="#attr-area-coords">coords</a></code>属性は領域を指定する。</p>

  <p><dfn data-anolis-xref="attr-area-shape" id="attr-area-shape"><code>shape</code></dfn>属性は、<a href="infrastructure.html#enumerated-attribute">列挙属性</a>である。以下の表は、この属性に対して定義されたキーワードを列挙する。キーワードとともにその行の最初のセルに与えられた状態は、これらキーワードが対応する状態を与える。<span class="impl">Some of the keywords are non-conforming, as noted in the last column.</span></p>

  <table><thead><tr><th>状態
     </th><th>キーワード
     </th><th class="impl">注
   <tbody></th></tr><tr><td rowspan="2"><a data-anolis-xref="attr-area-shape-circle" href="#attr-area-shape-circle">Circle state</a>
     </td><td><dfn data-anolis-xref="attr-area-shape-keyword-circle" id="attr-area-shape-keyword-circle"><code>circle</code></dfn>
     </td><td class="impl">
    </td></tr><tr><td class="impl"><dfn data-anolis-xref="attr-area-shape-keyword-circ" id="attr-area-shape-keyword-circ"><code>circ</code></dfn>
     </td><td class="impl">Non-conforming
    
    </td></tr><tr><td><a data-anolis-xref="attr-area-shape-default" href="#attr-area-shape-default">Default state</a>
     </td><td><dfn data-anolis-xref="attr-area-shape-keyword-default" id="attr-area-shape-keyword-default"><code>default</code></dfn>
     </td><td class="impl">
    </td></tr><tr><td rowspan="2"><a data-anolis-xref="attr-area-shape-poly" href="#attr-area-shape-poly">Polygon state</a>
     </td><td><dfn data-anolis-xref="attr-area-shape-keyword-poly" id="attr-area-shape-keyword-poly"><code>poly</code></dfn>
     </td><td class="impl">
    </td></tr><tr><td class="impl"><dfn data-anolis-xref="attr-area-shape-keyword-polygon" id="attr-area-shape-keyword-polygon"><code>polygon</code></dfn>
     </td><td class="impl">Non-conforming
    
    </td></tr><tr><td rowspan="2"><a data-anolis-xref="attr-area-shape-rect" href="#attr-area-shape-rect">Rectangle state</a>
     </td><td><dfn data-anolis-xref="attr-area-shape-keyword-rect" id="attr-area-shape-keyword-rect"><code>rect</code></dfn>
     </td><td class="impl">
    </td></tr><tr><td class="impl"><dfn data-anolis-xref="attr-area-shape-keyword-rectangle" id="attr-area-shape-keyword-rectangle"><code>rectangle</code></dfn>
     </td><td class="impl">Non-conforming
  
  </td></tr></table><p>属性は省略してもよい。<i>欠損値のデフォルト</i>は、<a data-anolis-xref="attr-area-shape-rect" href="#attr-area-shape-rect">rectangle</a>状態である。</p>

  <p><dfn data-anolis-xref="attr-area-coords" id="attr-area-coords"><code>coords</code></dfn>属性が指定される場合、<a href="infrastructure.html#valid-list-of-integers">整数の妥当なリスト</a>を含まなければならない。この属性は、<code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code>属性によって記述された図形の座標を与える。<span class="impl">The processing for this attribute is described as part of the <a href="#image-map">image map</a> processing model.</span></p><!-- v2: It was suggested by John S. Urban that coords should support percentages as well as
  pixels, so that one could use the same image map for images of various sizes. -->

  

  <p><dfn data-anolis-xref="attr-area-shape-circle" id="attr-area-shape-circle">circle state</dfn>において、<code><a href="#the-area-element">area</a></code>要素は、最後の整数は非負でなければならない、3つの整数とともに、存在する<code data-anolis-xref="attr-area-coords"><a href="#attr-area-coords">coords</a></code>属性を持たなければならない。最初の整数は画像の左端から円の中心までのCSSピクセル単位距離でなければならず、2番目の整数は画像の上端から円の中心までのCSSピクセル単位距離でなければならず、3番目の整数はCSSピクセル単位距離で円の半径でなければならない。</p>

  <p><dfn data-anolis-xref="attr-area-shape-default" id="attr-area-shape-default">default state</dfn>状態において、<code><a href="#the-area-element">area</a></code>要素は<code data-anolis-xref="attr-area-coords"><a href="#attr-area-coords">coords</a></code>属性を持ってはならない。（領域は全体の画像である。）</p>

  <p><dfn data-anolis-xref="attr-area-shape-poly" id="attr-area-shape-poly">polygon state</dfn>において、<code><a href="#the-area-element">area</a></code>要素は少なくとも6つの整数をもつ<code data-anolis-xref="attr-area-coords"><a href="#attr-area-coords">coords</a></code>属性を持たなければならず、その整数は偶数個でなければならない。整数の各ペアは、CSSピクセルでそれぞれ画像の左からおよび上からの距離として指定された座標を表さなければならず、順に、すべての座標はポリゴンの点を表さなければならない。</p>

  <p><dfn data-anolis-xref="attr-area-shape-rect" id="attr-area-shape-rect">rectangle state</dfn>において、<code><a href="#the-area-element">area</a></code>要素は正確に4つの整数をもつ<code data-anolis-xref="attr-area-coords"><a href="#attr-area-coords">coords</a></code>属性を持たなければならない。1番目の整数は3番目の整数未満でなければならず、2番目の整数は4番目の整数未満でなければならない。4点は、それぞれすべてCSSピクセルで、矩形の左側から画像の左辺までの距離、上側から上辺までの距離、左側から左辺までの距離、下側から上辺までの距離を表さなければならない。</p>

  <div class="impl">

  <p>When user agents allow users to <a data-anolis-xref="following hyperlinks" href="links.html#following-hyperlinks">follow hyperlinks</a> or
  <a data-anolis-xref="downloading hyperlinks" href="links.html#downloading-hyperlinks">download hyperlinks</a> created using the
  <code><a href="#the-area-element">area</a></code> element, as described in the next section, the <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code>, <code data-anolis-xref="attr-hyperlink-target"><a href="links.html#attr-hyperlink-target">target</a></code>,
  <code data-anolis-xref="attr-hyperlink-download"><a href="links.html#attr-hyperlink-download">download</a></code>, and

<!--PING-->
  
  attributes decide how the link is followed. The <code data-anolis-xref="attr-hyperlink-rel"><a href="links.html#attr-hyperlink-rel">rel</a></code>, <code data-anolis-xref="attr-hyperlink-hreflang"><a href="links.html#attr-hyperlink-hreflang">hreflang</a></code>, and <code data-anolis-xref="attr-hyperlink-type"><a href="links.html#attr-hyperlink-type">type</a></code>
  attributes may be used to indicate to the user the likely nature of the target resource before the
  user follows the link.</p>

  </div>

  <p>  
<!--PING-->
  <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code>属性が存在しない場合、<code data-anolis-xref="attr-hyperlink-rel"><a href="links.html#attr-hyperlink-rel">target</a></code>、<code data-anolis-xref="attr-hyperlink-hreflang"><a href="links.html#attr-hyperlink-hreflang">hreflang</a></code>、および<code data-anolis-xref="attr-hyperlink-type"><a href="links.html#attr-hyperlink-type">type</a></code>属性は省略しなければならない。</p>

  <p><code><a href="#the-area-element">area</a></code>要素で<code data-anolis-xref="attr-itemprop">itemprop</code>が指定される場合、<code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code>属性も指定されなければならない。</p>

  <div class="impl">

  <p>The <a href="editing.html#activation-behavior">activation behavior</a> of <code><a href="#the-area-element">area</a></code> elements is to run the following
  steps:</p>

  <ol><!-- c.f. <a>'s similar section --><li><p>If the <code><a href="#the-area-element">area</a></code> element's <code><a href="dom.html#document">Document</a></code> is not <a href="browsers.html#fully-active">fully active</a>,
   then abort these steps.</li>

   <li>

    <p>If the <code><a href="#the-area-element">area</a></code> element has a <code data-anolis-xref="attr-hyperlink-download"><a href="links.html#attr-hyperlink-download">download</a></code>
    attribute and the algorithm is not <a href="browsers.html#allowed-to-show-a-popup">allowed to show a popup</a>, or the element's <code data-anolis-xref="attr-hyperlink-target"><a href="links.html#attr-hyperlink-target">target</a></code> attribute is present and applying <a href="browsers.html#the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name">the rules
    for choosing a browsing context given a browsing context name</a>, using the value of the
    <code data-anolis-xref="attr-hyperlink-target"><a href="links.html#attr-hyperlink-target">target</a></code> attribute as the browsing context name, would
    result in there not being a chosen browsing context, then run these substeps:</p>

    <ol><li><p>If there is an <a href="webappapis.html#entry-settings-object">entry settings object</a>, throw an
     <code><a href="infrastructure.html#invalidaccesserror">InvalidAccessError</a></code> exception.</li>

     <li><p>Abort these steps without following the hyperlink.</li>

    </ol></li>

   <li><p>Otherwise, the user agent must <a data-anolis-xref="following hyperlinks" href="links.html#following-hyperlinks">follow the
   hyperlink</a> or <a data-anolis-xref="downloading hyperlinks" href="links.html#downloading-hyperlinks">download the hyperlink</a> created
   by the <code><a href="#the-area-element">area</a></code> element, if any, and as determined by the <code data-anolis-xref="attr-hyperlink-download"><a href="links.html#attr-hyperlink-download">download</a></code> attribute and any expressed user
   preference.</li>

  </ol><p>The IDL attributes <dfn data-anolis-xref="dom-area-alt" id="dom-area-alt"><code>alt</code></dfn>, <dfn data-anolis-xref="dom-area-coords" id="dom-area-coords"><code>coords</code></dfn>, <dfn data-anolis-xref="dom-area-target" id="dom-area-target"><code>target</code></dfn>, <dfn data-anolis-xref="dom-area-download" id="dom-area-download"><code>download</code></dfn>,

<!--PING-->
  <dfn data-anolis-xref="dom-area-rel" id="dom-area-rel"><code>rel</code></dfn>,
  <dfn data-anolis-xref="dom-area-hreflang" id="dom-area-hreflang"><code>hreflang</code></dfn>, and <dfn data-anolis-xref="dom-area-type" id="dom-area-type"><code>type</code></dfn>, each must <a href="infrastructure.html#reflect">reflect</a> the respective
  content attributes of the same name.</p>

  <p>The IDL attribute <dfn data-anolis-xref="dom-area-shape" id="dom-area-shape"><code>shape</code></dfn> must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> content attribute.</p>

  <p>The IDL attribute <dfn data-anolis-xref="dom-area-rellist" id="dom-area-rellist"><code>relList</code></dfn> must
  <a href="infrastructure.html#reflect">reflect</a> the <code data-anolis-xref="attr-hyperlink-rel"><a href="links.html#attr-hyperlink-rel">rel</a></code> content attribute.</p>

  <hr><!-- concept-uu --><p>The <code><a href="#the-area-element">area</a></code> element also supports the <code><a href="infrastructure.html#urlutils">URLUtils</a></code> interface. <a href="references.html#refsURL">[URL]</a></p>

  <p>When the element is created, and whenever the element's <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code> content attribute is set, changed, or removed, the user
  agent must invoke the element's <code><a href="infrastructure.html#urlutils">URLUtils</a></code> interface's <a data-anolis-xref="concept-uu-set-the-input" href="infrastructure.html#concept-uu-set-the-input">set the input</a> algorithm with the value of the <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code> content attribute, if any, or the empty string otherwise,
  as the given value.</p>

  <p>The element's <code><a href="infrastructure.html#urlutils">URLUtils</a></code> interface's <a data-anolis-xref="concept-uu-get-the-base" href="infrastructure.html#concept-uu-get-the-base">get the
  base</a> algorithm must simply return <a href="infrastructure.html#the-element's-base-url">the element's base URL</a>.</p>

  <p>The element's <code><a href="infrastructure.html#urlutils">URLUtils</a></code> interface's <a data-anolis-xref="concept-uu-query-encoding" href="infrastructure.html#concept-uu-query-encoding">query
  encoding</a> is the <a href="infrastructure.html#document's-character-encoding">document's character encoding</a>.</p>

  <p>When the element's <code><a href="infrastructure.html#urlutils">URLUtils</a></code> interface invokes its <a data-anolis-xref="concept-uu-update" href="infrastructure.html#concept-uu-update">update steps</a> with a string <var data-anolis-xref="">value</var>, the user
  agent must set the element's <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code> content attribute to
  the string <var data-anolis-xref="">value</var>.</p>

  </div>



  <h4 id="image-maps"><span class="secno">4.7.17</span> イメージマップ</h4><!-- TESTS
  http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C%21DOCTYPE%20html%3E%0A%3Cimg%20src%3D%22http%3A//hixie.ch/resources/images/smallcats%22%20usemap%3D%23a%20onclick%3Dw%28%27img%27%29%3E%0A%3Cmap%20name%3Da%3E%0A%20%3Carea%20onclick%3Dw%28%271%27%29%20coords%3D%270%25%200%25%20100%25%20100%25%27%20href%3Djavascript%3A%3E%0A%3C/map%3E
  http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C%21DOCTYPE%20html%3E%0A%3Cbody%20onfocus%3D%22w%28document.activeElement.tagName%29%22%3E%0A%3Cimg%20src%3D%22http%3A//hixie.ch/resources/images/smallcats%22%20usemap%3D%23a%20onclick%3Dw%28%27img%27%29%20onfocus%3D%22w%28document.activeElement.tagName%29%22%3E%0A%3Cimg%20src%3D%22http%3A//hixie.ch/resources/images/sample%22%20usemap%3D%23a%20onclick%3Dw%28%27img%27%29%20onfocus%3D%22w%28document.activeElement.tagName%29%22%3E%0A%3Cmap%20name%3Da%20onfocus%3D%22w%28document.activeElement.tagName%29%22%3E%0A%20%3Carea%20onclick%3Dw%28%271%27%29%20coords%3D%270%200%2050%2050%27%20href%3Djavascript%3A%20onfocus%3D%22w%28document.activeElement.tagName%29%22%3E%0A%3C/map%3E%0A%3Cscript%3E%0A%20var%20x%20%3D%20document.getElementsByTagName%28%27img%27%29%5B0%5D%3B%0A%20x.parentNode.appendChild%28x%29%3B%0A%20document.getElementsByTagName%28%27area%27%29%5B0%5D.focus%28%29%3B%0A%3C/script%3E
  http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C%21DOCTYPE%20html%3Ex%3Cmap%3E%3Carea%20shape%3Dpolyg%20coords%3D%221%2C2%203%22%3E%3C/map%3E%0A%3Cscript%3Ex%20%3D%20document.getElementsByTagName%28%27area%27%29%5B0%5D%3B%20w%28x.shape%20+%20%27%20%27%20+%20x.coords%29%3C/script%3E
  http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C%21DOCTYPE%20html%3E%0D%0A%3Cp%3E%3Cimg%20src%3D%22http%3A//hixie.ch/resources/images/astrophy/128%22%20usemap%3D%23a%3E%0D%0A%3Cmap%20name%3Da%3E%3Carea%20shape%3Dcirc%20coords%3D%2220%2C20%2C10%25%22%20href%3D%23%3E%3Carea%20shape%3Dcirc%20coords%3D%2220%2C20%2C10%22%20href%3D%23%3E%3C/map%3E%0D%0A%3Cscript%3Edocument.write%28document.getElementsByTagName%28%27area%27%29%5B0%5D.coords%29%3C/script%3E
  -->

  

  <div class="impl">

  <h5 id="authoring"><span class="secno">4.7.17.1 </span>Authoring</h5>

  </div>

  <p><dfn id="image-map">イメージマップ</dfn>は、<a data-anolis-xref="hyperlink" href="links.html#hyperlink">ハイパーリンク</a>に関連付けられるような画像で幾何学的な領域を可能にする。</p>

  <p><code><a href="#the-img-element">img</a></code>要素や画像を表す<code><a href="#the-object-element">object</a></code>要素の形式において、画像は、<code><a href="#the-img-element">img</a></code>や<code><a href="#the-object-element">object</a></code>要素上で<dfn data-anolis-xref="attr-hyperlink-usemap" id="attr-hyperlink-usemap"><code>usemap</code></dfn>属性を指定することにより（<code><a href="#the-map-element">map</a></code>要素の形式で）イメージマップに関連付けてもよい。<code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code>属性が指定される場合、<code><a href="#the-map-element">map</a></code>要素に<a href="infrastructure.html#valid-hash-name-reference">妥当なハッシュ名の参照</a>でなければならない。</p>

  <div class="example">

   <p>次のような画像を考えてみよう：</p>

   <p><img alt="A line with four shapes in it, equally spaced: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star." height="150" src="http://www.w3.org/TR/html5/images/sample-usemap.png" width="600"></p>

   <p>色付きの領域のみをクリック可能にしたい場合、次のようにするだろう：</p>

   <pre>&lt;p&gt;
 Please select a shape:
 &lt;img src="shapes.png" usemap="#shapes"
      alt="Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star."&gt;
 &lt;map name="shapes"&gt;
  &lt;area shape=rect coords="50,50,100,100"&gt; &lt;!-- the hole in the red box --&gt;
  &lt;area shape=rect coords="25,25,125,125" href="red.html" alt="Red box."&gt;
  &lt;area shape=circle coords="200,75,50" href="green.html" alt="Green circle."&gt;
  &lt;area shape=poly coords="325,25,262,125,388,125" href="blue.html" alt="Blue triangle."&gt;
  &lt;area shape=poly coords="450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60"
        href="yellow.html" alt="Yellow star."&gt;
 &lt;/map&gt;
&lt;/p&gt;</pre>

  </div>

  <div class="impl">

  <h5 id="processing-model-0"><span class="secno">4.7.17.2 </span>Processing model</h5>

  <p>If an <code><a href="#the-img-element">img</a></code> element or an <code><a href="#the-object-element">object</a></code> element representing an image has a
  <code data-anolis-xref="attr-hyperlink-usemap"><a href="#attr-hyperlink-usemap">usemap</a></code> attribute specified, user agents must process it
  as follows:</p>

  <ol><li><p>First, <a href="infrastructure.html#rules-for-parsing-a-hash-name-reference">rules for parsing a hash-name reference</a> to a <code><a href="#the-map-element">map</a></code> element
   must be followed. This will return either an element (the <var data-anolis-xref="">map</var>) or
   null.</li>

   <li><p>If that returned null, then abort these steps. The image is not associated with an image
   map after all.</li>

   <li><p>Otherwise, the user agent must collect all the <code><a href="#the-area-element">area</a></code> elements that are
   descendants of the <var data-anolis-xref="">map</var>. Let those be the <var data-anolis-xref="">areas</var>.</li>

  </ol><p>Having obtained the list of <code><a href="#the-area-element">area</a></code> elements that form the image map (the <var data-anolis-xref="">areas</var>), interactive user agents must process the list in one of two ways.</p>

  <p>If the user agent intends to show the text that the <code><a href="#the-img-element">img</a></code> element represents, then
  it must use the following steps.</p>

  <p class="note">In user agents that do not support images, or that have images disabled,
  <code><a href="#the-object-element">object</a></code> elements cannot represent images, and thus this section never applies (the
  <a href="dom.html#fallback-content">fallback content</a> is shown instead). The following steps therefore only apply to
  <code><a href="#the-img-element">img</a></code> elements.</p>

  <ol><li><p>Remove all the <code><a href="#the-area-element">area</a></code> elements in <var data-anolis-xref="">areas</var> that have no <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code> attribute.</li>

   <li><p>Remove all the <code><a href="#the-area-element">area</a></code> elements in <var data-anolis-xref="">areas</var> that have no <code data-anolis-xref="attr-area-alt"><a href="#attr-area-alt">alt</a></code> attribute, or whose <code data-anolis-xref="attr-area-alt"><a href="#attr-area-alt">alt</a></code>
   attribute's value is the empty string, <em>if</em> there is another <code><a href="#the-area-element">area</a></code> element in
   <var data-anolis-xref="">areas</var> with the same value in the <code data-anolis-xref="attr-hyperlink-href"><a href="links.html#attr-hyperlink-href">href</a></code> attribute and with a non-empty <code data-anolis-xref="attr-area-alt"><a href="#attr-area-alt">alt</a></code> attribute.</li>

   <li><p>Each remaining <code><a href="#the-area-element">area</a></code> element in <var data-anolis-xref="">areas</var> represents a
   <a href="links.html#hyperlink">hyperlink</a>. Those hyperlinks should all be made available to the user in a manner
   associated with the text of the <code><a href="#the-img-element">img</a></code>.</p>

   <p>In this context, user agents may represent <code><a href="#the-area-element">area</a></code> and <code><a href="#the-img-element">img</a></code> elements
   with no specified <code data-anolis-xref="">alt</code> attributes, or whose <code data-anolis-xref="">alt</code>
   attributes are the empty string or some other non-visible text, in a user-agent-defined fashion
   intended to indicate the lack of suitable author-provided text.</li>

  </ol><p>If the user agent intends to show the image and allow interaction with the image to select
  hyperlinks, then the image must be associated with a set of layered shapes, taken from the
  <code><a href="#the-area-element">area</a></code> elements in <var data-anolis-xref="">areas</var>, in reverse tree order (so the last
  specified <code><a href="#the-area-element">area</a></code> element in the <var data-anolis-xref="">map</var> is the bottom-most shape, and
  the first element in the <var data-anolis-xref="">map</var>, in tree order, is the top-most shape).</p>

  <p>Each <code><a href="#the-area-element">area</a></code> element in <var data-anolis-xref="">areas</var> must be processed as follows to
  obtain a shape to layer onto the image:</p>

  <ol><li><p>Find the state that the element's <code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> attribute
   represents.</li>

   <li><p>Use the <a href="infrastructure.html#rules-for-parsing-a-list-of-integers">rules for parsing a list of integers</a> to parse the element's <code data-anolis-xref="attr-area-coords"><a href="#attr-area-coords">coords</a></code> attribute, if it is present, and let the result be the
   <var data-anolis-xref="">coords</var> list. If the attribute is absent, let the <var data-anolis-xref="">coords</var>
   list be the empty list.</li>

   <li>

    <p>If the number of items in the <var data-anolis-xref="">coords</var> list is less than the minimum number
    given for the <code><a href="#the-area-element">area</a></code> element's current state, as per the following table, then the
    shape is empty; abort these steps.</p>

    <table><thead><tr><th>状態
       </th><th>Minimum number of items
     
     <tbody></th></tr><tr><td><a data-anolis-xref="attr-area-shape-circle" href="#attr-area-shape-circle">Circle state</a>
       </td><td>3
      
      </td></tr><tr><td><a data-anolis-xref="attr-area-shape-default" href="#attr-area-shape-default">Default state</a>
       </td><td>0
      
      </td></tr><tr><td><a data-anolis-xref="attr-area-shape-poly" href="#attr-area-shape-poly">Polygon state</a>
       </td><td>6
      
      </td></tr><tr><td><a data-anolis-xref="attr-area-shape-rect" href="#attr-area-shape-rect">Rectangle state</a>
       </td><td>4
    
    </td></tr></table></li>

   <li>

    <p>Check for excess items in the <var data-anolis-xref="">coords</var> list as per the entry in the
    following list corresponding to the <code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> attribute's
    state:</p>

    <dl class="switch"><dt><a data-anolis-xref="attr-area-shape-circle" href="#attr-area-shape-circle">Circle state</a></dt>
     <dd>Drop any items in the list beyond the third.</dd>
     <dt><a data-anolis-xref="attr-area-shape-default" href="#attr-area-shape-default">Default state</a></dt>
     <dd>Drop all items in the list.</dd>
     <dt><a data-anolis-xref="attr-area-shape-poly" href="#attr-area-shape-poly">Polygon state</a></dt>
     <dd>Drop the last item if there's an odd number of items.</dd>
     <dt><a data-anolis-xref="attr-area-shape-rect" href="#attr-area-shape-rect">Rectangle state</a></dt>
     <dd>Drop any items in the list beyond the fourth.</dd>
    </dl></li>

   <li><p>If the <code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> attribute represents the <a data-anolis-xref="attr-area-shape-rect" href="#attr-area-shape-rect">rectangle state</a>, and the first number in the list is
   numerically less than the third number in the list, then swap those two numbers around.</li>

   <li><p>If the <code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> attribute represents the <a data-anolis-xref="attr-area-shape-rect" href="#attr-area-shape-rect">rectangle state</a>, and the second number in the list is
   numerically less than the fourth number in the list, then swap those two numbers around.</li>

   <li><p>If the <code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> attribute represents the <a data-anolis-xref="attr-area-shape-circle" href="#attr-area-shape-circle">circle state</a>, and the third number in the list is less than
   or equal to zero, then the shape is empty; abort these steps.</li>

   <li><p>Now, the shape represented by the element is the one described for the entry in the list
   below corresponding to the state of the <code data-anolis-xref="attr-area-shape"><a href="#attr-area-shape">shape</a></code> attribute:</p>

    <dl class="switch"><dt><a data-anolis-xref="attr-area-shape-circle" href="#attr-area-shape-circle">Circle state</a></dt>
     <dd>

      <p>Let <var data-anolis-xref="">x</var> be the first number in <var data-anolis-xref="">coords</var>, <var data-anolis-xref="">y</var> be the second number, and <var data-anolis-xref="">r</var> be the third number.</p>

      <p>The shape is a circle whose center is <var data-anolis-xref="">x</var> CSS pixels from the left edge
      of the image and <var data-anolis-xref="">y</var> CSS pixels from the top edge of the image, and whose
      radius is <var data-anolis-xref="">r</var> pixels.</p>

     </dd>

     <dt><a data-anolis-xref="attr-area-shape-default" href="#attr-area-shape-default">Default state</a></dt>
     <dd>

      <p>The shape is a rectangle that exactly covers the entire image.</p>

     </dd>

     <dt><a data-anolis-xref="attr-area-shape-poly" href="#attr-area-shape-poly">Polygon state</a></dt>
     <dd>

      <p>Let <var data-anolis-xref="">x<sub data-anolis-xref=""><var data-anolis-xref="">i</var></sub></var> be the <span data-anolis-xref="">(2<var data-anolis-xref="">i</var>)</span>th entry in <var data-anolis-xref="">coords</var>, and <var data-anolis-xref="">y<sub data-anolis-xref=""><var data-anolis-xref="">i</var></sub></var> be the <span data-anolis-xref="">(2<var data-anolis-xref="">i</var>+1)</span>th entry in <var data-anolis-xref="">coords</var> (the first entry in <var data-anolis-xref="">coords</var> being the one with index 0).</p>

      <p>Let <var data-anolis-xref="">the coordinates</var> be (<var data-anolis-xref="">x<sub data-anolis-xref=""><var data-anolis-xref="">i</var></sub></var>, <var data-anolis-xref="">y<sub data-anolis-xref=""><var data-anolis-xref="">i</var></sub></var>),
      interpreted in CSS pixels measured from the top left of the image, for all integer values of
      <var data-anolis-xref="">i</var> from 0 to <span data-anolis-xref="">(<var data-anolis-xref="">N</var>/2)-1</span>, where <var data-anolis-xref="">N</var> is the number of items in <var data-anolis-xref="">coords</var>.</p>

      <p>The shape is a polygon whose vertices are given by <var data-anolis-xref="">the coordinates</var>, and
      whose interior is established using the even-odd rule. <a href="references.html#refsGRAPHICS">[GRAPHICS]</a></p><!--
        browsers implement the even-odd rule / even winding rule:
        http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C%21DOCTYPE%20html%3E%0A%3Cimg%20usemap%3D%22%23x%22%20src%3D%22/resources/images/sample%22%3E%0A%3Cmap%20name%3D%22x%22%3E%0A%20%20%3Carea%20shape%3Dpolygon%20coords%3D%220%2C0%200%2C100%20100%2C100%20100%2C2%201%2C2%202%2C1%202%2C99%2099%2C99%2099%2C0%22%20href%3Da%3E%0A%3C/map%3E%0A
       -->

      

     </dd>

     <dt><a data-anolis-xref="attr-area-shape-rect" href="#attr-area-shape-rect">Rectangle state</a></dt>

     <dd>

      <p>Let <var data-anolis-xref="">x<sub data-anolis-xref="">1</sub></var> be the first number in <var data-anolis-xref="">coords</var>, <var data-anolis-xref="">y<sub data-anolis-xref="">1</sub></var> be the second number, <var data-anolis-xref="">x<sub data-anolis-xref="">2</sub></var> be the third number, and <var data-anolis-xref="">y<sub data-anolis-xref="">2</sub></var> be the fourth number.</p>

      <p>The shape is a rectangle whose top-left corner is given by the coordinate (<var data-anolis-xref="">x<sub data-anolis-xref="">1</sub></var>, <var data-anolis-xref="">y<sub data-anolis-xref="">1</sub></var>) and whose
      bottom right corner is given by the coordinate (<var data-anolis-xref="">x<sub data-anolis-xref="">2</sub></var>,
      <var data-anolis-xref="">y<sub data-anolis-xref="">2</sub></var>), those coordinates being interpreted as CSS pixels
      from the top left corner of the image.</p>

     </dd>

    </dl><p>For historical reasons, the coordinates must be interpreted relative to the
    <em>displayed</em> image after any stretching caused by the CSS 'width' and 'height' properties
    (or, for non-CSS browsers, the image element's <code data-anolis-xref="">width</code> and <code data-anolis-xref="">height</code> attributes — CSS browsers map those attributes to the
    aforementioned CSS properties).</p>

    <p class="note">Browser zoom features and transforms applied using CSS or SVG do not affect the
    coordinates.</p>

   </li>

  </ol><p>Pointing device interaction with an image associated with a set of layered shapes per the above
  algorithm must result in the relevant user interaction events being first fired to the top-most
  shape covering the point that the pointing device indicated, if any, or to the image element
  itself, if there is no shape covering that point. User agents may also allow individual
  <code><a href="#the-area-element">area</a></code> elements representing <a data-anolis-xref="hyperlink" href="links.html#hyperlink">hyperlinks</a> to be selected
  and activated (e.g. using a keyboard).</p>

  <p class="note">Because a <code><a href="#the-map-element">map</a></code> element (and its <code><a href="#the-area-element">area</a></code> elements) can be
  associated with multiple <code><a href="#the-img-element">img</a></code> and <code><a href="#the-object-element">object</a></code> elements, it is possible for an
  <code><a href="#the-area-element">area</a></code> element to correspond to multiple focusable areas of the document.</p>

  <p>Image maps are <a href="infrastructure.html#live">live</a>; if the DOM is mutated, then the user agent must act as if it
  had rerun the algorithms for image maps.</p>

  </div>



  <h4 id="mathml"><span class="secno">4.7.18</span> MathML</h4>

  <p><a href="infrastructure.html#mathml-namespace">MathML名前空間</a>由来の<dfn id="math"><code>math</code></dfn>要素は、この仕様におけるコンテンツモデルの意味に対して<a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>、<a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>、および<a href="dom.html#flow-content-1">フローコンテンツ</a>のカテゴリに分類される。</p>

  <p>MathMLの<code data-anolis-xref="">annotation-xml</code>要素が<a href="infrastructure.html#html-namespace-0">HTML名前空間</a>由来の要素を含む場合、そのような要素は、すべて<a href="dom.html#flow-content-1">フローコンテンツ</a>でなければならない。<a href="references.html#refsMATHML">[MATHML]</a></p>

  <p>MathMLのトークン要素（<code data-anolis-xref="">mi</code>、<code data-anolis-xref="">mo</code>、<code data-anolis-xref="">mn</code>、<code data-anolis-xref="">ms</code>および<code data-anolis-xref="">mtext</code>）がHTML要素の子孫である場合、要素は<a href="infrastructure.html#html-namespace-0">HTML名前空間</a>由来の<a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>要素を含んでもよい。<a href="references.html#refsMATHML">[MATHML]</a></p><!-- this hooks into http://www.w3.org/TR/MathML3/chapter6.html#world-int-combine-other -->
  

  <div class="impl"><!-- apparently we get to define error handling, so: -->

  

  <p>User agents must handle text other than <a href="dom.html#inter-element-whitespace">inter-element whitespace</a> found in MathML
  elements whose content models do not allow straight text by pretending for the purposes of MathML
  content models, layout, and rendering that that text is actually wrapped in an <code data-anolis-xref="">mtext</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a>. (Such text is not, however,
  conforming.)</p>

  <p>User agents must act as if any MathML element whose contents does not match the element's
  content model was replaced, for the purposes of MathML layout and rendering, by an <code data-anolis-xref="">merror</code> element in the <a href="infrastructure.html#mathml-namespace">MathML namespace</a> containing some appropriate
  error message.</p>

  <p>To enable authors to use MathML tools that only accept MathML in its XML form, interactive HTML
  user agents are encouraged to provide a way to export any MathML fragment as an XML
  namespace-well-formed XML fragment.</p>

  </div>

  <p>MathMLの要素のセマンティックは、MathML仕様や<a href="infrastructure.html#other-applicable-specifications">その他の適用可能な仕様</a>で定義される。<a href="references.html#refsMATHML">[MATHML]</a></p>

  <div class="example">

   <p>HTML文書でのMathMLの使用例は、次のとおり：</p>

   <pre>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
 &lt;head&gt;
  &lt;title&gt;The quadratic formula&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;The quadratic formula&lt;/h1&gt;
  &lt;p&gt;
   &lt;math&gt;
    &lt;mi&gt;x&lt;/mi&gt;
    &lt;mo&gt;=&lt;/mo&gt;
    &lt;mfrac&gt;
     &lt;mrow&gt;
      &lt;mo form="prefix"&gt;−&lt;/mo&gt; &lt;mi&gt;b&lt;/mi&gt;
      &lt;mo&gt;±&lt;/mo&gt;
      &lt;msqrt&gt;
       &lt;msup&gt; &lt;mi&gt;b&lt;/mi&gt; &lt;mn&gt;2&lt;/mn&gt; &lt;/msup&gt;
       &lt;mo&gt;−&lt;/mo&gt;
       &lt;mn&gt;4&lt;/mn&gt; &lt;mo&gt;⁢&lt;/mo&gt; &lt;mi&gt;a&lt;/mi&gt; &lt;mo&gt;⁢&lt;/mo&gt; &lt;mi&gt;c&lt;/mi&gt;
      &lt;/msqrt&gt;
     &lt;/mrow&gt;
     &lt;mrow&gt;
      &lt;mn&gt;2&lt;/mn&gt; &lt;mo&gt;⁢&lt;/mo&gt; &lt;mi&gt;a&lt;/mi&gt;
     &lt;/mrow&gt;
    &lt;/mfrac&gt;
   &lt;/math&gt;
  &lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre>

  </div>



  <h4 id="svg"><span class="secno">4.7.19</span> SVG</h4>

  <p><a href="infrastructure.html#svg-namespace">SVG名前空間</a>由来の<dfn id="svg-0"><code>svg</code></dfn>要素は、この仕様におけるコンテンツモデルの意味に対して<a href="dom.html#embedded-content-category">エンベディッドコンテンツ</a>、<a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>、および<a href="dom.html#flow-content-1">フローコンテンツ</a>のカテゴリに分類される。</p>

  <div class="impl">

  <p>To enable authors to use SVG tools that only accept SVG in its XML form, interactive HTML user
  agents are encouraged to provide a way to export any SVG fragment as an XML namespace-well-formed
  XML fragment.</p>

  </div>

  <p>SVGの<code data-anolis-xref="">foreignObject</code>要素が<a href="infrastructure.html#html-namespace-0">HTML名前空間</a>の要素を含む場合、そのような要素は、すべて<a href="dom.html#flow-content-1">フローコンテンツ</a>でなければならない。<a href="references.html#refsSVG">[SVG]</a></p>

  <p><a href="infrastructure.html#html-documents">HTML文書</a>内部の<a href="infrastructure.html#svg-namespace">SVG名前空間</a>で<code data-anolis-xref="">title</code>要素のコンテンツモデルは<a href="dom.html#phrasing-content-1">フレージングコンテンツ</a>である。（これはSVG仕様で指定された要件をさらに制約する。）</p>

  <p>SVGの要素のセマンティックは、SVG仕様や<a href="infrastructure.html#other-applicable-specifications">その他の適用可能な仕様</a>で定義される。<a href="references.html#refsSVG">[SVG]</a></p>



  <h4 id="dimension-attributes"><span class="secno">4.7.20</span> <dfn>次元属性</dfn></h4>

  <p><span class="impl"><strong>Author requirements</strong>:</span> The <dfn data-anolis-xref="attr-dim-width" id="attr-dim-width"><code>width</code></dfn> and <dfn data-anolis-xref="attr-dim-height" id="attr-dim-height"><code>height</code></dfn> attributes on <code><a href="#the-img-element">img</a></code>,
  <code><a href="#the-iframe-element">iframe</a></code>, <code><a href="#the-embed-element">embed</a></code>, <code><a href="#the-object-element">object</a></code>, <code><a href="#the-video-element">video</a></code>, and, when their
  <code data-anolis-xref="attr-input-type"><a href="forms.html#attr-input-type">type</a></code> attribute is in the <a data-anolis-xref="attr-input-type-image" href="forms.html#image-button-state-(type=image)">Image Button</a> state, <code><a href="forms.html#the-input-element">input</a></code> elements may be
  specified to give the dimensions of the visual content of the element (the width and height
  respectively, relative to the nominal direction of the output medium), in CSS pixels. The
  attributes, if specified, must have values that are <a data-anolis-xref="valid non-negative integer" href="infrastructure.html#valid-non-negative-integer">valid
  non-negative integers</a>.</p>

  <p>リソースはCSSピクセルの解像度とは異なる解像度を持つかもしれないので、与えられた指定次元は、リソース自体で指定された次元と異なるかもしれない。（画面では、CSSのピクセルが96ppiの解像度を持つが、一般にCSSピクセル解像度が読み取り距離に依存する。）両方の属性が指定される場合、次のいずれかの命題が真でなければならない：</p>

  <ul><li><span data-anolis-xref=""><var data-anolis-xref="">specified width</var> - 0.5 ≤
             <var data-anolis-xref="">specified height</var> * <var data-anolis-xref="">target ratio</var> ≤
             <var data-anolis-xref="">specified width</var> + 0.5</span></li>

   <li><span data-anolis-xref=""><var data-anolis-xref="">specified height</var> - 0.5 ≤
             <var data-anolis-xref="">specified width</var> / <var data-anolis-xref="">target ratio</var> ≤
             <var data-anolis-xref="">specified height</var> + 0.5</span></li>

   <li><span data-anolis-xref=""><var data-anolis-xref="">specified height</var> = <var data-anolis-xref="">specified width</var> = 0</span></li>

  </ul><p><var data-anolis-xref="">target ratio</var>は、リソースの固有高さと固有幅の比率である。<var data-anolis-xref="">specified width</var>と<var data-anolis-xref="">specified height</var>は、それぞれ<code data-anolis-xref="attr-dim-width"><a href="#attr-dim-width">width</a></code>と<code data-anolis-xref="attr-dim-height"><a href="#attr-dim-height">height</a></code>属性の値である。</p>

  <p>問題のリソースが固有幅と固有高さの両方を持たない場合、2つの属性は省略しなければならない。</p>

  <p>2つの属性がともに0である場合、要素がユーザーに意図されない（たとえば、ページビューをカウントするサービスの一部であるかもしれない）ことを示す。</p>

  <p class="note">次元属性は、画像を伸ばすために使用することを意図しない。</p>

  <div class="impl">

  <p><strong>User agent requirements</strong>: User agents are expected to use these attributes <a href="rendering.html#dimRendering">as hints for the rendering</a>.</p>

  <p>The <dfn data-anolis-xref="dom-dim-width" id="dom-dim-width"><code>width</code></dfn> and <dfn data-anolis-xref="dom-dim-height" id="dom-dim-height"><code>height</code></dfn> IDL attributes on the <code><a href="#the-iframe-element">iframe</a></code>,
  <code><a href="#the-embed-element">embed</a></code>, <code><a href="#the-object-element">object</a></code>, and <code><a href="#the-video-element">video</a></code> elements must <a href="infrastructure.html#reflect">reflect</a>
  the respective content attributes of the same name.</p>

  <p class="note">For <code><a href="#the-iframe-element">iframe</a></code>, <code><a href="#the-embed-element">embed</a></code>, and <code><a href="#the-object-element">object</a></code> the IDL
  attributes are <code>DOMString</code>; for <code><a href="#the-video-element">video</a></code> the IDL attributes are
  <code>unsigned long</code>.</p>

  <p class="note">The corresponding IDL attributes for <code data-anolis-xref="dom-img-height"><a href="#dom-img-height">img</a></code> and
  <code data-anolis-xref="dom-input-height"><a href="forms.html#dom-input-height">input</a></code> elements are defined in those respective elements'
  sections, as they are slightly more specific to those elements' other behaviors.</p>

  </div>




  </body></html>