<!DOCTYPE html><html class=split lang=ja>
<script src=/link-fixup.js defer=""></script><meta charset=utf-8><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name=viewport>
<title>HTML Standard, Developer's Edition 日本語訳</title><meta content=#3c790a name=theme-color><link rel=icon href=https://resources.whatwg.org/logo.svg>
<script>
   function toggleStatus(div) {
     div.parentNode.classList.toggle('wrapped');
   }
  </script>
<style>
   .status { min-height: 0.6em; font: 1em sans-serif; width: 9em; padding: 0.3em; position: absolute; z-index: 8; right: 0.3em; background: #EEE; color: black; box-shadow: 0 0 3px #999; overflow: hidden; margin: -2em 0 0 0; border-collapse: initial; border-spacing: initial; }
   .status:hover { z-index: 9; }
   .status:focus-within { z-index: 9; }
   .status.wrapped > :not(input) { display: none; }
   .status > input { position: absolute; left: 0; top: 0; width: 1em; height: 1em; border: none; background: transparent; padding: 0; margin: 0; }
   .status > p { font-size: 0.6em; margin: 0; padding: 0; }
   .status > p + p { padding-top: 0.5em; }
   .status > p > strong { margin-left: 1.5em; }
   .status > .support { display: block; }
   .status > .support > span { padding: 0.2em 0; display: block; display: table; }
   .status > .support > span.partial { color: #666666; filter: grayscale(50%); }
   .status > .support > span.no { color: #CCCCCC; filter: grayscale(100%); }
   .status > .support > span.no::before { opacity: 0.5; }
   .status > .support > span:first-of-type { padding-top: 0.5em; }
   .status > .support > span > span { padding: 0 0.5em; display: table-cell; vertical-align: top; }
   .status > .support > span > span:first-child { width: 100%; }
   .status > .support > span > span:last-child { width: 100%; white-space: pre; padding: 0; }
   .status > .support > span::before { content: ' '; display: table-cell; min-width: 1.5em; height: 1.5em; background: no-repeat center center; background-size: contain; text-align: right; font-size: 0.75em; font-weight: bold; }
   .status > .support > .and_chr::before { background-image: url(https://resources.whatwg.org/browser-logos/chrome.svg); }
   .status > .support > .and_ff::before { background-image: url(https://resources.whatwg.org/browser-logos/firefox.png); }
   .status > .support > .and_uc::before { background-image: url(https://resources.whatwg.org/browser-logos/uc.png); } /* UC Browser for Android */
   .status > .support > .android::before { background-image: url(https://resources.whatwg.org/browser-logos/android.svg); }
   .status > .support > .bb::before { background-image: url(https://resources.whatwg.org/browser-logos/bb.jpg); } /* Blackberry Browser */
   .status > .support > .chrome::before { background-image: url(https://resources.whatwg.org/browser-logos/chrome.svg); }
   .status > .support > .edge::before { background-image: url(https://resources.whatwg.org/browser-logos/edge.svg); }
   .status > .support > .firefox::before { background-image: url(https://resources.whatwg.org/browser-logos/firefox.png); }
   .status > .support > .ie::before { background-image: url(https://resources.whatwg.org/browser-logos/ie.png); }
   .status > .support > .ie_mob::before { background-image: url(https://resources.whatwg.org/browser-logos/ie-mobile.svg); }
   .status > .support > .ios_saf::before { background-image: url(https://resources.whatwg.org/browser-logos/safari-ios.svg); }
   .status > .support > .op_mini::before { background-image: url(https://resources.whatwg.org/browser-logos/opera-mini.png); }
   .status > .support > .op_mob::before { background-image: url(https://resources.whatwg.org/browser-logos/opera.png); }
   .status > .support > .opera::before { background-image: url(https://resources.whatwg.org/browser-logos/opera.png); }
   .status > .support > .safari::before { background-image: url(https://resources.whatwg.org/browser-logos/safari.png); }
   .status > .support > .samsung::before { background-image: url(https://resources.whatwg.org/browser-logos/samsung.png); }
   .status > .caniuse { text-align: right; font-style: italic; width: 100%; }
   .status > .caniuse + p { margin-top: 0.5em; border-top: 1px solid silver; }

   @media (max-width: 767px) {
     .status { right: -9em; }
   }
  </style><link rel=stylesheet href=styles.css>
<body>
  <script async="" src=search.js></script>
  
  
  <header id=head class="head with-buttons">
   <a href=https://whatwg.org/ class=logo><img alt=WHATWG src=https://resources.whatwg.org/logo.svg width=100 height=100></a>
   
   <hgroup><h1><a rel=home href=/dev/>HTML: The Living Standard</a></h1><h2 id=dev-edition-h2 class="no-num no-toc">Developer's Edition — Last Updated <span class=pubdate>2 May 2018</span></h2></hgroup>
   

   <div id=search>
    <input placeholder="Search. Press '/'" autocomplete=off name=query id=query type=search>
    <ol id=results></ol>
   </div>
  </header>

  

  
  

  
  

  

  <nav><a href=web-messaging.html>← 9.4 Cross-document messaging</a> — <a href=./>目次</a> — <a href=webstorage.html>11 Web storage →</a></nav><ol class=toc><li><a href=workers.html#workers><span class=secno>10</span> Web workers</a><ol><li><a href=workers.html#introduction-13><span class=secno>10.1</span> Introduction</a><ol><li><a href=workers.html#scope-2><span class=secno>10.1.1</span> Scope</a></li><li><a href=workers.html#examples-6><span class=secno>10.1.2</span> Examples</a><ol><li><a href=workers.html#a-background-number-crunching-worker><span class=secno>10.1.2.1</span> A background number-crunching worker</a></li><li><a href=workers.html#module-worker-example><span class=secno>10.1.2.2</span> Using a JavaScript module as a worker</a></li><li><a href=workers.html#shared-workers-introduction><span class=secno>10.1.2.3</span> Shared workers introduction</a></li><li><a href=workers.html#shared-state-using-a-shared-worker><span class=secno>10.1.2.4</span> Shared state using a shared worker</a></li><li><a href=workers.html#delegation><span class=secno>10.1.2.5</span> Delegation</a></li><li><a href=workers.html#providing-libraries><span class=secno>10.1.2.6</span> Providing libraries</a></li></ol></li><li><a href=workers.html#tutorials><span class=secno>10.1.3</span> Tutorials</a><ol><li><a href=workers.html#creating-a-dedicated-worker><span class=secno>10.1.3.1</span> Creating a dedicated worker</a></li><li><a href=workers.html#communicating-with-a-dedicated-worker><span class=secno>10.1.3.2</span> Communicating with a dedicated worker</a></li><li><a href=workers.html#shared-workers><span class=secno>10.1.3.3</span> Shared workers</a></li></ol></li></ol></li><li><a href=workers.html#infrastructure-2><span class=secno>10.2</span> Infrastructure</a><ol><li><a href=workers.html#the-global-scope><span class=secno>10.2.1</span> The global scope</a><ol><li><a href=workers.html#the-workerglobalscope-common-interface><span class=secno>10.2.1.1</span> The <code>WorkerGlobalScope</code> common interface</a></li><li><a href=workers.html#dedicated-workers-and-the-dedicatedworkerglobalscope-interface><span class=secno>10.2.1.2</span> Dedicated workers and the <code>DedicatedWorkerGlobalScope</code> interface</a></li><li><a href=workers.html#shared-workers-and-the-sharedworkerglobalscope-interface><span class=secno>10.2.1.3</span> Shared workers and the <code>SharedWorkerGlobalScope</code> interface</a></li></ol></li><li><a href=workers.html#worker-event-loop><span class=secno>10.2.2</span> The event loop</a></li><li><a href=workers.html#runtime-script-errors-2><span class=secno>10.2.3</span> Runtime script errors</a></li><li><a href=workers.html#creating-workers><span class=secno>10.2.4</span> Creating workers</a><ol><li><a href=workers.html#properties-present-on-both-worker-and-sharedworker><span class=secno>10.2.4.1</span> Properties present on both <code>Worker</code> and <code>SharedWorker</code></a></li><li><a href=workers.html#dedicated-workers-and-the-worker-interface><span class=secno>10.2.4.2</span> Dedicated workers and the <code>Worker</code> interface</a></li><li><a href=workers.html#shared-workers-and-the-sharedworker-interface><span class=secno>10.2.4.3</span> Shared workers and the <code>SharedWorker</code> interface</a></li></ol></li><li><a href=workers.html#navigator.hardwareconcurrency><span class=secno>10.2.5</span> Concurrent hardware capabilities</a></li></ol></li><li><a href=workers.html#apis-available-to-workers><span class=secno>10.3</span> APIs available to workers</a><ol><li><a href=workers.html#the-workernavigator-object><span class=secno>10.3.1</span> The <code>WorkerNavigator</code> interface</a></li><li><a href=workers.html#worker-locations><span class=secno>10.3.2</span> The <code>WorkerLocation</code> interface</a></li></ol></li></ol></li></ol><h2 data-lt="web worker" id=workers data-export="" data-dfn-type=dfn><span class=secno>10</span> Web workers<a href=#workers class=self-link></a></h2>

  <h3 id=introduction-13><span class=secno>10.1</span> Introduction<a href=#introduction-13 class=self-link></a></h3>

  <h4 id=scope-2><span class=secno>10.1.1</span> Scope<a href=#scope-2 class=self-link></a></h4>

  

  <p>This specification defines an API for running scripts in the background independently of any
  user interface scripts.</p>

  <p>This allows for long-running scripts that are not interrupted by scripts that respond to clicks
  or other user interactions, and allows long tasks to be executed without yielding to keep the page
  responsive.</p>

  <p>Workers (as these background scripts are called herein) are relatively heavy-weight, and are
  not intended to be used in large numbers. For example, it would be inappropriate to launch one
  worker for each pixel of a four megapixel image. The examples below show some appropriate uses of
  workers.</p>

  <p>Generally, workers are expected to be long-lived, have a high start-up performance cost, and a
  high per-instance memory cost.</p>


  <h4 id=examples-6><span class=secno>10.1.2</span> Examples<a href=#examples-6 class=self-link></a></h4>

  

  <p>There are a variety of uses that workers can be put to. The following subsections show various
  examples of this use.</p>


  <h5 id=a-background-number-crunching-worker><span class=secno>10.1.2.1</span> A background number-crunching worker<a href=#a-background-number-crunching-worker class=self-link></a></h5>

  

  <p>The simplest use of workers is for performing a computationally
  expensive task without interrupting the user interface.</p>

  <p>In this example, the main document spawns a worker to (naïvely) compute prime numbers, and
  progressively displays the most recently found prime number.</p>

  <p>The main page is as follows:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Worker example: One-core computation&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;The highest prime number discovered so far is: &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;
  &lt;script&gt;
   var worker = new Worker('worker.js');
   worker.onmessage = function (event) {
     document.getElementById('result').textContent = event.data;
   };
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

  <p>The <code id=a-background-number-crunching-worker:dom-worker><a href=#dom-worker>Worker()</a></code> constructor call creates a worker and returns a
  <code id=a-background-number-crunching-worker:worker><a href=#worker>Worker</a></code> object representing that worker, which is used to communicate with the worker.
  That object's <code id=a-background-number-crunching-worker:handler-worker-onmessage><a href=#handler-worker-onmessage>onmessage</a></code> event handler allows the
  code to receive messages from the worker.</p>

  <p>The worker itself is as follows:</p>

  <pre>var n = 1;
search: while (true) {
  n += 1;
  for (var i = 2; i &lt;= Math.sqrt(n); i += 1)
    if (n % i == 0)
     continue search;
  // found a prime!
  postMessage(n);
}
</pre>

  <p>The bulk of this code is simply an unoptimized search for a prime number. The <code id=a-background-number-crunching-worker:dom-dedicatedworkerglobalscope-postmessage><a href=#dom-dedicatedworkerglobalscope-postmessage>postMessage()</a></code> method is used to send a
  message back to the page when a prime is found.</p>

  <p><a href=/demos/workers/primes/page.html>この例をオンラインで見る</a>。</p>


  <h5 id=module-worker-example><span class=secno>10.1.2.2</span> Using a JavaScript module as a worker<a href=#module-worker-example class=self-link></a></h5>

  

  <p>All of our examples so far show workers that run <span>classic
  scripts</span>. Workers can instead be instantiated using <span>module
  scripts</span>, which have the usual benefits: the ability to use the JavaScript
  <code>import</code> statement to import other modules; strict mode by default; and
  top-level declarations not polluting the worker's global scope.</p>

  <p>Note that such module-based workers follow different restrictions regarding cross-origin
  content, compared to classic workers. Unlike classic workers, module workers can be instantiated
  using a cross-origin script, as long as that script is exposed using the <a id=module-worker-example:cors-protocol href=https://triple-underscore.github.io/Fetch-ja.html#http-cors-protocol data-x-internal=cors-protocol>CORS
  protocol</a>. Additionally, the <code id=module-worker-example:dom-workerglobalscope-importscripts><a href=#dom-workerglobalscope-importscripts>importScripts()</a></code> method will automatically fail
  inside module workers; the JavaScript <code>import</code> statement is generally a
  better choice.</p>

  <p>In this example, the main document uses a worker to do off-main-thread image manipulation.
  It imports the filters used from another module.</p>

  <p>The main page is as follows:</p>

  <pre>&lt;!DOCTYPE html&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;Worker example: image decoding&lt;/title&gt;

&lt;p&gt;
  &lt;label&gt;
    Type an image URL to decode
    &lt;input type="url" id="image-url" list="image-list"&gt;
    &lt;datalist id="image-list"&gt;
      &lt;option value="https://html.spec.whatwg.org/images/drawImage.png"&gt;
      &lt;option value="https://html.spec.whatwg.org/images/robots.jpeg"&gt;
      &lt;option value="https://html.spec.whatwg.org/images/arcTo2.png"&gt;
    &lt;/datalist&gt;
  &lt;/label&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;label&gt;
    Choose a filter to apply
    &lt;select id="filter"&gt;
      &lt;option value="none"&gt;none&lt;/option&gt;
      &lt;option value="grayscale"&gt;grayscale&lt;/option&gt;
      &lt;option value="brighten"&gt;brighten by 20%&lt;/option&gt;
    &lt;/select&gt;
  &lt;/label&gt;
&lt;/p&gt;

&lt;canvas id="output"&gt;&lt;/canvas&gt;

&lt;script type="module"&gt;
  const worker = new Worker("worker.js", { type: "module" });
  worker.onmessage = receiveFromWorker;

  const url = document.querySelector("#image-url");
  const filter = document.querySelector("#filter");
  const output = document.querySelector("#output");

  url.oninput = updateImage;
  filter.oninput = sendToWorker;

  let imageData, context;

  function updateImage() {
    const img = new Image();
    img.src = url.value;

    img.onload = () =&gt; {
      output.innerHTML = "";

      const canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;

      context = canvas.getContext("2d");
      context.drawImage(img, 0, 0);
      imageData = context.getImageData(0, 0, canvas.width, canvas.height);

      sendToWorker();
      output.appendChild(canvas);
    };
  }

  function sendToWorker() {
    worker.postMessage({ imageData, filter: filter.value });
  }

  function receiveFromWorker(e) {
    context.putImageData(e.data, 0, 0);
  }
&lt;/script&gt;
</pre>

  <p>The worker file is then:</p>

  <pre>import * as filters from "./filters.js";

self.onmessage = e =&gt; {
  const { imageData, filter } = e.data;
  filters[filter](imageData);
  self.postMessage(imageData, [imageData.data.buffer]);
};
</pre>

  <p>Which imports the file <code>filters.js</code>:</p>

  <pre>export function none() {}

export function grayscale({ data: d }) {
  for (let i = 0; i &lt; d.length; i += 4) {
    const [r, g, b] = [d[i], d[i + 1], d[i + 2]];

    // CIE luminance for the RGB
    // The human eye is bad at seeing red and blue, so we de-emphasize them.
    d[i] = d[i + 1] = d[i + 2] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }
};

export function brighten({ data: d }) {
  for (let i = 0; i &lt; d.length; ++i) {
    d[i] *= 1.2;
  }
};
</pre>

  <p><a href=/demos/workers/modules/page.html>この例をオンラインで見る</a>。</p>


  <h5 id=shared-workers-introduction><span class=secno>10.1.2.3</span> Shared workers introduction<a href=#shared-workers-introduction class=self-link></a></h5><div class=status><input onclick=toggleStatus(this) value=⋰ type=button><p class=support><strong>Support:</strong> sharedworkers<span class="and_chr no"><span>Chrome for Android</span> <span>None</span></span><span class="chrome yes"><span>Chrome</span> <span>4+</span></span><span class="ios_saf no"><span>iOS Safari</span> <span>None</span></span><span class="and_uc yes"><span>UC Browser for Android</span> <span>11.8+</span></span><span class="firefox yes"><span>Firefox</span> <span>29+</span></span><span class="ie no"><span>IE</span> <span>None</span></span><span class="op_mini no"><span>Opera Mini</span> <span>None</span></span><span class="samsung no"><span>Samsung Internet</span> <span>None</span></span><span class="safari no"><span>Safari</span> <span>None</span></span><span class="edge no"><span>Edge</span> <span>None</span></span><span class="android no"><span>Android Browser</span> <span>None</span></span><span class="opera yes"><span>Opera</span> <span>10.6+</span></span><p class=caniuse>Source: <a href="https://caniuse.com/#feat=sharedworkers">caniuse.com</a></div>

  

  <p>This section introduces shared workers using a Hello World example. Shared workers use slightly
  different APIs, since each worker can have multiple connections.</p>

  <p>This first example shows how you connect to a worker and how a worker can send a message back
  to the page when it connects to it. Received messages are displayed in a log.</p>

  <p>Here is the HTML page:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;Shared workers: demo 1&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;
&lt;script&gt;
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.onmessage = function(e) { // note: not worker.onmessage!
    log.textContent += '\n' + e.data;
  }
&lt;/script&gt;
</pre>

  <p>Here is the JavaScript worker:</p>

  <pre>onconnect = function(e) {
  var port = e.ports[0];
  port.postMessage('Hello World!');
}
</pre>

  <p><a href=/demos/workers/shared/001/test.html>この例をオンラインで見る</a>。</p>

  <hr>

  <p>This second example extends the first one by changing two things: first, messages are received
  using <code>addEventListener()</code> instead of an <span>event handler IDL attribute</span>, and second, a message is sent <em>to</em> the
  worker, causing the worker to send another message in return. Received messages are again
  displayed in a log.</p>

  <p>Here is the HTML page:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;Shared workers: demo 2&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;
&lt;script&gt;
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.addEventListener('message', function(e) {
    log.textContent += '\n' + e.data;
  }, false);
  worker.port.start(); // note: need this when using addEventListener
  worker.port.postMessage('ping');
&lt;/script&gt;
</pre>

  <p>Here is the JavaScript worker:</p>

  <pre>onconnect = function(e) {
  var port = e.ports[0];
  port.postMessage('Hello World!');
  port.onmessage = function(e) {
    port.postMessage('pong'); // not e.ports[0].postMessage!
    // e.target.postMessage('pong'); would work also
  }
}
</pre>

  <p><a href=/demos/workers/shared/002/test.html>この例をオンラインで見る</a>。</p>

  <hr>

  <p>Finally, the example is extended to show how two pages can connect to the same worker; in this
  case, the second page is merely in an <code id=shared-workers-introduction:the-iframe-element><a href=iframe-embed-object.html#the-iframe-element>iframe</a></code> on the first page, but the same
  principle would apply to an entirely separate page in a separate <a id=shared-workers-introduction:top-level-browsing-context href=browsers.html#top-level-browsing-context>top-level browsing
  context</a>.</p>

  <p>Here is the outer HTML page:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;Shared workers: demo 3&lt;/title&gt;
&lt;pre id="log"&gt;Log:&lt;/pre&gt;
&lt;script&gt;
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.addEventListener('message', function(e) {
    log.textContent += '\n' + e.data;
  }, false);
  worker.port.start();
  worker.port.postMessage('ping');
&lt;/script&gt;
&lt;iframe src="inner.html"&gt;&lt;/iframe&gt;
</pre>

  <p>Here is the inner HTML page:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;Shared workers: demo 3 inner frame&lt;/title&gt;
&lt;pre id=log&gt;Inner log:&lt;/pre&gt;
&lt;script&gt;
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.onmessage = function(e) {
   log.textContent += '\n' + e.data;
  }
&lt;/script&gt;
</pre>

  <p>Here is the JavaScript worker:</p>

  <pre>var count = 0;
onconnect = function(e) {
  count += 1;
  var port = e.ports[0];
  port.postMessage('Hello World! You are connection #' + count);
  port.onmessage = function(e) {
    port.postMessage('pong');
  }
}
</pre>

  <p><a href=/demos/workers/shared/003/test.html>この例をオンラインで見る</a>。</p>


  <h5 id=shared-state-using-a-shared-worker><span class=secno>10.1.2.4</span> Shared state using a shared worker<a href=#shared-state-using-a-shared-worker class=self-link></a></h5>

  

  <p>In this example, multiple windows (viewers) can be opened that are all viewing the same map.
  All the windows share the same map information, with a single worker coordinating all the viewers.
  Each viewer can move around independently, but if they set any data on the map, all the viewers
  are updated.</p>

  <p>The main page isn't interesting, it merely provides a way to open the viewers:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Workers example: Multiviewer&lt;/title&gt;
  &lt;script&gt;
   function openViewer() {
     window.open('viewer.html');
   }
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;&lt;button type=button onclick="openViewer()"&gt;Open a new
  viewer&lt;/button&gt;&lt;/p&gt;
  &lt;p&gt;Each viewer opens in a new window. You can have as many viewers
  as you like, they all view the same data.&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

  <p>The viewer is more involved:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Workers example: Multiviewer viewer&lt;/title&gt;
  &lt;script&gt;
   var worker = new SharedWorker('worker.js', 'core');

   // CONFIGURATION
   function configure(event) {
     if (event.data.substr(0, 4) != 'cfg ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     // update display to mention our name is name
     document.getElementsByTagName('h1')[0].textContent += ' ' + name;
     // no longer need this listener
     worker.port.removeEventListener('message', configure, false);
   }
   worker.port.addEventListener('message', configure, false);

   // MAP
   function paintMap(event) {
     if (event.data.substr(0, 4) != 'map ') return;
     var data = event.data.substr(4).split(',');
     // display tiles data[0] .. data[8]
     var canvas = document.getElementById('map');
     var context = canvas.getContext('2d');
     for (var y = 0; y &lt; 3; y += 1) {
       for (var x = 0; x &lt; 3; x += 1) {
         var tile = data[y * 3 + x];
         if (tile == '0')
           context.fillStyle = 'green';
         else
           context.fillStyle = 'maroon';
         context.fillRect(x * 50, y * 50, 50, 50);
       }
     }
   }
   worker.port.addEventListener('message', paintMap, false);

   // PUBLIC CHAT
   function updatePublicChat(event) {
     if (event.data.substr(0, 4) != 'txt ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     var message = event.data.substr(4 + name.length + 1);
     // display "&lt;name&gt; message" in public chat
     var public = document.getElementById('public');
     var p = document.createElement('p');
     var n = document.createElement('button');
     n.textContent = '&lt;' + name + '&gt; ';
     n.onclick = function () { worker.port.postMessage('msg ' + name); };
     p.appendChild(n);
     var m = document.createElement('span');
     m.textContent = message;
     p.appendChild(m);
     public.appendChild(p);
   }
   worker.port.addEventListener('message', updatePublicChat, false);

   // PRIVATE CHAT
   function startPrivateChat(event) {
     if (event.data.substr(0, 4) != 'msg ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     var port = event.ports[0];
     // display a private chat UI
     var ul = document.getElementById('private');
     var li = document.createElement('li');
     var h3 = document.createElement('h3');
     h3.textContent = 'Private chat with ' + name;
     li.appendChild(h3);
     var div = document.createElement('div');
     var addMessage = function(name, message) {
       var p = document.createElement('p');
       var n = document.createElement('strong');
       n.textContent = '&lt;' + name + '&gt; ';
       p.appendChild(n);
       var t = document.createElement('span');
       t.textContent = message;
       p.appendChild(t);
       div.appendChild(p);
     };
     port.onmessage = function (event) {
       addMessage(name, event.data);
     };
     li.appendChild(div);
     var form = document.createElement('form');
     var p = document.createElement('p');
     var input = document.createElement('input');
     input.size = 50;
     p.appendChild(input);
     p.appendChild(document.createTextNode(' '));
     var button = document.createElement('button');
     button.textContent = 'Post';
     p.appendChild(button);
     form.onsubmit = function () {
       port.postMessage(input.value);
       addMessage('me', input.value);
       input.value = '';
       return false;
     };
     form.appendChild(p);
     li.appendChild(form);
     ul.appendChild(li);
   }
   worker.port.addEventListener('message', startPrivateChat, false);

   worker.port.start();
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;h1&gt;Viewer&lt;/h1&gt;
  &lt;h2&gt;Map&lt;/h2&gt;
  &lt;p&gt;&lt;canvas id="map" height=150 width=150&gt;&lt;/canvas&gt;&lt;/p&gt;
  &lt;p&gt;
   &lt;button type=button onclick="worker.port.postMessage('mov left')"&gt;Left&lt;/button&gt;
   &lt;button type=button onclick="worker.port.postMessage('mov up')"&gt;Up&lt;/button&gt;
   &lt;button type=button onclick="worker.port.postMessage('mov down')"&gt;Down&lt;/button&gt;
   &lt;button type=button onclick="worker.port.postMessage('mov right')"&gt;Right&lt;/button&gt;
   &lt;button type=button onclick="worker.port.postMessage('set 0')"&gt;Set 0&lt;/button&gt;
   &lt;button type=button onclick="worker.port.postMessage('set 1')"&gt;Set 1&lt;/button&gt;
  &lt;/p&gt;
  &lt;h2&gt;Public Chat&lt;/h2&gt;
  &lt;div id="public"&gt;&lt;/div&gt;
  &lt;form onsubmit="worker.port.postMessage('txt ' + message.value); message.value = ''; return false;"&gt;
   &lt;p&gt;
    &lt;input type="text" name="message" size="50"&gt;
    &lt;button&gt;Post&lt;/button&gt;
   &lt;/p&gt;
  &lt;/form&gt;
  &lt;h2&gt;Private Chat&lt;/h2&gt;
  &lt;ul id="private"&gt;&lt;/ul&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

  <p>There are several key things worth noting about the way the viewer is written.</p>

  <p><strong>Multiple listeners</strong>. Instead of a single message processing function, the code
  here attaches multiple event listeners, each one performing a quick check to see if it is relevant
  for the message. In this example it doesn't make much difference, but if multiple authors wanted
  to collaborate using a single port to communicate with a worker, it would allow for independent
  code instead of changes having to all be made to a single event handling function.</p>

  <p>Registering event listeners in this way also allows you to unregister specific listeners when
  you are done with them, as is done with the <code>configure()</code> method in this
  example.</p>

  <p>Finally, the worker:</p>

  <pre>var nextName = 0;
function getNextName() {
  // this could use more friendly names
  // but for now just return a number
  return nextName++;
}

var map = [
 [0, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 1, 0, 1, 1],
 [0, 1, 0, 1, 0, 0, 0],
 [0, 1, 0, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 0, 0, 1, 1, 1, 1],
 [1, 1, 0, 1, 1, 0, 1],
];

function wrapX(x) {
  if (x &lt; 0) return wrapX(x + map[0].length);
  if (x &gt;= map[0].length) return wrapX(x - map[0].length);
  return x;
}

function wrapY(y) {
  if (y &lt; 0) return wrapY(y + map.length);
  if (y &gt;= map[0].length) return wrapY(y - map.length);
  return y;
}

function wrap(val, min, max) {
  if (val &lt; min)
    return val + (max-min)+1;
  if (val &gt; max)
    return val - (max-min)-1;
  return val;
}

function sendMapData(viewer) {
  var data = '';
  for (var y = viewer.y-1; y &lt;= viewer.y+1; y += 1) {
    for (var x = viewer.x-1; x &lt;= viewer.x+1; x += 1) {
      if (data != '')
        data += ',';
      data += map[wrap(y, 0, map[0].length-1)][wrap(x, 0, map.length-1)];
    }
  }
  viewer.port.postMessage('map ' + data);
}

var viewers = {};
onconnect = function (event) {
  var name = getNextName();
  event.ports[0]._data = { port: event.ports[0], name: name, x: 0, y: 0, };
  viewers[name] = event.ports[0]._data;
  event.ports[0].postMessage('cfg ' + name);
  event.ports[0].onmessage = getMessage;
  sendMapData(event.ports[0]._data);
};

function getMessage(event) {
  switch (event.data.substr(0, 4)) {
    case 'mov ':
      var direction = event.data.substr(4);
      var dx = 0;
      var dy = 0;
      switch (direction) {
        case 'up': dy = -1; break;
        case 'down': dy = 1; break;
        case 'left': dx = -1; break;
        case 'right': dx = 1; break;
      }
      event.target._data.x = wrapX(event.target._data.x + dx);
      event.target._data.y = wrapY(event.target._data.y + dy);
      sendMapData(event.target._data);
      break;
    case 'set ':
      var value = event.data.substr(4);
      map[event.target._data.y][event.target._data.x] = value;
      for (var viewer in viewers)
        sendMapData(viewers[viewer]);
      break;
    case 'txt ':
      var name = event.target._data.name;
      var message = event.data.substr(4);
      for (var viewer in viewers)
        viewers[viewer].port.postMessage('txt ' + name + ' ' + message);
      break;
    case 'msg ':
      var party1 = event.target._data;
      var party2 = viewers[event.data.substr(4).split(' ', 1)[0]];
      if (party2) {
        var channel = new MessageChannel();
        party1.port.postMessage('msg ' + party2.name, [channel.port1]);
        party2.port.postMessage('msg ' + party1.name, [channel.port2]);
      }
      break;
  }
}
</pre>

  <p><strong>Connecting to multiple pages</strong>. The script uses the <code id=shared-state-using-a-shared-worker:handler-sharedworkerglobalscope-onconnect><a href=#handler-sharedworkerglobalscope-onconnect>onconnect</a></code> event listener to listen for
  multiple connections.</p>

  <p><strong>Direct channels</strong>. When the worker receives a "msg" message from one viewer
  naming another viewer, it sets up a direct connection between the two, so that the two viewers can
  communicate directly without the worker having to proxy all the messages.</p>

  <p><a href=/demos/workers/multiviewer/page.html>この例をオンラインで見る</a>。</p>


  <h5 id=delegation><span class=secno>10.1.2.5</span> Delegation<a href=#delegation class=self-link></a></h5>

  

  <p>With multicore CPUs becoming prevalent, one way to obtain better performance is to split
  computationally expensive tasks amongst multiple workers. In this example, a computationally
  expensive task that is to be performed for every number from 1 to 10,000,000 is farmed out to ten
  subworkers.</p>

  <p>The main page is as follows, it just reports the result:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Worker example: Multicore computation&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Result: &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;
  &lt;script&gt;
   var worker = new Worker('worker.js');
   worker.onmessage = function (event) {
     document.getElementById('result').textContent = event.data;
   };
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

  <p>The worker itself is as follows:</p>

  <pre>// settings
var num_workers = 10;
var items_per_worker = 1000000;

// start the workers
var result = 0;
var pending_workers = num_workers;
for (var i = 0; i &lt; num_workers; i += 1) {
  var worker = new Worker('core.js');
  worker.postMessage(i * items_per_worker);
  worker.postMessage((i+1) * items_per_worker);
  worker.onmessage = storeResult;
}

// handle the results
function storeResult(event) {
  result += 1*event.data;
  pending_workers -= 1;
  if (pending_workers &lt;= 0)
    postMessage(result); // finished!
}
</pre>

  <p>It consists of a loop to start the subworkers, and then a handler
  that waits for all the subworkers to respond.</p>

  <p>The subworkers are implemented as follows:</p>

  <pre>var start;
onmessage = getStart;
function getStart(event) {
  start = 1*event.data;
  onmessage = getEnd;
}

var end;
function getEnd(event) {
  end = 1*event.data;
  onmessage = null;
  work();
}

function work() {
  var result = 0;
  for (var i = start; i &lt; end; i += 1) {
    // perform some complex calculation here
    result += 1;
  }
  postMessage(result);
  close();
}
</pre>

  <p>They receive two numbers in two events, perform the computation for the range of numbers thus
  specified, and then report the result back to the parent.</p>

  <p><a href=/demos/workers/multicore/page.html>この例をオンラインで見る</a>。</p>


  <h5 id=providing-libraries><span class=secno>10.1.2.6</span> Providing libraries<a href=#providing-libraries class=self-link></a></h5>

  

  <p>Suppose that a cryptography library is made available that provides three tasks:</p>

  <dl><dt>Generate a public/private key pair<dd>Takes a port, on which it will send two messages, first the public key and then the private
   key.<dt>Given a plaintext and a public key, return the corresponding ciphertext<dd>Takes a port, to which any number of messages can be sent, the first giving the public key,
   and the remainder giving the plaintext, each of which is encrypted and then sent on that same
   channel as the ciphertext. The user can close the port when it is done encrypting content.<dt>Given a ciphertext and a private key, return the corresponding plaintext<dd>Takes a port, to which any number of messages can be sent, the first giving the private key,
   and the remainder giving the ciphertext, each of which is decrypted and then sent on that same
   channel as the plaintext. The user can close the port when it is done decrypting content.</dl>

  <p>The library itself is as follows:</p>

  <pre>function handleMessage(e) {
  if (e.data == "genkeys")
    genkeys(e.ports[0]);
  else if (e.data == "encrypt")
    encrypt(e.ports[0]);
  else if (e.data == "decrypt")
    decrypt(e.ports[0]);
}

function genkeys(p) {
  var keys = _generateKeyPair();
  p.postMessage(keys[0]);
  p.postMessage(keys[1]);
}

function encrypt(p) {
  var key, state = 0;
  p.onmessage = function (e) {
    if (state == 0) {
      key = e.data;
      state = 1;
    } else {
      p.postMessage(_encrypt(key, e.data));
    }
  };
}

function decrypt(p) {
  var key, state = 0;
  p.onmessage = function (e) {
    if (state == 0) {
      key = e.data;
      state = 1;
    } else {
      p.postMessage(_decrypt(key, e.data));
    }
  };
}

// support being used as a shared worker as well as a dedicated worker
if ('onmessage' in this) // dedicated worker
  onmessage = handleMessage;
else // shared worker
  onconnect = function (e) { e.port.onmessage = handleMessage; }


// the "crypto" functions:

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}

function _encrypt(k, s) {
  return 'encrypted-' + k + ' ' + s;
}

function _decrypt(k, s) {
  return s.substr(s.indexOf(' ')+1);
}
</pre>

  <p>Note that the crypto functions here are just stubs and don't do real cryptography.</p>

  <p>This library could be used as follows:</p>

  <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Worker example: Crypto library&lt;/title&gt;
  &lt;script&gt;
   const cryptoLib = new Worker('libcrypto-v1.js'); // or could use 'libcrypto-v2.js'
   function startConversation(source, message) {
     const messageChannel = new MessageChannel();
     source.postMessage(message, [messageChannel.port2]);
     return messageChannel.port1;
   }
   function getKeys() {
     let state = 0;
     startConversation(cryptoLib, "genkeys").onmessage = function (e) {
       if (state === 0)
         document.getElementById('public').value = e.data;
       else if (state === 1)
         document.getElementById('private').value = e.data;
       state += 1;
     };
   }
   function enc() {
     const port = startConversation(cryptoLib, "encrypt");
     port.postMessage(document.getElementById('public').value);
     port.postMessage(document.getElementById('input').value);
     port.onmessage = function (e) {
       document.getElementById('input').value = e.data;
       port.close();
     };
   }
   function dec() {
     const port = startConversation(cryptoLib, "decrypt");
     port.postMessage(document.getElementById('private').value);
     port.postMessage(document.getElementById('input').value);
     port.onmessage = function (e) {
       document.getElementById('input').value = e.data;
       port.close();
     };
   }
  &lt;/script&gt;
  &lt;style&gt;
   textarea { display: block; }
  &lt;/style&gt;
 &lt;/head&gt;
 &lt;body onload="getKeys()"&gt;
  &lt;fieldset&gt;
   &lt;legend&gt;Keys&lt;/legend&gt;
   &lt;p&gt;&lt;label&gt;Public Key: &lt;textarea id="public"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
   &lt;p&gt;&lt;label&gt;Private Key: &lt;textarea id="private"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
  &lt;/fieldset&gt;
  &lt;p&gt;&lt;label&gt;Input: &lt;textarea id="input"&gt;&lt;/textarea&gt;&lt;/label&gt;&lt;/p&gt;
  &lt;p&gt;&lt;button onclick="enc()"&gt;Encrypt&lt;/button&gt; &lt;button onclick="dec()"&gt;Decrypt&lt;/button&gt;&lt;/p&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>

  <p>A later version of the API, though, might want to offload all the crypto work onto subworkers.
  This could be done as follows:</p>

  <pre>function handleMessage(e) {
  if (e.data == "genkeys")
    genkeys(e.ports[0]);
  else if (e.data == "encrypt")
    encrypt(e.ports[0]);
  else if (e.data == "decrypt")
    decrypt(e.ports[0]);
}

function genkeys(p) {
  var generator = new Worker('libcrypto-v2-generator.js');
  generator.postMessage('', [p]);
}

function encrypt(p) {
  p.onmessage = function (e) {
    var key = e.data;
    var encryptor = new Worker('libcrypto-v2-encryptor.js');
    encryptor.postMessage(key, [p]);
  };
}

function encrypt(p) {
  p.onmessage = function (e) {
    var key = e.data;
    var decryptor = new Worker('libcrypto-v2-decryptor.js');
    decryptor.postMessage(key, [p]);
  };
}

// support being used as a shared worker as well as a dedicated worker
if ('onmessage' in this) // dedicated worker
  onmessage = handleMessage;
else // shared worker
  onconnect = function (e) { e.ports[0].onmessage = handleMessage };
</pre>

  <p>The little subworkers would then be as follows.</p>

  <p>For generating key pairs:</p>

  <pre>onmessage = function (e) {
  var k = _generateKeyPair();
  e.ports[0].postMessage(k[0]);
  e.ports[0].postMessage(k[1]);
  close();
}

function _generateKeyPair() {
  return [Math.random(), Math.random()];
}
</pre>

  <p>For encrypting:</p>

  <pre>onmessage = function (e) {
  var key = e.data;
  e.ports[0].onmessage = function (e) {
    var s = e.data;
    postMessage(_encrypt(key, s));
  }
}

function _encrypt(k, s) {
  return 'encrypted-' + k + ' ' + s;
}
</pre>

  <p>For decrypting:</p>

  <pre>onmessage = function (e) {
  var key = e.data;
  e.ports[0].onmessage = function (e) {
    var s = e.data;
    postMessage(_decrypt(key, s));
  }
}

function _decrypt(k, s) {
  return s.substr(s.indexOf(' ')+1);
}
</pre>

  <p>Notice how the users of the API don't have to even know that this is happening — the API
  hasn't changed; the library can delegate to subworkers without changing its API, even though it is
  accepting data using message channels.</p>

  <p><a href=/demos/workers/crypto/page.html>この例をオンラインで見る</a>。</p>


  <h4 id=tutorials><span class=secno>10.1.3</span> Tutorials<a href=#tutorials class=self-link></a></h4>

  <h5 id=creating-a-dedicated-worker><span class=secno>10.1.3.1</span> Creating a dedicated worker<a href=#creating-a-dedicated-worker class=self-link></a></h5>

  

  <p>Creating a worker requires a URL to a JavaScript file. The <code id=creating-a-dedicated-worker:dom-worker><a href=#dom-worker>Worker()</a></code> constructor is invoked with the URL to that file as its only
  argument; a worker is then created and returned:</p>

  <pre>var worker = new Worker('helper.js');</pre>

  <p>If you want your worker script to be interpreted as a <span>module script</span> instead of
  the default <span>classic script</span>, you need to use a slightly different signature:</p>

  <pre>var worker = new Worker('helper.js', { type: "module" });</pre>


  <h5 id=communicating-with-a-dedicated-worker><span class=secno>10.1.3.2</span> Communicating with a dedicated worker<a href=#communicating-with-a-dedicated-worker class=self-link></a></h5>

  

  <p>Dedicated workers use <code>MessagePort</code> objects behind the scenes, and thus support all
  the same features, such as sending structured data, transferring binary data, and transferring
  other ports.</p>

  <p>To receive messages from a dedicated worker, use the <code id=communicating-with-a-dedicated-worker:handler-worker-onmessage><a href=#handler-worker-onmessage>onmessage</a></code> <span>event
  handler IDL attribute</span> on the <code id=communicating-with-a-dedicated-worker:worker><a href=#worker>Worker</a></code> object:</p>

  <pre>worker.onmessage = function (event) { ... };</pre>

  <p>You can also use the <code id=communicating-with-a-dedicated-worker:dom-eventtarget-addeventlistener><a data-x-internal=dom-eventtarget-addeventlistener href=https://triple-underscore.github.io/DOM4-ja.html#dom-eventtarget-addeventlistener>addEventListener()</a></code>
  method.</p>

  <p class=note>The implicit <code>MessagePort</code> used by dedicated workers has its <span>port
  message queue</span> implicitly enabled when it is created, so there is no equivalent to the
  <code>MessagePort</code> interface's <code id=communicating-with-a-dedicated-worker:dom-messageport-start><a href=web-messaging.html#dom-messageport-start>start()</a></code> method on
  the <code id=communicating-with-a-dedicated-worker:worker-2><a href=#worker>Worker</a></code> interface.</p>

  <p>To <em>send</em> data to a worker, use the <code id=communicating-with-a-dedicated-worker:dom-worker-postmessage><a href=#dom-worker-postmessage>postMessage()</a></code> method. Structured data can be sent over this
  communication channel. To send <code id=communicating-with-a-dedicated-worker:idl-arraybuffer><a data-x-internal=idl-arraybuffer href=https://triple-underscore.github.io/WebIDL-ja.html#idl-ArrayBuffer>ArrayBuffer</a></code> objects
  efficiently (by transferring them rather than cloning them), list them in an array in the second
  argument.</p>

  <pre>worker.postMessage({
  operation: 'find-edges',
  input: buffer, // an ArrayBuffer object
  threshold: 0.6,
}, [buffer]);</pre>

  <p>To receive a message inside the worker, the <code id=communicating-with-a-dedicated-worker:handler-dedicatedworkerglobalscope-onmessage><a href=#handler-dedicatedworkerglobalscope-onmessage>onmessage</a></code> <span>event handler IDL attribute</span> is used.</p>

  <pre>onmessage = function (event) { ... };</pre>

  <p>You can again also use the <code id=communicating-with-a-dedicated-worker:dom-eventtarget-addeventlistener-2><a data-x-internal=dom-eventtarget-addeventlistener href=https://triple-underscore.github.io/DOM4-ja.html#dom-eventtarget-addeventlistener>addEventListener()</a></code> method.</p>

  <p>In either case, the data is provided in the event object's <code id=communicating-with-a-dedicated-worker:dom-messageevent-data><a href=comms.html#dom-messageevent-data>data</a></code> attribute.</p>

  <p>To send messages back, you again use <code id=communicating-with-a-dedicated-worker:dom-dedicatedworkerglobalscope-postmessage><a href=#dom-dedicatedworkerglobalscope-postmessage>postMessage()</a></code>. It supports the
  structured data in the same manner.</p>

  <pre>postMessage(event.data.input, [event.data.input]); // transfer the buffer back</pre>


  <h5 id=shared-workers data-dfn-type=dfn data-lt="shared worker" data-export=""><span class=secno>10.1.3.3</span> Shared workers<a href=#shared-workers class=self-link></a></h5>

  

  <p>Shared workers are identified by the URL of the script used to create it, optionally with an
  explicit name. The name allows multiple instances of a particular shared worker to be started.</p>

  <p>Shared workers are scoped by <a id=shared-workers:concept-origin href=origin.html#concept-origin>origin</a>. Two different sites using the same names will
  not collide. However, if a page tries to use the same shared worker name as another page on the
  same site, but with a different script URL, it will fail.</p>

  <p>Creating shared workers is done using the <code id=shared-workers:dom-sharedworker><a href=#dom-sharedworker>SharedWorker()</a></code>
  constructor. This constructor takes the URL to the script to use for its first argument, and the
  name of the worker, if any, as the second argument.</p>

  <pre>var worker = new SharedWorker('service.js');</pre>

  <p>Communicating with shared workers is done with explicit <code>MessagePort</code> objects. The
  object returned by the <code id=shared-workers:dom-sharedworker-2><a href=#dom-sharedworker>SharedWorker()</a></code> constructor holds a
  reference to the port on its <code id=shared-workers:dom-sharedworker-port><a href=#dom-sharedworker-port>port</a></code> attribute.</p>

  <pre>worker.port.onmessage = function (event) { ... };
worker.port.postMessage('some message');
worker.port.postMessage({ foo: 'structured', bar: ['data', 'also', 'possible']});</pre>

  <p>Inside the shared worker, new clients of the worker are announced using the <code id=shared-workers:event-workerglobalscope-connect><a href=indices.html#event-workerglobalscope-connect>connect</a></code> event. The port for the new client is
  given by the event object's <code id=shared-workers:dom-messageevent-source><a href=comms.html#dom-messageevent-source>source</a></code> attribute.</p>

  <pre>onconnect = function (event) {
  var newPort = event.source;
  // set up a listener
  newPort.onmessage = function (event) { ... };
  // send a message back to the port
  newPort.postMessage('ready!'); // can also send structured data, of course
};</pre>




  <h3 id=infrastructure-2><span class=secno>10.2</span> Infrastructure<a href=#infrastructure-2 class=self-link></a></h3>

  <p>There are two kinds of workers; dedicated workers, and shared workers. Dedicated workers, once
  created, are linked to their creator; but message ports can be used to communicate from a
  dedicated worker to multiple other browsing contexts or workers. Shared workers, on the other
  hand, are named, and once created any script running in the same <a id=infrastructure-2:concept-origin href=origin.html#concept-origin>origin</a> can obtain a
  reference to that worker and communicate with it.</p>


  <h4 id=the-global-scope><span class=secno>10.2.1</span> The global scope<a href=#the-global-scope class=self-link></a></h4>

  <p>The global scope is the "inside" of a worker.</p>

  <h5 id=the-workerglobalscope-common-interface><span class=secno>10.2.1.1</span> The <code id=workerglobalscope>WorkerGlobalScope</code> common interface<a href=#the-workerglobalscope-common-interface class=self-link></a></h5>

  

  <p><code id=the-workerglobalscope-common-interface:workerglobalscope><a href=#workerglobalscope>WorkerGlobalScope</a></code> serves as the base class for specific types of worker global
  scope objects, including <code id=the-workerglobalscope-common-interface:dedicatedworkerglobalscope><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code>,
  <code id=the-workerglobalscope-common-interface:sharedworkerglobalscope><a href=#sharedworkerglobalscope>SharedWorkerGlobalScope</a></code>, and <code id=the-workerglobalscope-common-interface:serviceworkerglobalscope><a data-x-internal=serviceworkerglobalscope href=https://w3c.github.io/ServiceWorker/#serviceworkerglobalscope>ServiceWorkerGlobalScope</a></code>.</p>

  

  <dl class=domintro><dt><var>workerGlobal</var> . <code id=dom-workerglobalscope-self>self</code><dd>Returns <var>workerGlobal</var>.<dt><var>workerGlobal</var> . <code id=dom-workerglobalscope-location>location</code><dd>Returns <var>workerGlobal</var>'s <code id=the-workerglobalscope-common-interface:workerlocation><a href=#workerlocation>WorkerLocation</a></code> object.<dt><var>workerGlobal</var> . <code id=dom-worker-navigator>navigator</code><dd>Returns <var>workerGlobal</var>'s <code id=the-workerglobalscope-common-interface:workernavigator><a href=#workernavigator>WorkerNavigator</a></code> object.<dt><var>workerGlobal</var> . <code id=dom-workerglobalscope-importscripts>importScripts</code>(<var>urls</var>...)<dd>Fetches each <a id=the-workerglobalscope-common-interface:url href=https://triple-underscore.github.io/URL-ja.html#concept-url data-x-internal=url>URL</a> in <var>urls</var>, executes them one-by-one in the order they
   are passed, and then returns (or throws if something went amiss).</dl>

  

  <p>The following are the <a id=the-workerglobalscope-common-interface:event-handlers href=webappapis.html#event-handlers>event handlers</a> (and their corresponding <span>event handler event types</span>)  supported,
  as <span>event handler IDL attributes</span>, by objects implementing the
  <code id=the-workerglobalscope-common-interface:workerglobalscope-2><a href=#workerglobalscope>WorkerGlobalScope</a></code> interface:</p>

  <table><thead><tr><th><a href=webappapis.html#event-handlers id=the-workerglobalscope-common-interface:event-handlers-2>イベントハンドラー</a> </th><th><span>イベントハンドラーイベント型</span>
   <tbody></th></tr><tr><td><dfn id=handler-workerglobalscope-onerror><code>onerror</code></dfn> </td><td> <code id=the-workerglobalscope-common-interface:event-error><a href=indices.html#event-error>error</a></code>
    </td></tr><tr><td><dfn id=handler-workerglobalscope-onlanguagechange><code>onlanguagechange</code></dfn> </td><td> <code id=the-workerglobalscope-common-interface:event-languagechange><a href=indices.html#event-languagechange>languagechange</a></code> 
    </td></tr><tr><td><dfn id=handler-workerglobalscope-onoffline><code>onoffline</code></dfn> </td><td> <code id=the-workerglobalscope-common-interface:event-offline><a href=indices.html#event-offline>offline</a></code> 
    </td></tr><tr><td><dfn id=handler-workerglobalscope-ononline><code>ononline</code></dfn> </td><td> <code id=the-workerglobalscope-common-interface:event-online><a href=indices.html#event-online>online</a></code> 
    </td></tr><tr><td><dfn id=handler-workerglobalscope-onrejectionhandled><code>onrejectionhandled</code></dfn> </td><td> <code id=the-workerglobalscope-common-interface:event-rejectionhandled><a href=indices.html#event-rejectionhandled>rejectionhandled</a></code>
    </td></tr><tr><td><dfn id=handler-workerglobalscope-onunhandledrejection><code>onunhandledrejection</code></dfn> </td><td> <code id=the-workerglobalscope-common-interface:event-unhandledrejection><a href=indices.html#event-unhandledrejection>unhandledrejection</a></code>
  </td></tr></table>


  <h5 id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface><span class=secno>10.2.1.2</span> Dedicated workers and the <code id=dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</code> interface<a href=#dedicated-workers-and-the-dedicatedworkerglobalscope-interface class=self-link></a></h5>

  

  <p><code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dedicatedworkerglobalscope><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code> objects act as if they had an implicit
  <code>MessagePort</code> associated with them. This port is part of a channel that is set up when
  the worker is created, but it is not exposed.</p>

  

  <dl class=domintro><dt><var>dedicatedWorkerGlobal</var> . <code id=dom-dedicatedworkerglobalscope-name>name</code><dd>Returns <var>dedicatedWorkerGlobal</var>'s <span>name</span>, i.e. the value given to the
   <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:worker><a href=#worker>Worker</a></code> constructor. Primarily useful for debugging.<dt><var>dedicatedWorkerGlobal</var> . <code id=dom-dedicatedworkerglobalscope-postmessage>postMessage</code>(<var>message</var> [,
   <var>transfer</var> ])<dd>Clones <var>message</var> and transmits it to the <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:worker-2><a href=#worker>Worker</a></code> object associated with
   <var>dedicatedWorkerGlobal</var>. <var>transfer</var> can be passed as a list of objects that are
   to be transferred rather than cloned.<dt><var>dedicatedWorkerGlobal</var> . <code id=dom-dedicatedworkerglobalscope-close>close</code>()<dd>Aborts <var>dedicatedWorkerGlobal</var>.</dl>

  

  <p>The following are the <a id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:event-handlers href=webappapis.html#event-handlers>event handlers</a> (and their corresponding <span>event handler event types</span>)  supported,
  as <span>event handler IDL attributes</span>, by objects implementing the
  <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dedicatedworkerglobalscope-2><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code> interface:</p>

  <table><thead><tr><th><a href=webappapis.html#event-handlers id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:event-handlers-2>イベントハンドラー</a> </th><th><span>イベントハンドラーイベント型</span>
   <tbody></th></tr><tr><td><dfn id=handler-dedicatedworkerglobalscope-onmessage><code>onmessage</code></dfn> </td><td> <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:event-message><a href=indices.html#event-message>message</a></code>
    </td></tr><tr><td><dfn id=handler-dedicatedworkerglobalscope-onmessageerror><code>onmessageerror</code></dfn> </td><td> <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:event-messageerror><a href=indices.html#event-messageerror>messageerror</a></code>
  </td></tr></table>

  <p>For the purposes of the <span>application cache</span> networking model, a dedicated worker is
  an extension of the <span>cache host</span> from which it was created.</p>



  <h5 id=shared-workers-and-the-sharedworkerglobalscope-interface><span class=secno>10.2.1.3</span> Shared workers and the <code id=sharedworkerglobalscope>SharedWorkerGlobalScope</code> interface<a href=#shared-workers-and-the-sharedworkerglobalscope-interface class=self-link></a></h5>

  

  

  <p>Shared workers receive message ports through <code id=shared-workers-and-the-sharedworkerglobalscope-interface:event-workerglobalscope-connect><a href=indices.html#event-workerglobalscope-connect>connect</a></code> events on their <code id=shared-workers-and-the-sharedworkerglobalscope-interface:sharedworkerglobalscope><a href=#sharedworkerglobalscope>SharedWorkerGlobalScope</a></code> object for each
  connection.</p>

  <dl class=domintro><dt><var>sharedWorkerGlobal</var> . <code id=dom-sharedworkerglobalscope-name>name</code><dd>Returns <var>sharedWorkerGlobal</var>'s <span>name</span>, i.e. the value given to the
   <code id=shared-workers-and-the-sharedworkerglobalscope-interface:sharedworker><a href=#sharedworker>SharedWorker</a></code> constructor. Multiple <code id=shared-workers-and-the-sharedworkerglobalscope-interface:sharedworker-2><a href=#sharedworker>SharedWorker</a></code> objects can correspond
   to the same shared worker (and <code id=shared-workers-and-the-sharedworkerglobalscope-interface:sharedworkerglobalscope-2><a href=#sharedworkerglobalscope>SharedWorkerGlobalScope</a></code>), by reusing the same
   name.<dt><var>sharedWorkerGlobal</var> . <code id=dom-sharedworkerglobalscope-close>close</code>()<dd>Aborts <var>sharedWorkerGlobal</var>.</dl>

  

  <p>The following are the <a id=shared-workers-and-the-sharedworkerglobalscope-interface:event-handlers href=webappapis.html#event-handlers>event handlers</a> (and their corresponding <span>event handler event types</span>)  supported,
  as <span>event handler IDL attributes</span>, by objects implementing the
  <code id=shared-workers-and-the-sharedworkerglobalscope-interface:sharedworkerglobalscope-3><a href=#sharedworkerglobalscope>SharedWorkerGlobalScope</a></code> interface:</p>

  <table><thead><tr><th><a href=webappapis.html#event-handlers id=shared-workers-and-the-sharedworkerglobalscope-interface:event-handlers-2>イベントハンドラー</a> </th><th><span>イベントハンドラーイベント型</span>
   <tbody></th></tr><tr><td><dfn id=handler-sharedworkerglobalscope-onconnect><code>onconnect</code></dfn> </td><td> <code id=shared-workers-and-the-sharedworkerglobalscope-interface:event-workerglobalscope-connect-2><a href=indices.html#event-workerglobalscope-connect>connect</a></code>
  </td></tr></table>



  <h4 id=worker-event-loop><span class=secno>10.2.2</span> The event loop<a href=#worker-event-loop class=self-link></a></h4>

  <p>Each <code id=worker-event-loop:workerglobalscope><a href=#workerglobalscope>WorkerGlobalScope</a></code> object has a distinct <span>event loop</span>, separate
  from those used by <span>units of related
  similar-origin browsing contexts</span>. This <span>event loop</span> has no associated
  <a id=worker-event-loop:browsing-context href=browsers.html#browsing-context>browsing context</a>, and its <span>task queues</span> only have
  events, callbacks, and networking activity as <span>tasks</span>.</p>

  <p>Each <code id=worker-event-loop:workerglobalscope-2><a href=#workerglobalscope>WorkerGlobalScope</a></code> object also has a <dfn data-export="" data-dfn-type=dfn id=dom-workerglobalscope-closing data-dfn-for=WorkerGlobalScope>closing</dfn> flag,  initially
  false, but which can get set to true when the worker is requested to close.</p>

  <p>Once the <code id=worker-event-loop:workerglobalscope-3><a href=#workerglobalscope>WorkerGlobalScope</a></code>'s <a href=#dom-workerglobalscope-closing id=worker-event-loop:dom-workerglobalscope-closing>closing</a> flag is set to true, the <span>event
  loop</span>'s <span>task queues</span>  discard any
  further <span>tasks</span> that would be added to them (tasks already on the
  queue are unaffected except where otherwise specified). Effectively, once the <a href=#dom-workerglobalscope-closing id=worker-event-loop:dom-workerglobalscope-closing-2>closing</a> flag is true, timers stop firing,
  notifications for all pending background operations are dropped, etc.</p>



  


  <h4 id=runtime-script-errors-2><span class=secno>10.2.3</span> Runtime script errors<a href=#runtime-script-errors-2 class=self-link></a></h4>

  <p>Whenever an uncaught runtime script error occurs in one of the worker's scripts, if the error
  did not occur while handling a previous script error, the user agent 
  will <span>report the error</span> for that <span>script</span>, with the position (line number and column number) where the
  error occurred, using the <code id=runtime-script-errors-2:workerglobalscope><a href=#workerglobalscope>WorkerGlobalScope</a></code> object as the target.</p>

  <p>For shared workers, if the error is still <i>not handled</i>
  afterwards, the error may be reported to a developer console.</p>

  <p>For dedicated workers, if the error is still <i>not
  handled</i> afterwards, the error report propagates to the <code id=runtime-script-errors-2:worker><a href=#worker>Worker</a></code>
  object, then to any containing workers in the same fashion, eventually reaching the
  <code>Window</code> if it was never handled along the way.</p>

  

  <p class=note>Error reports propagate up
  to the chain of dedicated workers up to the original <code>Document</code>, even if some of the
  workers along this chain have been terminated and garbage collected.</p>

  


  <h4 id=creating-workers><span class=secno>10.2.4</span> Creating workers<a href=#creating-workers class=self-link></a></h4>

  
  <h5 id=properties-present-on-both-worker-and-sharedworker><span class=secno>10.2.4.1</span> Properties present on both <code id=properties-present-on-both-worker-and-sharedworker:worker><a href=#worker>Worker</a></code> and <code id=properties-present-on-both-worker-and-sharedworker:sharedworker><a href=#sharedworker>SharedWorker</a></code><a href=#properties-present-on-both-worker-and-sharedworker class=self-link></a></h5>

  

  <p>The following are the <a id=properties-present-on-both-worker-and-sharedworker:event-handlers href=webappapis.html#event-handlers>event handlers</a> (and their corresponding <span>event handler event types</span>)  supported,
  as <span>event handler IDL attributes</span>, by <code id=properties-present-on-both-worker-and-sharedworker:worker-2><a href=#worker>Worker</a></code> and
  <code id=properties-present-on-both-worker-and-sharedworker:sharedworker-2><a href=#sharedworker>SharedWorker</a></code> objects:</p>

  <table><thead><tr><th><a href=webappapis.html#event-handlers id=properties-present-on-both-worker-and-sharedworker:event-handlers-2>イベントハンドラー</a> </th><th><span>イベントハンドラーイベント型</span>
   <tbody></th></tr><tr><td><dfn id=handler-abstractworker-onerror><code>onerror</code></dfn> </td><td> <code id=properties-present-on-both-worker-and-sharedworker:event-error><a href=indices.html#event-error>error</a></code>
  </td></tr></table>


  


  <h5 id=dedicated-workers-and-the-worker-interface><span class=secno>10.2.4.2</span> Dedicated workers and the <code id=worker>Worker</code> interface<a href=#dedicated-workers-and-the-worker-interface class=self-link></a></h5>

  

  <dl class=domintro><dt><var>worker</var> = new <code id=dom-worker>Worker</code>(<var>scriptURL</var> [, <var>options</var> ])<dd>Returns a new <code id=dedicated-workers-and-the-worker-interface:worker><a href=#worker>Worker</a></code> object. <var>scriptURL</var> will be fetched and executed
   in the background, creating a new global environment for which <var>worker</var> represents the
   communication channel. <var>options</var> can be used to define the <span>name</span> of that global environment via the <code>name</code> option, primarily for debugging purposes. It can also ensure this new
   global environment supports JavaScript modules (specify <code>type: "module"</code>),
   and if that is specified, can also be used to specify how <var>scriptURL</var> is fetched through
   the <code>credentials</code> option.

   

   <dt><var>worker</var> . <code id=dom-worker-terminate>terminate</code>()<dd>Aborts <var>worker</var>'s associated global environment.<dt><var>worker</var> . <code id=dom-worker-postmessage>postMessage</code>(<var>message</var> [, <var>transfer</var> ])
   
   <dd>Clones <var>message</var> and transmits it to <var>worker</var>'s global environment.
   <var>transfer</var> can be passed as a list of objects that are to be transferred rather than
   cloned.</dl>

  

  <div class=example>

   <p>The <code id=dedicated-workers-and-the-worker-interface:dom-worker-postmessage><a href=#dom-worker-postmessage>postMessage()</a></code>
   method's first argument can be structured data:</p>

   <pre>worker.postMessage({opcode: 'activate', device: 1938, parameters: [23, 102]});</pre>

  </div>

  <p>The following are the <a id=dedicated-workers-and-the-worker-interface:event-handlers href=webappapis.html#event-handlers>event handlers</a> (and their corresponding <span>event handler event types</span>)  supported,
  as <span>event handler IDL attributes</span>, by objects implementing the <code id=dedicated-workers-and-the-worker-interface:worker-2><a href=#worker>Worker</a></code>
  interface:</p>

  <table><thead><tr><th><a href=webappapis.html#event-handlers id=dedicated-workers-and-the-worker-interface:event-handlers-2>イベントハンドラー</a> </th><th><span>イベントハンドラーイベント型</span>
   <tbody></th></tr><tr><td><dfn id=handler-worker-onmessage><code>onmessage</code></dfn> </td><td> <code id=dedicated-workers-and-the-worker-interface:event-message><a href=indices.html#event-message>message</a></code>
    </td></tr><tr><td><dfn id=handler-worker-onmessageerror><code>onmessageerror</code></dfn> </td><td> <code id=dedicated-workers-and-the-worker-interface:event-messageerror><a href=indices.html#event-messageerror>messageerror</a></code>
  </td></tr></table>

  


  <h5 id=shared-workers-and-the-sharedworker-interface><span class=secno>10.2.4.3</span> Shared workers and the <code id=sharedworker>SharedWorker</code> interface<a href=#shared-workers-and-the-sharedworker-interface class=self-link></a></h5>

  

  <dl class=domintro><dt><var>sharedWorker</var> = new <code id=dom-sharedworker>SharedWorker</code>(<var>scriptURL</var> [, <var>name</var> ])<dd>Returns a new <code id=shared-workers-and-the-sharedworker-interface:sharedworker><a href=#sharedworker>SharedWorker</a></code> object. <var>scriptURL</var> will be fetched and
   executed in the background, creating a new global environment for which <var>sharedWorker</var>
   represents the communication channel. <var>name</var> can be used to define the <span>name</span> of that global environment.<dt><var>sharedWorker</var> = new <code id=shared-workers-and-the-sharedworker-interface:dom-sharedworker><a href=#dom-sharedworker>SharedWorker</a></code>(<var>scriptURL</var> [, <var>options</var> ])<dd>Returns a new <code id=shared-workers-and-the-sharedworker-interface:sharedworker-2><a href=#sharedworker>SharedWorker</a></code> object. <var>scriptURL</var> will be fetched and
   executed in the background, creating a new global environment for which <var>sharedWorker</var>
   represents the communication channel. <var>options</var> can be used to define the <span>name</span> of that global environment via the <code>name</code> option. It can also ensure this new global environment supports JavaScript
   modules (specify <code>type: "module"</code>), and if that is specified, can also be
   used to specify how <var>scriptURL</var> is fetched through the <code>credentials</code> option.<dt><var>sharedWorker</var> . <code id=dom-sharedworker-port>port</code><dd>Returns <var>sharedWorker</var>'s <code>MessagePort</code> object which can be used to
   communicate with the global environment.</dl>

  


  <h4 id=navigator.hardwareconcurrency><span class=secno>10.2.5</span> Concurrent hardware capabilities<a href=#navigator.hardwareconcurrency class=self-link></a></h4><div class=status><input onclick=toggleStatus(this) value=⋰ type=button><p class=support><strong>Support:</strong> hardwareconcurrency<span class="and_chr yes"><span>Chrome for Android</span> <span>66+</span></span><span class="chrome yes"><span>Chrome</span> <span>37+</span></span><span class="ios_saf yes"><span>iOS Safari</span> <span>10.3+</span></span><span class="and_uc yes"><span>UC Browser for Android</span> <span>11.8+</span></span><span class="firefox yes"><span>Firefox</span> <span>48+</span></span><span class="ie no"><span>IE</span> <span>None</span></span><span class="op_mini no"><span>Opera Mini</span> <span>None</span></span><span class="samsung yes"><span>Samsung Internet</span> <span>4+</span></span><span class="safari yes"><span>Safari</span> <span>10.1+</span></span><span class="edge yes"><span>Edge</span> <span>15+</span></span><span class="android yes"><span>Android Browser</span> <span>62+</span></span><span class="opera yes"><span>Opera</span> <span>24+</span></span><p class=caniuse>Source: <a href="https://caniuse.com/#feat=hardwareconcurrency">caniuse.com</a></div>

  

  <dl class=domintro><dt><var>self</var> . <code>navigator</code> . <code id=dom-navigator-hardwareconcurrency>hardwareConcurrency</code><dd><p>Returns the number of logical processors potentially available to the user agent.</dl>

  

  <h3 id=apis-available-to-workers><span class=secno>10.3</span> APIs available to workers<a href=#apis-available-to-workers class=self-link></a></h3>

  


  <h4 id=the-workernavigator-object><span class=secno>10.3.1</span> The <code id=workernavigator>WorkerNavigator</code> interface<a href=#the-workernavigator-object class=self-link></a></h4>

  

  

  

  <p>The <code id=the-workernavigator-object:workernavigator><a href=#workernavigator>WorkerNavigator</a></code> interface implements a subset of the <code>Navigator</code>
  interface, consisting of the following APIs:</p>

  <ul class=brief><li><a href=system-state.html#client-identification>Client identification</a></li><li><a href=system-state.html#language-preferences> 言語の好み</a></li><li><a href=offline.html#navigator.online> ブラウザーの状態</a></li><li><a href=#navigator.hardwareconcurrency>Concurrent hardware capabilities</a></li></ul>

  

  <h4 id=worker-locations><span class=secno>10.3.2</span> The <code id=workerlocation>WorkerLocation</code> interface<a href=#worker-locations class=self-link></a></h4>

  

  <p>The <code id=worker-locations:workerlocation><a href=#workerlocation>WorkerLocation</a></code> interface is like the <code>Location</code> interface,
  but lacks the <code id=worker-locations:dom-location-assign><a href=history.html#dom-location-assign>assign()</a></code>, <code id=worker-locations:dom-location-replace><a href=history.html#dom-location-replace>replace()</a></code>, <code id=worker-locations:dom-location-reload><a href=history.html#dom-location-reload>reload()</a></code>,
  and <code id=worker-locations:dom-location-ancestororigins><a href=history.html#dom-location-ancestororigins>ancestorOrigins</a></code> members.</p>

  




  <nav><a href=web-messaging.html>← 9.4 Cross-document messaging</a> — <a href=./>目次</a> — <a href=webstorage.html>11 Web storage →</a></nav>
</body></html>